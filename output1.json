[
  {
    "id": "11",
    "name": "Khóa học Offline tại Hà Nội",
    "href": "https://www.vietjack.com/java/khoa-hoc-java-offline.jsp",
    "lesson": {
      "title": "Khóa học Java chất lượng cao tại VietJack",
      "content": "Khóa học Java Offline Thứ 6 của IMTATeam tại Hà Nội\nGiảng viên: Anh Nguyễn Thanh Tuyền, Cựu sinh viên Kỹ sư Tài năng, Đại học Bách Khoa Hà Nội.\nKhai giảng: Cuối tháng 10/2018\nChốt danh sách đăng ký: 25/10/2018\nĐịa điểm: Phòng 903 Lô B, Chung cư CT36 Định Công, Hà Nội.\nĐiện thoại liên hệ: 01689933602\nEmail: imtateam@gmail.com\nWebsite: imtacom.com\nFacebook: Nguyễn Thanh Tuyền\nNội dung khóa học:\nGiới thiệu mục đích khóa học, ngôn ngữ Java và yêu cầu thực tế.\nPhần Java Core: Ngôn ngữ Java.\nCollection và dự án quản lý đặt lịch rạp hát.\nLàm việc với database, dự án quản lý sinh viên với database.\nJSP/Servlet: Dự án JSP/Servlet đầu tiên, bài tập quản lý sinh viên bằng JSP/Servlet, ứng dụng dự án Bookstore với JSP/Servlet.\nLàm các dự án thực hành, dự án và phỏng vấn hướng tới đi làm.\nKhóa học trị giá 2.500.000 đồng.\nGiảm 300.000 đồng học phí cho các bạn nữ.\nGiảm 200.000 đồng cho nhóm bạn đăng ký cùng nhau.\nGiảm 200.000 đồng cho các bạn được học bổng học kỳ trước.\nHỗ trợ kiến thức về Java đến khi đi làm việc.\nYêu cầu đầu vào:\nCó kế hoạch học tập nghiêm túc, dành 2 giờ mỗi ngày cho Java trong thời gian khóa học.\nCó laptop.\nBiết trước ít nhất một ngôn ngữ lập trình bất kỳ (C, C++, Java, Python, C#, PHP).\nĐối tượng khóa học:\nCác bạn chuẩn bị tham gia các kỳ thi lấy chứng chỉ Java SCJP.\nCác bạn muốn tìm hiểu Java để học tiếp Android hoặc muốn trở thành một lập trình viên Java/J2EE/Java Web.\nCác bạn muốn tham gia các kỳ giống như thực tập doanh nghiệp, cùng làm các bài tập lớn Java Core và JSP với vài chục file class trở nên.\nCác bạn đang có nhu cầu trở thành lập trình viên chuyên nghiệp, chuẩn bị tham gia các kỳ phỏng vấn xin việc.\nCác bạn muốn tìm hiểu Java, phát triển các dự án mức độ trường đại học.\nCác bạn học ngành CNTT, Điện tử Viễn thông, Đa phương tiện, Điện/Điện tử có thể theo học khóa Java này.\nKhóa 9 nhận đăng ký đến trước ngày 25/10/2018.\nKhóa học offline tập trung làm các dự án thực hành, các dự án và phỏng vấn hướng tới đi làm.\nKhóa học online làm tài liệu khóa offline trong 4 buổi đầu tiên.\nKhóa offline không tập trung vào kiến thức Java Core và tập trung vào sử dụng các kiến thức đó thành các dự án giúp các bạn sinh viên tự tin đi làm.\nĐây không chỉ là một khóa học mà còn giúp các bạn định hướng, giúp các bạn cần những gì để đi làm bởi lập trình viên lâu năm.\nCác bạn học khóa offline sẽ được miễn phí khóa học Java Online của IMTATeam trên Udemy và hơn 10 khóa học trả phí khác.\nKhóa offline tương đương với độ khó của các bạn sinh viên ra trường và làm công ty 1 tháng về Java, khó hơn mức độ phỏng vấn nhiều."
    }
  },
  {
    "id": "21",
    "name": "Khóa học Java Online tại Udemy",
    "href": "https://www.vietjack.com/java/khoa-hoc-java-online.jsp",
    "lesson": {
      "title": "Khóa học Java online trên Udemy",
      "content": "Khóa học này phù hợp với những người muốn học lập trình Java. Bạn cần có máy tính để thực hành và biết ít nhất một ngôn ngữ lập trình khác trước đó như C, C++, Python, PHP hoặc Ruby ở mức cơ bản.\n\nKhóa học gồm gần 100 video bằng tiếng Việt, bạn có thể xem đi xem lại nhiều lần. Bạn có thể mua khóa học với giá 250.000 VNĐ và học mãi mãi.\n\nTác giả khóa học có nhiều kinh nghiệm dạy offline và làm việc tại các công ty lớn. Khóa học này được đánh giá 4,75/5 bởi các học viên.\n\nBạn có thể liên hệ với tác giả qua Facebook hoặc số điện thoại để mua khóa học. Trong vòng 30 ngày mua khóa học, nếu bạn không hài lòng, bạn có thể yêu cầu lấy lại tiền."
    }
  },
  {
    "id": "12",
    "name": "Giới thiệu Java",
    "href": "https://www.vietjack.com/java/index.jsp",
    "lesson": {
      "title": "Học Java cơ bản và nâng cao",
      "content": "Trong khóa học trực tuyến tại imtateam, chúng tôi sẽ cung cấp hơn 250 ví dụ về Java được sử dụng phổ biến trong quá trình thực hành. Bạn có thể tham khảo loạt bài ví dụ này để dễ dàng hơn khi học về Java. Loạt bài hướng dẫn của chúng tôi dựa trên nguồn tài liệu của Tutorialspoint.\n\nChúng tôi sẽ hướng dẫn bạn từ các bài học cơ bản đến nâng cao, bao gồm các chủ đề như Collection, Set, Hashcode, Equals, JDBC, Package, Constructor, Vòng lặp, Regular Expression, v.v.\n\nĐể giúp bạn quyết định nên tham gia khóa học trực tuyến hay ngoại tuyến tại Hà Nội, chúng tôi cung cấp 8 video miễn phí để bạn xem thử. Bạn có thể xem các video demo tại địa chỉ video demo.\n\nNếu bạn ở xa hoặc không có điều kiện về thời gian, bạn có thể tham dự khóa học trực tuyến để chủ động cho việc học tập trong năm 2018. Giá khóa học chỉ còn 200k. Bạn có thể liên hệ với chúng tôi qua Facebook (fb.com/tuyenimta) để thanh toán chuyển khoản hoặc thẻ điện thoại.\n\nKhóa học được giảng dạy bằng tiếng Việt với gần 100 video. Bạn có thể chủ động học bất cứ lúc nào và xem mãi mãi. Thông tin khóa học tại khóa học Java trực tuyến trên Udemy.\n\nĐối với những bạn ở Hà Nội, chúng tôi có các khóa học ngoại tuyến. Bạn có thể xem các bạn khóa 6 được học gì và khóa 7 đang tuyển sinh đến ngày 20/06. Chúng tôi sẽ làm lớn hơn các dự án nhé. Video một phần các dự án khóa 6.\n\nJava là một trong những ngôn ngữ được dùng phổ biến nhất trên thế giới, đặc biệt cho các ứng dụng web client-server. Theo thống kê, trên thế giới có khoảng 9 triệu lập trình viên Java. Java là ngôn ngữ lập trình máy tính có tính chất hướng đối tượng dựa trên các lớp, thường được sử dụng cho các hệ thống có tính độc lập cao. Nó được sử dụng để hướng tới các lập trình viên viết ứng dụng \"write one run everywhere\" (viết một lần chạy mọi nơi), nghĩa là đoạn code Java sau khi được biên dịch có thể chạy được trên tất cả các nền tảng hỗ trợ Java mà không cần phải được biên dịch lại. Các ứng dụng Java sau khi đã được biên dịch thành bytecode có thể chạy trên bất kỳ máy ảo Java nào (Java Virtual Machine)."
    }
  },
  {
    "id": "22",
    "name": "Java là gì?",
    "href": "https://www.vietjack.com/java/java_la_gi.jsp",
    "lesson": {
      "title": "Java là gì",
      "content": "Java có thể được sử dụng để tạo nhiều loại ứng dụng khác nhau, bao gồm:\n\n* **Ứng dụng di động:** Được tạo cho các thiết bị di động như điện thoại thông minh và máy tính bảng. Các ứng dụng này thường được viết bằng Android hoặc Java.\n* **Ứng dụng doanh nghiệp:** Được sử dụng trong các doanh nghiệp để hỗ trợ các quy trình kinh doanh. Các ứng dụng này thường được viết bằng Java EE.\n* **Ứng dụng web:** Được chạy trên máy chủ web và tạo các trang web động. Các ứng dụng này thường được viết bằng Java Servlet, JSP, Struts hoặc JSF.\n* **Ứng dụng độc lập:** Được cài đặt trên máy tính và không yêu cầu máy chủ web. Các ứng dụng này thường được viết bằng AWT hoặc Swing.\n\nJava cũng có thể được sử dụng để tạo các nền tảng, là các môi trường phần cứng hoặc phần mềm mà trong đó một chương trình chạy. Java Runtime Environment (JRE) và Java API là những ví dụ về các nền tảng Java.\n\nJava là một ngôn ngữ lập trình bảo mật cao, hướng đối tượng, bậc cao và mạnh mẽ. Nó là một ngôn ngữ lập trình và là một nền tảng.class Simple{ public static void main(String args[]){\nSystem.out.println(\"Hello World\"); } }\n\n"
    }
  },
  {
    "id": "32",
    "name": "Lịch sử Java",
    "href": "https://www.vietjack.com/java/lich_su_java.jsp",
    "lesson": {
      "title": "Lịch sử Java",
      "content": "Java là một ngôn ngữ lập trình đã trải qua quá trình phát triển và cải tiến qua nhiều năm. Phiên bản hiện tại của Java là Java SE 8, được công bố vào năm 2014. Trước đó, Java SE 7 được công bố vào năm 2011, Java SE 6 vào năm 2006, J2SE 5.0 vào năm 2004, J2SE 1.4 vào năm 2002, J2SE 1.3 vào năm 2000, J2SE 1.2 vào năm 1998, JDK 1.1 vào năm 1997, JDK 1.0 vào năm 1996 và JDK Alpha và Beta vào năm 1995.\n\nJava được phát triển lần đầu tiên bởi James Gosling tại Sun Microsystems (hiện là công ty con của Oracle Corporation) và được công bố vào năm 1995. Tên \"Java\" được lấy cảm hứng từ một loại cà phê được sản xuất tại đảo Java ở Indonesia.\n\nBan đầu, Java được gọi là GreenTalk và có đuôi là \"gt\". Sau đó, nó được đổi tên thành Oak và được phát triển như một phần của Green Project. Năm 1995, Oak được đổi tên thành Java.\n\nJava được thiết kế ban đầu cho các hệ thống nhỏ có thể nhúng vào trong các thiết bị điện tử như set-top box. Tuy nhiên, sau đó Java đã được mở rộng để sử dụng trong lập trình mạng, các thiết bị di động, trò chơi và các giải pháp về e-business.\n\nJava là một ngôn ngữ lập trình phổ biến và được sử dụng rộng rãi trên thế giới. Nó được đánh giá cao vì tính đa nền tảng, bảo mật và khả năng mở rộng."
    }
  },
  {
    "id": "42",
    "name": "Tổng quan",
    "href": "https://www.vietjack.com/java/tong_quan_ve_java.jsp",
    "lesson": {
      "title": "Tổng quan về Java",
      "content": "- Thread là một chương trình riêng biệt thực thi đồng thời, cho phép Java xử lý nhiều tác vụ cùng lúc.\n- Multithreading là một lợi thế chính của Java, cho phép chia sẻ cùng bộ nhớ và quan trọng cho các ứng dụng đa phương tiện và web.\n- Java hỗ trợ tạo các ứng dụng phân tán bằng cách sử dụng Java RMI và EJB, cho phép truy cập các tệp từ bất kỳ thiết bị nào trên Internet.\n- Java sử dụng trình biên dịch Just-in-Time để nâng cao hiệu suất và hỗ trợ debug dễ dàng, giúp phát hiện lỗi nhanh chóng.\n- Java bytecode có thể được thực thi trên bất kỳ nền tảng nào mà không phụ thuộc vào trình triển khai cụ thể.\n- Java là một ngôn ngữ robust, sử dụng hệ quản lý bộ nhớ mạnh mẽ, ít con trỏ hơn và có trình dọn rác tự động.\n- Java cung cấp các tính năng bảo mật thông qua SSL, JAAS và Security Manager, giúp kiểm soát quyền truy cập tài nguyên và xác minh mã bytecode.\n- Java là một ngôn ngữ toàn nền tảng, cho phép mã Java chạy trên nhiều nền tảng khác nhau như Windows, Linux, Sun Solaris và macOS.\n- Java cung cấp các khái niệm lập trình hướng đối tượng như lớp (class), đối tượng (object), tính bao đóng (encapsulation), tính trừu tượng (abstraction), tính đa hình (polymorphism) và tính kế thừa (inheritance).\n- Java đơn giản hóa việc phát triển phần mềm bằng cách loại bỏ các đặc điểm gây bối rối và hiếm khi được sử dụng, chẳng hạn như con trỏ tường minh và nạp chồng toán tử."
    }
  },
  {
    "id": "52",
    "name": "Cài đặt Java",
    "href": "https://www.vietjack.com/java/cai_dat_java.jsp",
    "lesson": {
      "title": "Cài đặt môi trường Java",
      "content": "- Để bắt đầu với Java, bạn cần cài đặt Java trên máy tính của mình.\n- Bạn có thể tải xuống Java từ trang web chính thức của Java.\n- Sau khi tải xuống, bạn cần chạy trình cài đặt Java.\n- Trình cài đặt Java sẽ hướng dẫn bạn qua quá trình cài đặt.\n- Sau khi cài đặt Java, bạn cần thiết lập các biến môi trường để trỏ tới các tệp nhị phân của Java.\n- Bạn có thể làm điều này bằng cách chỉnh sửa tệp PATH của hệ thống của mình.\n- Sau khi thiết lập các biến môi trường, bạn có thể bắt đầu viết và chạy các chương trình Java.\n- Bạn có thể sử dụng trình soạn thảo văn bản đơn giản như Notepad để viết các chương trình Java.\n- Để chạy một chương trình Java, bạn cần sử dụng trình biên dịch Java.\n- Trình biên dịch Java sẽ biên dịch chương trình Java của bạn thành mã máy.\n- Sau khi chương trình Java của bạn đã được biên dịch, bạn có thể chạy nó bằng cách sử dụng trình chạy Java.\n- Trình chạy Java sẽ thực thi chương trình Java của bạn."
    }
  },
  {
    "id": "62",
    "name": "Cách thiết lập Path",
    "href": "https://www.vietjack.com/java/cach_thiet_lap_path_trong_java.jsp",
    "lesson": {
      "title": "Cách thiết lập PATH trong Java",
      "content": "Bạn có thể tham khảo thêm các thiết lập classpath tại địa chỉ https://www.oracle.com/java/technologies/javase-jdk16-downloads.html.\n\nĐể thiết lập classpath, bạn có thể làm theo các bước sau:\n\n1. Vào My Computer > Properties > Advanced tab > Environment Variables.\n2. Tạo một tab mới có tên là User Variable.\n3. Trong ô Variable Name, nhập \"Path\".\n4. Trong ô Variable Value, nhập đường dẫn đến thư mục bin của cài đặt Java. Ví dụ: \"C:\\Program Files\\Java\\jdk16.0.1\\bin\".\n5. Nhấp vào OK để lưu các thay đổi.\n6. Khởi động lại máy tính để các thay đổi có hiệu lực.\n\nThiết lập classpath trong Java là rất cần thiết nếu bạn cần sử dụng các công cụ liên quan đến javac hoặc java dùng terminal."
    }
  },
  {
    "id": "72",
    "name": "Chương trình Hello World",
    "href": "https://www.vietjack.com/java/chuong_trinh_java_dau_tien_hello_world.jsp",
    "lesson": {
      "title": "Chương trình Java đầu tiên Hello World",
      "content": "Để thực thi một chương trình Java, bạn cần phải thiết lập path của thư mục JDKbin. Nếu bạn chưa cài đặt JDK, bạn có thể tải xuống và cài đặt nó. Sau đó, bạn có thể tạo một chương trình Java đơn giản bằng cách tạo một lớp chứa phương thức main. Phương thức main là điểm khởi đầu của chương trình Java.\n\nĐể biên dịch chương trình, bạn sử dụng lệnh javac. Để chạy chương trình, bạn sử dụng lệnh java. Bạn có thể truyền các tham số dòng lệnh cho chương trình bằng cách sử dụng đối số string args.\n\nPhương thức main có thể có nhiều dạng khác nhau. Ví dụ, bạn có thể sử dụng varargs để truyền một số lượng tùy ý các tham số cho phương thức main. Bạn cũng có thể sử dụng các modifiers khác nhau để thay đổi hành vi của phương thức main.\n\nTrong chương này, bạn sẽ học cách viết một chương trình Java đơn giản. Bạn cũng sẽ học về các thành phần khác nhau của một chương trình Java, chẳng hạn như lớp, phương thức và biến.class Simple{ public static void main(String args[]){\nSystem.out.println(\"Hello World\"); } }\n\n, static public void main(String args[])\n\n, public static void main(String[] args) public static void main(String []args)\npublic static void main(String args[])\n\n, public static void main(String... args)\n\n, class A{ static public void main(String... args){ System.out.println(\"Hello\nWorld\"); } };\n\n, public static void main(String[] args) public static void main(String []args)\npublic static void main(String args[]) public static void main(String... args)\nstatic public void main(String[] args) public static final void main(String[]\nargs) final public static void main(String[] args) final strictfp public\nstatic void main(String[] args)\n\n, public void main(String[] args) static void main(String[] args) public void\nstatic main(String[] args) abstract public static void main(String[] args)\n\n"
    }
  },
  {
    "id": "82",
    "name": "Phân tích chương trình Hello World",
    "href": "https://www.vietjack.com/java/phan_tich_chuong_trinh_java_hello_world.jsp",
    "lesson": {
      "title": "Phân tích nội tại chương trình Hello World trong Java",
      "content": "Để thực thi một chương trình Java, bạn cần nhập lệnh `java simple` vào cửa sổ lệnh. Để biên dịch chương trình, bạn cần nhập lệnh `javac hardjava`. Nếu lớp không phải là lớp public, bạn có thể làm theo các bước được minh họa trong sơ đồ dưới đây.\n\nInterpreter đọc luồng mã byte và thực thi các hướng dẫn. Bytecode vertifier kiểm tra các đoạn mã để xem có hay không các phần mã không hợp lệ có truy cập không hợp lệ tới các đối tượng. Classloader là hệ thống con của JVM được sử dụng để tải các tệp lớp.\n\nTại thời điểm chạy, các bước sau được thực hiện:\n\n1. Tại thời điểm biên dịch, tệp Java được biên dịch bởi trình biên dịch Java. Trình biên dịch Java không tương tác với hệ điều hành và chuyển đổi mã Java thành mã byte.\n2. Trong chương trước, chúng ta đã học cách viết, biên dịch và chạy chương trình Hello World trong Java. Ở đây, chúng ta sẽ tiếp tục tìm hiểu những gì xảy ra trong khi biên dịch và chạy một chương trình Java.\n3. Ngoài ra, bạn sẽ thấy một số câu hỏi liên quan đến chương trình Java đầu tiên này."
    }
  },
  {
    "id": "92",
    "name": "Cú pháp Java cơ bản",
    "href": "https://www.vietjack.com/java/cu_phap_java_co_ban.jsp",
    "lesson": {
      "title": "Cú pháp Java cơ bản",
      "content": "- Java cung cấp hai lệnh println và print để hiển thị thông tin trên màn hình. Lệnh println sẽ di chuyển con trỏ xuống dòng tiếp theo, trong khi lệnh print giữ nguyên vị trí con trỏ trên cùng một dòng.\n- Interface là một hợp đồng giữa các đối tượng về cách giao tiếp với nhau. Interface định nghĩa các phương thức mà các subclass phải sử dụng, nhưng sự thực thi của các phương thức lại hoàn toàn là các subclass.\n- Kế thừa cho phép bạn tái sử dụng các trường và các phương thức của class đang tồn tại mà không cần phải viết lại code trong class mới.\n- Enum là một danh sách các hằng số được đặt tên. Enum được giới thiệu bởi Java 5.0 và giới hạn số lượng các biến bằng cách định nghĩa trước các biến trong danh sách được liệt kê gọi là enums.\n- Mảng là đối tượng lưu trữ nhiều biến với chung một kiểu dữ liệu. Mặc dù vậy, một mảng bản thân nó cũng là một đối tượng trong bộ nhớ.\n- Java có hai loại modifier: access modifier và non-access modifier. Access modifier bao gồm default, public, protected và private. Non-access modifier bao gồm final, abstract và strictfp.\n- Identifier là tên được sử dụng với các class, biến cũng như phương thức. Identifier phải tuân theo một số quy tắc, chẳng hạn như phải bắt đầu bằng một chữ cái, không được chứa khoảng trắng và không được là từ khóa.\n- Java là chương trình phân biệt chữ hoa chữ thường, điều đó có nghĩa là \"Hello\" và \"hello\" mang những ý nghĩa khác nhau trong Java.\n- Qui ước đặt tên trong Java là một quy tắc bạn cần theo khi quyết định đặt tên nào cho định danh identifier của mình. Qui ước đặt tên không bắt buộc, nhưng nó giúp cho code của bạn dễ đọc và dễ hiểu hơn.\n- Biến là một ô nhớ được sử dụng để lưu trữ dữ liệu. Mỗi đối tượng có một tập các biến duy nhất, mỗi trạng thái của đối tượng được khởi tạo bởi các giá trị và gán với những biến.\n- Phương thức là một hành vi. Một lớp có thể bao gồm nhiều phương thức. Trong mỗi phương thức có những phép toán logic, dữ liệu được xử lý và tất cả các hành động được thực thi.\n- Lớp có thể được định nghĩa như một bản thiết kế mẫu mà có thể mô tả các trạng thái, hành vi của một đối tượng mà nó hỗ trợ.\n- Đối tượng có các trạng thái và hành vi. Ví dụ, một con chó có các trạng thái của màu da, tên, tuổi, thức ăn cũng như các hành vi như sủa, ăn, vẫy đuôi.**Từ khóa** trong Java là những từ được sử dụng để xác định các hành vi cụ thể của chương trình. Chúng được sử dụng để tạo ra các lệnh, cấu trúc điều khiển, các kiểu dữ liệu, các lớp và các thành viên của lớp.\n\nMột số từ khóa phổ biến trong Java bao gồm:\n\n* **assert:** Được sử dụng để khẳng định một điều kiện nào đó là đúng. Nếu điều kiện không đúng, chương trình sẽ ném ra một ngoại lệ `AssertionError`.\n* **boolean:** Kiểu dữ liệu Boolean có thể có hai giá trị: true hoặc false.\n* **break:** Được sử dụng để thoát khỏi một vòng lặp hoặc câu lệnh switch.\n* **byte:** Kiểu dữ liệu byte có thể lưu trữ các giá trị từ -128 đến 127.\n* **case:** Được sử dụng trong câu lệnh switch để xác định một trường hợp cụ thể.\n* **catch:** Được sử dụng để bắt một ngoại lệ.\n* **char:** Kiểu dữ liệu char có thể lưu trữ một ký tự Unicode.\n* **class:** Được sử dụng để tạo một lớp mới.\n* **const:** Được sử dụng để khai báo một hằng số.\n* **continue:** Được sử dụng để bỏ qua phần còn lại của vòng lặp hiện tại và tiếp tục với vòng lặp tiếp theo.\n* **default:** Được sử dụng trong câu lệnh switch để xác định trường hợp mặc định.\n* **do:** Được sử dụng để tạo một vòng lặp do-while.\n* **double:** Kiểu dữ liệu double có thể lưu trữ các giá trị số thực có độ chính xác cao.\n* **else:** Được sử dụng để tạo một câu lệnh if-else.\n* **enum:** Được sử dụng để tạo một kiểu dữ liệu liệt kê.\n* **extends:** Được sử dụng để chỉ ra rằng một lớp là lớp con của một lớp khác.\n* **final:** Được sử dụng để khai báo một biến hoặc phương thức không thể thay đổi giá trị.\n* **finally:** Được sử dụng để tạo một khối finally, luôn được thực thi bất kể có ngoại lệ xảy ra hay không.\n* **float:** Kiểu dữ liệu float có thể lưu trữ các giá trị số thực có độ chính xác thấp hơn double.\n* **for:** Được sử dụng để tạo một vòng lặp for.\n* **goto:** Được sử dụng để chuyển đến một nhãn đã được khai báo trước đó trong chương trình.\n* **if:** Được sử dụng để tạo một câu lệnh if.\n* **implements:** Được sử dụng để chỉ ra rằng một lớp triển khai một giao diện.\n* **import:** Được sử dụng để nhập một lớp hoặc gói từ một thư viện khác.\n* **instanceof:** Được sử dụng để kiểm tra xem một đối tượng có thuộc về một lớp hoặc giao diện cụ thể hay không.\n* **int:** Kiểu dữ liệu int có thể lưu trữ các giá trị số nguyên từ -2^31 đến 2^31-1.\n* **interface:** Được sử dụng để tạo một giao diện.\n* **long:** Kiểu dữ liệu long có thể lưu trữ các giá trị số nguyên từ -2^63 đến 2^63-1.\n* **native:** Được sử dụng để khai báo một phương thức được triển khai bằng ngôn ngữ gốc (ví dụ: C hoặc C++).\n* **new:** Được sử dụng để tạo một đối tượng mới.\n* **package:** Được sử dụng để tạo một gói mới.\n* **private:** Được sử dụng để chỉ ra rằng một biến, phương thức hoặc lớp chỉ có thể được truy cập trong lớp mà nó được khai báo.\n* **protected:** Được sử dụng để chỉ ra rằng một biến, phương thức hoặc lớp chỉ có thể được truy cập trong lớp mà nó được khai báo và các lớp con của nó.\n* **public:** Được sử dụng để chỉ ra rằng một biến, phương thức hoặc lớp có thể được truy cập từ bất kỳ nơi nào trong chương trình.\n* **return:** Được sử dụng để trả về giá trị từ một phương thức.\n* **short:** Kiểu dữ liệu short có thể lưu trữ các giá trị số nguyên từ -2^15 đến 2^15-1.\n* **static:** Được sử dụng để chỉ ra rằng một biến, phương thức hoặc lớp thuộc về lớp chứ không thuộc về một đối tượng cụ thể.\n* **strictfp:** Được sử dụng để chỉ ra rằng một biểu thức số học phải được đánh giá theo cách chính xác, mà không có bất kỳ lỗi làm tròn nào.\n* **super:** Được sử dụng để tham chiếu đến lớp cha của lớp hiện tại.\n* **switch:** Được sử dụng để tạo một câu lệnh switch.\n* **synchronized:** Được sử dụng để chỉ ra rằng một phương thức hoặc khối mã phải được thực thi bởi một luồng duy nhất tại một thời điểm.\n* **this:** Được sử dụng để tham chiếu đến đối tượng hiện tại.\n* **throw:** Được sử dụng để ném một ngoại lệ.\n* **throws:** Được sử dụng để chỉ ra rằng một phương thức có thể ném một ngoại lệ cụ thể.\n* **transient:** Được sử dụng để chỉ ra rằng một biến không nên được lưu vào đĩa khi đối tượng được tuần tự hóa.\n* **try:** Được sử dụng để tạo một khối try-catch.\n* **void:** Được sử dụng để chỉ ra rằng một phương thức không trả về giá trị.\n* **volatile:** Được sử dụng để chỉ ra rằng một biến có thể được thay đổi bởi nhiều luồng cùng một lúc.\n* **while:** Được sử dụng để tạo một vòng lặp while.class FreshJuice { enum FreshJuiceSize{ SMALL, MEDIUM, LARGE } FreshJuiceSize\nsize; } public class FreshJuiceTest { public static void main(String args[]){\nFreshJuice juice = new FreshJuice(); juice.size = FreshJuice.\nFreshJuiceSize.MEDIUM ; System.out.println(\"Size: \" + juice.size); } }\n\n, Size: MEDIUM\n\n, public class MyFirstJavaProgram{ /* Chuong trinh in Hello World. * Day la vi\ndu ve comment gom nhieu dong. */ public static void main(String []args){ // Vi\ndu thu nhat ve comment co mot dong. /* Vi du thu hai ve comment co mot dong.\n*/ System.out.println(\"Hello World\"); } }\n\n, package edu.doannhg.basic; // vi du phan biet hai lenh print va println class\nTest { public static void main(String args[]) { // lenh print\nSystem.out.print(\"VietJack \"); System.out.print(\"chuc cac ban \");\nSystem.out.print(\"hoc tot!!!\"); System.out.print(\"\\n---------------\\n\"); //\nlenh println System.out.println(\"VietJack \"); System.out.println(\"chuc cac ban\n\"); System.out.println(\"hoc tot!!!\"); } }\n\n, VietJack chuc cac ban hoc tot!!! \\--------------- VietJack chuc cac ban hoc\ntot!!!\n\n"
    }
  },
  {
    "id": "102",
    "name": "JDK, JRE và JVM",
    "href": "https://www.vietjack.com/java/gioi_thieu_jdk_jre_jvm_trong_java.jsp",
    "lesson": {
      "title": "Giới thiệu JDK, JRE và JVM trong Java",
      "content": "- JDK (Java Development Kit): Bao gồm JRE cùng các công cụ phát triển.\n- JRE (Java Runtime Environment): Cung cấp môi trường chạy cho các chương trình Java.\n- JVM (Java Virtual Machine): Máy ảo Java thực thi bytecode Java.\n\n**Cấu trúc bên trong của JVM**\n\n- Classloader: Tải các file class.\n- Memory Area: Khu vực bộ nhớ chứa dữ liệu runtime.\n- Execution Engine: Thực thi code Java.\n\n**Các tác vụ chính của JVM**\n\n- Cung cấp môi trường chạy cho các chương trình Java.\n- Thực thi code Java.\n- Kiểm tra code Java.\n- Tải code Java.\n\n**Sự khác biệt giữa JDK, JRE và JVM**\n\n- JDK phụ thuộc nền tảng vì cấu hình của mỗi hệ điều hành khác nhau, nhưng Java độc lập nền tảng.\n- JRE và JVM phụ thuộc nền tảng.\n- JDK bao gồm JRE và các công cụ phát triển.\n- JRE bao gồm JVM và các thư viện cần thiết để chạy các chương trình Java.\n- JVM là máy ảo Java thực thi bytecode Java."
    }
  },
  {
    "id": "112",
    "name": "Biến trong Java",
    "href": "https://www.vietjack.com/java/bien_trong_java.jsp",
    "lesson": {
      "title": "Các kiểu biến trong Java",
      "content": "- Các biến static (biến lớp) được khai báo với từ khóa static trong một lớp nhưng ở bên ngoài một phương thức, constructor hoặc một khối.\n- Các thuộc tính có thể được truy cập một cách trực tiếp bởi việc gọi tên biến bên trong lớp đó. Tuy nhiên, với các phương thức static và các lớp khác nhau khi thuộc tính được cung cấp khả năng truy cập nó nên được gọi bởi sử dụng tên đầy đủ hợp lệ như sau: objectreference.variablename.\n- Các thuộc tính có các giá trị mặc định với các số giá trị mặc định là 0, với boolean là false và với đối tượng là null. Các giá trị có thể được gán trong khi khai báo hoặc trong constructor.\n- Các thuộc tính là nhìn thấy với tất cả các phương thức, constructor và khối trong lớp. Tuy nhiên, tính nhìn thấy cho các lớp phụ có thể được cung cấp cho những biến này với sự sử dụng của chỉ định truy cập.\n- Chỉ định truy cập access modifier có thể được cung cấp cho các thuộc tính.\n- Các thuộc tính có thể được khai báo trong mức độ lớp trước hoặc sau khi sử dụng.\n- Các thuộc tính giữ các giá trị mà phải được tham chiếu bởi nhiều hơn một phương thức, constructor hoặc khối hoặc các phần chủ yếu của trạng thái đối tượng mà phải có mặt xuyên suốt lớp đó.\n- Các thuộc tính được tạo khi một đối tượng được tạo bởi sử dụng từ khóa new và bị hủy khi đối tượng bị hủy.\n- Khi một không gian nhớ được cấp phát cho một đối tượng trong một heap (một dạng cấu trúc hàng đợi có thứ tự ưu tiên), một slot cho mỗi giá trị thuộc tính được tạo ra.\n- Các biến local được thực thi nội bộ.\n- Các biến local chỉ nhìn thấy trong phương thức constructor hoặc khối được khai báo.\n- Chỉ định truy cập access modifier có thể không được sử dụng cho các biến local.\n- Các biến được tạo khi phương thức constructor hoặc khối được nhập và biến bị hủy khi phương thức constructor hoặc khối kết thúc.\n- Các biến được khai báo trong các phương thức constructor hoặc khối.kieu_du_lieu bien [ = giatri][, bien [= giatri] ...] ;\n\n, int a, b, c; // Khai bao ba bien kieu int la a, b, và c. int a = 5, b = 7; //\nVi du ve khoi tao bien byte A = 11; // Khoi tao mot bien kieu byte ten la A.\ndouble pi = 3.14159; // Khai bao va gan mot gia tri cua PI. char nam = 'b'; //\nBien nam duoc khoi tao voi gia tri 'a'.\n\n, public class Test{ public void tuoiCon(){ int tuoi = 0; tuoi = tuoi + 10;\nSystem.out.println(\"Tuoi con la : \" + tuoi); } public static void main(String\nargs[]){ Test test = new Test(); test.tuoiCon(); } }\n\n, public class Test{ public void tuoiCon(){ int tuoi; tuoi = tuoi + 10;\nSystem.out.println(\"Tuoi con la : \" + tuoi); } public static void main(String\nargs[]){ Test test = new Test(); test.tuoiCon(); } }\n\n, Test.java:4:variable number might not have been initialized tuoi = tuoi + 10;\n^ 1 error\n\n, import java.io.*; public class Student{ // Bien instance nay la nhin thay cho\nbat ky lop con nao. public String ten; // Bien hocphi la chi nhin thay cho lop\nStudent. private double hocphi; // Bien ten duoc gan trong constructor. public\nStudent (String tenSV){ ten = tenSV; } // Bien hocphi duoc gan mot gia tri.\npublic void setHocPhi(double hp){ hocphi = hp; } // Phuong thuc nay in chi\ntiet ve Student. public void inThongTin(){ System.out.println(\"Ho va ten: \" +\nten ); System.out.println(\"Hoc phi: \" + hocphi); } public static void\nmain(String args[]){ Student sv1 = new Student(\"Nguyen Van Doan\");\nsv1.setHocPhi(4000); sv1.inThongTin(); } }\n\n, Ho va ten: Nguyen Van Doan Hoc phi: 4000.0\n\n, import java.io.*; public class Student{ // Bien hocphi la mot bien private\nstatic private static double hocphi; // FACULTY la mot constant public static\nfinal String FACULTY = \"KhoaIT \"; public static void main(String args[]){\nhocphi = 4000; System.out.println(FACULTY+\"hocphi trung binh:\"+hocphi); } }\n\n, KhoaIT hocphi trung binh:4000\n\n"
    }
  },
  {
    "id": "122",
    "name": "Kiểu dữ liệu",
    "href": "https://www.vietjack.com/java/kieu_du_lieu_trong_java.jsp",
    "lesson": {
      "title": "Kiểu dữ liệu trong Java",
      "content": "Trong Java, có hai loại kiểu dữ liệu: kiểu dữ liệu gốc (primitive data types) và kiểu dữ liệu tham chiếu (reference data types).\n\nKiểu dữ liệu gốc là các kiểu dữ liệu cơ bản được hỗ trợ bởi Java và được định nghĩa sẵn trong ngôn ngữ. Có 8 kiểu dữ liệu gốc trong Java, bao gồm:\n\n* **byte:** Kiểu dữ liệu byte lưu trữ các số nguyên có kích thước 8 bit. Giá trị nhỏ nhất của byte là -128 và giá trị lớn nhất là 127.\n* **short:** Kiểu dữ liệu short lưu trữ các số nguyên có kích thước 16 bit. Giá trị nhỏ nhất của short là -32768 và giá trị lớn nhất là 32767.\n* **int:** Kiểu dữ liệu int lưu trữ các số nguyên có kích thước 32 bit. Giá trị nhỏ nhất của int là -2147483648 và giá trị lớn nhất là 2147483647.\n* **long:** Kiểu dữ liệu long lưu trữ các số nguyên có kích thước 64 bit. Giá trị nhỏ nhất của long là -9223372036854775808 và giá trị lớn nhất là 9223372036854775807.\n* **float:** Kiểu dữ liệu float lưu trữ các số thực có kích thước 32 bit. Giá trị nhỏ nhất của float là -3.4028235E38 và giá trị lớn nhất là 3.4028235E38.\n* **double:** Kiểu dữ liệu double lưu trữ các số thực có kích thước 64 bit. Giá trị nhỏ nhất của double là -1.7976931348623157E308 và giá trị lớn nhất là 1.7976931348623157E308.\n* **char:** Kiểu dữ liệu char lưu trữ các ký tự Unicode có kích thước 16 bit. Giá trị nhỏ nhất của char là '\\u0000' và giá trị lớn nhất là '\\uffff'.\n* **boolean:** Kiểu dữ liệu boolean lưu trữ các giá trị true hoặc false.\n\nKiểu dữ liệu tham chiếu là các kiểu dữ liệu không phải là kiểu dữ liệu gốc. Kiểu dữ liệu tham chiếu lưu trữ các tham chiếu đến các đối tượng trong bộ nhớ. Có nhiều kiểu dữ liệu tham chiếu khác nhau trong Java, bao gồm:\n\n* **class:** Kiểu dữ liệu class lưu trữ các đối tượng của một lớp.\n* **interface:** Kiểu dữ liệu interface lưu trữ các đối tượng của một giao diện.\n* **array:** Kiểu dữ liệu array lưu trữ các mảng.\n* **enum:** Kiểu dữ liệu enum lưu trữ các liệt kê.\n\nCác kiểu dữ liệu trong Java được sử dụng để lưu trữ các giá trị khác nhau. Kiểu dữ liệu gốc được sử dụng để lưu trữ các giá trị đơn giản như số nguyên, số thực, ký tự và giá trị boolean. Kiểu dữ liệu tham chiếu được sử dụng để lưu trữ các giá trị phức tạp như đối tượng, mảng và liệt kê.- **Boolean:** Loại giữ liệu bool, false là mặc định, kích thước mặc định là 1 bit.\n- **Char:** Loại giữ liệu char, '\\u0000' là mặc định, kích thước mặc định là 2 byte.\n- **Byte:** Loại giữ liệu byte, 0 là mặc định, kích thước mặc định là 1 byte.\n- **Short:** Loại giữ liệu short, 0 là mặc định, kích thước mặc định là 2 byte.\n- **Int:** Loại giữ liệu int, 0 là mặc định, kích thước mặc định là 4 byte.\n- **Long:** Loại giữ liệu long, 0L là mặc định, kích thước mặc định là 8 byte.\n- **Float:** Loại giữ liệu float, 0.0f là mặc định, kích thước mặc định là 4 byte.\n- **Double:** Loại giữ liệu double, 0.0d là mặc định, kích thước mặc định là 8 byte.\n- **Ký hiệu:** Loại giữ liệu biểu diễn ký tụ, các ký hiệu bao gồm:\n  - \\n: Newline (0x0a)\n  - \\r: Carriage return (0x0d)\n  - \\f: Form feed (0x0c)\n  - \\b: Backspace (0x08)\n  - \\s: Space (0x20)\n  - \\t: Tab\n  - \\\": Trích dẫn kép\n  - \\': Trích dẫn đơn\n  - \\\\: Backslash\n  - \\ddd: Ký tụ thập phân (ddd)\n  - \\uxxxx: Ký tụ Unicode thập lục phân (x4)byte a = 12; char a = 'CAT'\n\n, int decimal = 100; int octal = 0144; int hexa = 0x64;\n\n, \"Hello World\" \"Hai\\ndong\" \"\\\"Day la trong trich dan\\\"\"\n\n, char x = '\\u0001'; String y = \"\\u0001\";\n\n"
    }
  },
  {
    "id": "132",
    "name": "Toán tử",
    "href": "https://www.vietjack.com/java/toan_tu_trong_java.jsp",
    "lesson": {
      "title": "Toán tử trong Java",
      "content": "| Thứ tự ưu tiên | Toán tử | Ví dụ | Kết quả |\n|---|---|---|---|\n| 1 | Dấu ngoặc đơn | `(x + y)` | `10` |\n| 2 | Lũy thừa | `x ** y` | `9` |\n| 3 | Nhân và chia | `x * y` | `20` |\n| 4 | Cộng và trừ | `x + y` | `10` |\n| 5 | Gán | `x = y` | `x = 10` |\n| 6 | Toán tử điều kiện | `x ? y : z` | `10` |\n| 7 | Toán tử logic | `x && y` | `true` |\n| 8 | Toán tử thao tác bit | `x & y` | `8` |\n| 9 | Toán tử quan hệ | `x < y` | `true` |\n| 10 | Toán tử số học | `x + y` | `10` |Toán tử\nMô tả\nVí dụ\n\n+\nPhép cộng\nA + B sẽ cho kết quả 30\n\n-\nPhép trừ: Trừ toán hạng trái cho toán hạng phải\nA - B sẽ cho kết quả -10\n\n*\nPhép nhân\nA * B sẽ cho kết quả 200\n\n/\nPhép chia: Chia toán hạng trái cho toán hạng phải\nB / A sẽ cho kết quả 2\n\n%\nPhép chia lấy phần dư: Lấy phần dư của phép chia toán hạng trái cho toán hạng phải\nB % A sẽ cho kết quả 0\n\n++\nPhép lượng gia: Lượng gia giá trị toán hạng thêm 1\nB++ sẽ cho kết quả 21\n\n--\nPhép lượng giảm: Lượng giảm giá trị toán hạng đi 1\nB-- sẽ cho kết quả 19\n\n==\nKiểm tra nếu giá trị của hai toán hạng có cân bằng hay không, nếu có thì điều kiện là true.\n(A == B) là không true.\n\n!=\nKiểm tra nếu giá trị hai toán hạng là cân bằng hay không, nếu không cân bằng, thì điều kiện là true\n(A != B) là true.\n\n>\nKiểm tra nếu toán hạng trái có lớn hơn toán hạng phải hay không, nếu có thì điều kiện là true\n(A > B) là không true.\n\n<\nKiểm tra nếu toán hạng phải có lớn hơn toán hạng trái hay không, nếu có thì điều kiện là true\n(A < B) là true.\n\n>=\nKiểm tra nếu toán hạng trái có lớn hơn hoặc bằng toán hạng phải hay không, nếu có thì điều kiện là true\n(A >= B) là không true.\n\n<=\nKiểm tra nếu toán hạng phải có lớn hơn hoặc bằng toán hạng trái hay không, nếu có thì điều kiện là true\n(A <= B) là true.\n\n&\nToán tử Và nhị phân sao chép một bit tới kết quả nếu nó tồn tại trong cả hai toán hạng\n(A & B) sẽ cho kết quả 12, hay là 0000 1100\n\n|\nToán tử Hoặc nhị phân sao chép một bit tới kết quả nếu nó tồn tại trong một hoặc hai toán hạng\n(A | B) sẽ cho kết quả 61, hay là 0011 1101\n\n^\nToán tử Hoặc loại trừ nhị phân sao chép bit nếu nó được thiết lập trong một toán hạng nhưng không phải trong cả hai\n(A ^ B) sẽ cho kết quả 49, hay là 0011 0001\n\n~\nToán tử đảo bit là toán tử một ngôi. Đảo bít 1 thành 0 và ngược lại\n(~A ) sẽ cho kết quả -61, hay là 1100 0011\n\n<<\nToán tử dịch trái. Giá trị toán hạng trái được dịch chuyển sang trái bởi số các bit được xác định bởi toán hạng bên phải.\nA << 2 sẽ cho kết quả 240, hay là 1111 0000\n\n>>\nToán tử dịch phải. Giá trị toán hạng trái được dịch chuyển sang phải bởi số các bit được xác định bởi toán hạng bên phải\nA >> 2 sẽ cho kết quả 15, hay là 1111\n\n>>>\nToán tử dịch phải và điền 0 vào chỗ trống\nA >>>2 sẽ cho kết quả 15, hay là 0000 1111\n\n&&\nToán tử Và logic. Nếu cả hai toán hạng là khác không, thì khi đó điều kiện là true\n(A && B) là false.\n\n||\nToán tử Hoặc logic. Nếu một trong hai toán tử khác 0, thì điều kiện là true\n(A || B) là true.\n\n!\nToán tử Phủ định logic. Sử dụng để đảo ngược lại trạng thái logic của toán hạng đó. Nếu điều kiện toán hạng là true thì phủ định nó sẽ là false\n!(A && B) là true.\n\n=\nToán tử gán đơn giản. Gán giá trị toán hạng bên phải cho toán hạng trái.\nC = A + B sẽ gán giá trị của A + B vào cho C\n\n+=\nThêm giá trị toán hạng phải tới toán hạng trái và gán giá trị đó cho toán hạng trái.\nC += A là tương đương với C = C + A\n\n-=\nTrừ đi giá trị toán hạng phải từ toán hạng trái và gán giá trị này cho toán hạng trái.\nC -= A là tương đương với C = C - A\n\n*=\nNhân giá trị toán hạng phải với toán hạng trái và gán giá trị này cho toán hạng trái.\nC *= A là tương đương với C = C * A\n\n/=\nChia toán hạng trái cho toán hạng phải và gán giá trị này cho toán hạng trái.\nC /= A là tương đương với C = C / A\n\n%=\nLấy phần dư của phép chia toán hạng trái cho toán hạng phải và gán cho toán hạng trái.\nC %= A là tương đương với C = C % A\n\n<<=\nDịch trái toán hạng trái sang số vị trí là giá trị toán hạng phải.\nC <<= 2 là giống như C = C << 2\n\n>>=\nDịch phải toán hạng trái sang số vị trí là giá trị toán hạng phải.\nC >>= 2 là giống như C = C >> 2\n\n&=\nPhép AND bit\nC &= 2 là giống như C = C & 2\n\n^=\nPhép OR loại trừ bit\nC ^= 2 là giống như C = C ^ 2\n\n|=\nPhép OR bit.\nC |= 2 là giống như C = C | 2\n\nLoại\nToán tử\nThứ tự ưu tiên\n\nPostfix\n() [] . (toán tử dot)\nTrái sang phải\n\nUnary\n++ - - ! ~\nPhải sang trái\n\nTính nhân\n* / %\nTrái sang phải\n\nTính cộng\n+ -\nTrái sang phải\n\nDịch chuyển\n>> >>> <<\nTrái sang phải\n\nQuan hệ\n> >= < <=\nTrái sang phải\n\nCân bằng\n== !=\nTrái sang phải\n\nPhép AND bit\n&\nTrái sang phải\n\nPhép XOR bit\n^\nTrái sang phải\n\nPhép OR bit\n|\nTrái sang phải\n\nPhép AND logic\n&&\nTrái sang phải\n\nPhép OR logic\n||\nTrái sang phải\n\nĐiều kiện\n?:\nPhải sang trái\n\nGán\n= += -= *= /= %= >>= <<= &= ^= |=\nPhải sang trái\n\nDấu phảy\n,\nTrái sang phảibien x = (bieu_thuc) ? (giatri1 neu true) : (giatri1 neu true); //hoac ban\ncung co the su dung trong cac lenh RETURN return (bieu_thuc) ? (giatri1 neu\ntrue) : (giatri2 neu false);\n\n, public class Test { public static void main(String args[]){ int a , b; a = 10;\nb = (a == 1) ? 20: 30; //Day la vi du ve toan tu dieu kien.\nSystem.out.println( \"Gia tri cua b la : \" + b ); b = (a == 10) ? 20: 30; //Day\nla vi du ve toan tu dieu kien. System.out.println( \"Gia tri cua b la : \" + b\n); } }\n\n, Gia tri cua b la : 30 Gia tri cua b la : 20\n\n, ( Object reference variable ) instanceof (class/interface type)\n\n, public class Test { public static void main(String args[]){ String name =\n\"Doan\"; // Duoi day se tra ve true neu name la mot kieu String boolean result\n= name instanceof String; System.out.println( result ); } }\n\n, true\n\n, class Animal {} public class Dog extends Animal { public static void\nmain(String args[]){ Animal a = new Dog(); boolean result = a instanceof Dog;\nSystem.out.println( result ); } }\n\n, true\n\n"
    }
  },
  {
    "id": "142",
    "name": "Các kiểu vòng lặp",
    "href": "https://www.vietjack.com/java/vong_lap_trong_java.jsp",
    "lesson": {
      "title": "Vòng lặp trong Java",
      "content": "Trong chương tiếp theo, chúng ta sẽ tìm hiểu về các lệnh điều khiển luồng trong Java, cụ thể là lệnh continue và lệnh break. Bảng dưới đây liệt kê các lệnh được sử dụng để điều khiển vòng lặp trong Java. Nếu bạn muốn dừng thực thi hoặc tiếp tục thực thi một vòng lặp tại một điều kiện cụ thể, bạn có thể sử dụng các lệnh này. Java hỗ trợ nhiều loại vòng lặp khác nhau, bao gồm vòng lặp for, vòng lặp while, vòng lặp do-while và vòng lặp foreach. Vòng lặp foreach, còn được gọi là vòng lặp enhanced, được giới thiệu trong Java 5 và được sử dụng chủ yếu cho các mảng. Java có ba kỹ thuật lặp linh hoạt cho phép bạn sử dụng một trong ba vòng lặp sau: vòng lặp for, vòng lặp while và vòng lặp do-while. Trong một số tình huống, bạn có thể cần thực hiện một khối mã nhiều lần, điều này được gọi là vòng lặp.Các loại vòng lặp trong lập trình bao gồm:\n\n- Vòng lặp while: Kiểm tra điều kiện trước khi thực thi phần thân vòng lặp.\n\n- Vòng lặp for: Cho phép lặp lại một tác vụ một số lần cụ thể.\n\n- Vòng lặp do...while: Thực hiện phần thân vòng lặp trước khi kiểm tra điều kiện.\n\n- Vòng lặp foreach: Được sử dụng chủ yếu với các mảng và các ArrayList.\n\nCác lệnh điều khiển vòng lặp:\n\n- Lệnh break: Dừng toàn bộ vòng lặp.\n\n- Lệnh continue: Làm cho vòng lặp ngay lập tức tiếp tục tiến trình lặp tiếp theo của vòng lặp."
    }
  },
  {
    "id": "152",
    "name": "Lệnh if, switch",
    "href": "https://www.vietjack.com/java/dieu_khien_luong_trong_java.jsp",
    "lesson": {
      "title": "Lệnh IF/ELSE, Lệnh SWITCH/CASE trong Java",
      "content": "Trong Java, chúng ta có thể sử dụng các lớp để tạo các đối tượng với các thuộc tính và phương thức cụ thể. Các lớp này có thể được sử dụng để lưu trữ và thao tác dữ liệu theo nhiều cách khác nhau. Ngoài ra, Java cũng cung cấp một số hàm toán học cơ bản để thực hiện các phép tính số học như cộng, trừ, nhân, chia, v.v.\n\nĐể kiểm soát luồng thực thi chương trình, Java cung cấp các lệnh điều khiển luồng như lệnh if-else, lệnh switch, lệnh for, lệnh while, v.v. Những lệnh này cho phép chúng ta kiểm tra các điều kiện và thực hiện các hành động khác nhau tùy thuộc vào kết quả của các điều kiện đó.\n\nBảng dưới đây liệt kê các lệnh điều khiển luồng trong Java:\n\n| Lệnh | Mô tả |\n|---|---|\n| if-else | Kiểm tra một điều kiện và thực hiện các hành động khác nhau tùy thuộc vào kết quả của điều kiện đó. |\n| switch | Kiểm tra giá trị của một biến và thực hiện các hành động khác nhau tùy thuộc vào giá trị đó. |\n| for | Lặp lại một khối lệnh một số lần nhất định hoặc cho đến khi một điều kiện nào đó được đáp ứng. |\n| while | Lặp lại một khối lệnh trong khi một điều kiện nào đó được đáp ứng. |\n| do-while | Lặp lại một khối lệnh ít nhất một lần, sau đó lặp lại cho đến khi một điều kiện nào đó được đáp ứng. |\n| break | Thoát khỏi một vòng lặp hoặc một câu lệnh switch. |\n| continue | Bỏ qua phần còn lại của vòng lặp hiện tại và chuyển sang lần lặp tiếp theo. |\n\nCác lệnh điều khiển luồng là một phần quan trọng của bất kỳ ngôn ngữ lập trình nào, bao gồm cả Java. Chúng cho phép chúng ta kiểm soát cách thức chương trình thực thi và thực hiện các hành động khác nhau tùy thuộc vào các điều kiện khác nhau.**Lệnh if:**\n\n- Lệnh if là một lệnh rẽ nhánh trong Java dùng để kiểm tra một điều kiện và thực hiện các câu lệnh tương ứng nếu điều kiện đó đúng.\n\n**Lệnh if...else:**\n\n- Lệnh if...else là một lệnh rẽ nhánh trong Java dùng để kiểm tra một điều kiện và thực hiện các câu lệnh tương ứng nếu điều kiện đó đúng hoặc sai.\n\n**Lồng lệnh if:**\n\n- Có thể lồng các lệnh if-else, nghĩa là bạn có thể sử dụng một lệnh if hoặc else if bên trong lệnh if hoặc else if khác.\n\n**Lệnh switch:**\n\n- Lệnh switch là một lệnh rẽ nhánh trong Java dùng để kiểm tra một biến có giá trị bằng với một danh sách các giá trị đã cho hay không. Nếu giá trị của biến bằng với một trong các giá trị đã cho thì các câu lệnh tương ứng với giá trị đó sẽ được thực hiện.bien x = (bieu_thuc) ? (giatri1 neu true) : (giatri2 neu true); //hoac ban\ncung co the su dung trong cac lenh RETURN return (bieu_thuc) ? (giatri1 neu\ntrue) : (giatri2 neu false);\n\n, public class Test { public static void main(String args[]){ int a , b; a = 10;\nb = (a == 1) ? 20: 30; //Day la vi du ve toan tu dieu kien.\nSystem.out.println( \"Gia tri cua b la : \" + b ); b = (a == 10) ? 20: 30; //Day\nla vi du ve toan tu dieu kien. System.out.println( \"Gia tri cua b la : \" + b\n); } }\n\n, Gia tri cua b la : 30 Gia tri cua b la : 20\n\n"
    }
  },
  {
    "id": "162",
    "name": "Đối tượng Number",
    "href": "https://www.vietjack.com/java/number_trong_java.jsp",
    "lesson": {
      "title": "Number trong Java",
      "content": "- Phương thức `Math.random()` trả về một số ngẫu nhiên.\n- Phương thức `Math.toRadians(angle)` chuyển đổi một góc từ độ sang radian.\n- Phương thức `Math.toDegrees(angle)` chuyển đổi một góc từ radian sang độ.\n- Phương thức `Math.atan2(y, x)` trả về góc giữa trục x dương và điểm (x, y) trong radian.\n- Phương thức `Math.atan(x)` trả về góc arctan của x trong radian.\n- Phương thức `Math.acos(x)` trả về góc arccos của x trong radian.\n- Phương thức `Math.asin(x)` trả về góc arcsin của x trong radian.\n- Phương thức `Math.tan(x)` trả về giá trị tan của x trong radian.\n- Phương thức `Math.cos(x)` trả về giá trị cos của x trong radian.\n- Phương thức `Math.sin(x)` trả về giá trị sin của x trong radian.\n- Phương thức `Math.sqrt(x)` trả về căn bậc hai của x.\n- Phương thức `Math.pow(x, y)` trả về giá trị x mũ y.\n- Phương thức `Math.log(x)` trả về logarit cơ số e của x.\n- Phương thức `Math.exp(x)` trả về giá trị e mũ x.\n- Phương thức `Math.max(x, y)` trả về số lớn nhất trong hai số x và y.\n- Phương thức `Math.min(x, y)` trả về số nhỏ nhất trong hai số x và y.\n- Phương thức `Math.round(x)` trả về số gần nhất với x.\n- Phương thức `Math.rint(x)` trả về số integer gần nhất với x.\n- Phương thức `Math.floor(x)` trả về số integer lớn nhất mà nhỏ hơn hoặc bằng x.\n- Phương thức `Math.ceil(x)` trả về số integer nhỏ nhất mà lớn hơn hoặc bằng x.\n- Phương thức `Math.abs(x)` trả về giá trị tuyệt đối của x.\n- Phương thức `Integer.parseInt(string)` chuyển đổi một chuỗi thành số nguyên.\n- Phương thức `Integer.toString(number)` trả về một chuỗi biểu diễn số nguyên đã xác định.\n- Phương thức `Integer.valueOf(string)` trả về một đối tượng integer giữ giá trị gốc đã xác định.\n- Phương thức `Number.equals(object)` kiểm tra có hay không đối tượng number này là bằng với tham số.\n- Phương thức `Number.compareTo(number)` sánh đối tượng number này với tham số.\n- Phương thức `Number.xxxValue()` biến đổi giá trị của đối tượng number này thành kiểu dữ liệu xxx mà được trả về từ phương thức.1. Phương thức xxxValue() trong Java chuyển đổi giá trị của đối tượng Number thành kiểu dữ liệu xxx.\n2. Phương thức compareTo() trong Java so sánh đối tượng Number với một tham số.\n3. Phương thức equals() trong Java kiểm tra xem đối tượng Number có bằng với tham số không.\n4. Phương thức valueOf() trong Java trả về một đối tượng Integer giữ giá trị gốc đã xác định.\n5. Phương thức toString() trong Java trả về một đối tượng String biểu diễn giá trị Integer đã xác định.\n6. Phương thức parseInt() trong Java được sử dụng để nhận kiểu dữ liệu gốc của một String cụ thể.\n7. Phương thức abs() trong Java trả về giá trị tuyệt đối của tham số.\n8. Phương thức ceil() trong Java trả về số integer nhỏ nhất mà lớn hơn hoặc bằng tham số.\n9. Phương thức floor() trong Java trả về số integer lớn nhất mà nhỏ hơn hoặc bằng tham số.\n10. Phương thức rint() trong Java làm tròn số, trả về giá trị integer gần nhất với giá trị tham số.\n11. Phương thức round() trong Java trả về long hoặc int gần nhất, như kiểu dữ liệu được chỉ dẫn bởi phương thức, với tham số.\n12. Phương thức min() trong Java trả về số nhỏ nhất trong hai tham số.\n13. Phương thức max() trong Java trả về số lớn nhất trong hai tham số.\n14. Phương thức exp() trong Java tính hàm mũ cơ số e.\n15. Phương thức log() trong Java tính hàm logarit cơ số e.\n16. Phương thức pow() trong Java trả về giá trị hàm mũ với cơ số là tham số đầu tiên và mũ là tham số thứ hai.\n17. Phương thức sqrt() trong Java trả về căn bậc hai của tham số.\n18. Phương thức sin() trong Java trả về sin của giá trị double đã cho.\n19. Phương thức cos() trong Java trả về cos của giá trị double đã cho.\n20. Phương thức tan() trong Java trả về tan của giá trị double đã cho.\n21. Phương thức asin() trong Java trả về arcsin của giá trị double đã cho.\n22. Phương thức acos() trong Java trả về arccos của giá trị double đã cho.\n23. Phương thức atan() trong Java trả về arctan của giá trị double đã cho.\n24. Phương thức atan2() trong Java biến đổi tọa độ (x, y) thành tọa độ cực (r, theta) và trả về theta.\n25. Phương thức toDegrees() trong Java biến đổi tham số thành giá trị độ đo góc.\n26. Phương thức toRadians() trong Java biến đổi tham số thành radian.\n27. Phương thức random() trong Java trả về một số ngẫu nhiên.int i = 5000; float gpa = 13.65; byte mask = 0xaf;\n\n, public class Test{ public static void main(String args[]){ Integer x = 5; //\ndong hop int thanh doi tuong Integer x = x + 10; // mo hop Integer thanh int\nSystem.out.println(x); } }\n\n, 15\n\n"
    }
  },
  {
    "id": "172",
    "name": "Đối tượng Character",
    "href": "https://www.vietjack.com/java/character_trong_java.jsp",
    "lesson": {
      "title": "Character trong Java",
      "content": "- `Character.toString(char ch)`: trả về một đối tượng `String` biểu diễn giá trị ký tự đã cho.\n- `Character.toLowerCase(char ch)`: trả về form dạng chữ thường của giá trị `char` đã cho.\n- `Character.toUpperCase(char ch)`: trả về form dạng chữ hoa của giá trị `char` đã cho.\n- `Character.isLowerCase(char ch)`: xác định có hay không giá trị `char` đã cho là chữ thường.\n- `Character.isUpperCase(char ch)`: xác định có hay không giá trị `char` đã cho là chữ hoa.\n- `Character.isWhitespace(char ch)`: xác định có hay không giá trị `char` đã cho là một khoảng trắng.\n- `Character.isDigit(char ch)`: xác định có hay không giá trị `char` đã cho là một chữ số.\n- `Character.isLetter(char ch)`: kiểm tra có hay không giá trị `char` đã cho là một chữ cái.* Các ký tự thoát:\n\n - \\t: Chèn một tab vào văn bản tại điểm này\n - \\b: Chèn một backspace vào văn bản tại điểm này\n - \\n: Chèn một dòng mới vào văn bản tại điểm này\n - \\r: Chèn một carriage return vào văn bản tại điểm này\n - \\f: Chèn một form feed vào văn bản tại điểm này\n - \\' Chèn một dấu trích dẫn đơn vào văn bản tại điểm này\n - \\\" Chèn một dấu trích dẫn kép vào văn bản tại điểm này\n - \\\\ Chèn một ký tự dấu chéo ngược vào văn bản tại điểm này\n\n* Các phương thức của lớp Character:\n\n - isLetter(): Kiểm tra có hay không giá trị char đã cho là một chữ cái\n - isDigit(): Xác định có hay không giá trị char đã cho là một digit\n - isWhitespace(): Xác định có hay không giá trị char đã cho là một khoảng trắng\n - isUpperCase(): Xác định có hay không giá trị char đã cho là chữ hoa\n - isLowerCase(): Xác định có hay không giá trị char đã cho là chữ thường\n - toUpperCase(): Trả về form dạng chữ hoa của giá trị char đã cho\n - toLowerCase(): Trả về form dạng chữ thường của giá trị char đã cho\n - toString(): Trả về một đối tượng String biểu diễn giá trị ký tự đã cho, mà là, một chuỗi gồm một ký tựchar ch = 'a'; // Ma Unicode cho ky tu Greek omega dang chu hoa char uniChar =\n'\\u039A'; // Mot mang ky tu char[] charArray ={ 'a', 'b', 'c', 'd', 'e' };\n\n, Character ch = new Character('a');\n\n, // O day la kieu char goc 'a' // duoc dong hop thanh doi tuong Character la ch\nCharacter ch = 'a'; // Tai day kieu goc 'x' duoc dong hop cho phuong thuc\ntest, // gia tri tra ve duoc mo hop cho ky tu 'c' char c = test('x');\n\n, public class Test { public static void main(String args[]) {\nSystem.out.println(\"Co ta noi \\\"Hello!\\\" voi toi.\"); } }\n\n, Co ta noi \"Hello!\" voi toi.\n\n"
    }
  },
  {
    "id": "13",
    "name": "Khái niệm OOP",
    "href": "https://www.vietjack.com/java/khai_niem_huong_doi_tuong_trong_java.jsp",
    "lesson": {
      "title": "Khái niệm hướng đối tượng (OOP) trong Java",
      "content": "Lập trình hướng đối tượng (OOP) là một phương pháp thiết kế phần mềm bằng cách sử dụng các lớp và đối tượng. OOP giúp đơn giản hóa việc duy trì và phát triển phần mềm bằng cách cung cấp một số khái niệm, bao gồm:\n\n* Tính bao đóng (encapsulation): Tính bao đóng là gắn kết code và dữ liệu cùng với nhau vào trong một đơn vị duy nhất. Điều này giúp bảo vệ dữ liệu khỏi bị truy cập trái phép và giúp cho việc quản lý code dễ dàng hơn.\n* Tính trừu tượng (abstraction): Tính trừu tượng là ẩn các chi tiết nội tại và hiển thị tính năng. Điều này giúp cho người dùng chỉ cần quan tâm đến những gì mà đối tượng có thể làm, chứ không cần biết đối tượng đó hoạt động như thế nào.\n* Tính đa hình (polymorphism): Tính đa hình là khi một tác vụ được thực hiện theo nhiều cách khác nhau. Điều này giúp cho code trở nên linh hoạt hơn và dễ dàng mở rộng hơn.\n* Tính kế thừa (inheritance): Tính kế thừa là khi một đối tượng đạt được các thuộc tính và các hành vi của đối tượng cha. Điều này giúp tăng tính tái sử dụng cho code và giúp cho việc quản lý code dễ dàng hơn.\n\nOOP là một phương pháp lập trình mạnh mẽ và linh hoạt, được sử dụng rộng rãi trong phát triển phần mềm. OOP được hỗ trợ bởi nhiều ngôn ngữ lập trình, bao gồm Java, C++, Python và JavaScript."
    }
  },
  {
    "id": "23",
    "name": "Lớp và Đối tượng",
    "href": "https://www.vietjack.com/java/lop_va_doi_tuong_trong_java.jsp",
    "lesson": {
      "title": "Đối tượng và lớp (class) trong Java",
      "content": "1. Một lớp cung cấp bản thiết kế cho các đối tượng, giống như khuôn mẫu để tạo đối tượng.\n\n2. Từ khóa `new` được sử dụng để tạo một đối tượng mới từ một lớp.\n\n3. Đối tượng có ba đặc điểm: nhận dạng duy nhất, trạng thái và hành vi.\n\n4. Có nhiều cách để tạo đối tượng trong Java, bao gồm sử dụng từ khóa `new`, phương thức `clone()`, phương thức `newInstance()` và phương thức `factory`.\n\n5. Biến instance là biến được khai báo trong một lớp bên ngoài bất kỳ phương thức nào.\n\n6. Biến class là biến được khai báo với một lớp bên ngoài bất kỳ phương thức nào với từ khóa `static`.\n\n7. Biến local là biến được định nghĩa bên trong các phương thức, constructor hoặc block code.\n\n8. Lớp có thể chứa các loại biến sau: biến instance, biến class và biến local.\n\n9. Constructor là phương thức đặc biệt được gọi khi tạo một đối tượng mới.\n\n10. Mỗi lớp có ít nhất một constructor. Nếu không có constructor được khai báo rõ ràng, trình biên dịch Java sẽ tạo một constructor mặc định.\n\n11. Phương thức là hành vi của một đối tượng, được sử dụng để thực hiện một nhiệm vụ cụ thể.\n\n12. Phương thức có thể truy cập vào các biến instance và các phương thức khác của lớp.\n\n13. Đối tượng là instance của một lớp, được tạo ra từ bản thiết kế của lớp đó.\n\n14. Đối tượng có thể truy cập vào các biến instance và các phương thức của lớp.\n\n15. Đối tượng có thể được tạo, sửa đổi và hủy trong quá trình thực thi chương trình.class ten_lop{ thanh_vien_du_lieu; phuong_thuc; }\n\n, class Student1{ int id; //thanh vien du lieu (cung la bien instance) String\nname; //thanh vien du lieu (cung la bien instance) public static void\nmain(String args[]){ Student1 s1=new Student1(); //tao mot doi tuong Student\nSystem.out.println(s1.id); System.out.println(s1.name); } }\n\n, public class Xecon{ public Xecon(){ } public Xecon(String ten){ // Contructor\nnay co mot tham so la ten. } }\n\n, public class Xecon{ public Xecon(String ten){ // Contructor nay co mot tham so\nla ten. System.out.println(\"Ten xe la :\" + ten ); } public static void\nmain(String []args){ // Lenh sau se tao mot doi tuong la Xecuatoi Xecon\nXecuatoi = new Xecon( \"Toyota\" ); } }\n\n, Ten xe la :Toyota\n\n, /* Dau tien, ban tao mot doi tuong */ Doituongthamchieu = new Constructor();\n/* Sau do ban goi mot bien nhu sau */ Doituongthamchieu.TenBien; /* Bay gio\nban co the goi mot phuong thuc lop nhu sau */\nDoituongthamchieu.TenPhuongThuc();\n\n, public class Xecon{ int Giaxe; public Xecon(String ten){ // Contructor nay co\nmot tham so la ten. System.out.println(\"Ten xe la :\" + ten ); } public void\nsetGia( int gia ){ Giaxe = gia; } public int getGia( ){\nSystem.out.println(\"Gia mua xe la :\" + Giaxe ); return Giaxe; } public static\nvoid main(String []args){ /* Tao doi tuong */ Xecon Xecuatoi = new Xecon(\n\"Toyota\" ); /* Goi mot phuong thuc lop de thiet lap gia xe */ Xecuatoi.setGia(\n1000000000 ); /* Goi mot phuong thuc lop khac de lay gia xe */\nXecuatoi.getGia( ); /* Ban cung co the truy cap bien instance nhu sau */\nSystem.out.println(\"Gia tri bien :\" + Xecuatoi.Giaxe ); } }\n\n, Ten xe la :Toyota Gia mua xe la :1000000000 Gia tri bien :1000000000\n\n, class Student2{ int rollno; String name; void insertRecord(int r, String n){\n//phuong thuc rollno=r; name=n; } void\ndisplayInformation(){System.out.println(rollno+\" \"+name);} //phuong thuc\npublic static void main(String args[]){ Student2 s1=new Student2(); Student2\ns2=new Student2(); s1.insertRecord(111,\"HoangThanh\");\ns2.insertRecord(222,\"ThanhHuong\"); s1.displayInformation();\ns2.displayInformation(); } }\n\n, class Rectangle{ int length; int width; void insert(int l,int w){ length=l;\nwidth=w; } void calculateArea(){System.out.println(length*width);} public\nstatic void main(String args[]){ Rectangle r1=new Rectangle(); Rectangle\nr2=new Rectangle(); r1.insert(11,5); r2.insert(3,15); r1.calculateArea();\nr2.calculateArea(); } }\n\n, class Calculation{ void fact(int n){ int fact=1; for(int i=1;i<=n;i++){\nfact=fact*i; } System.out.println(\"factorial is \"+fact); } public static void\nmain(String args[]){ new Calculation().fact(5); //Goi phuong thuc voi doi\ntuong vo danh (annonymous) } }\n\n, Rectangle r1=new Rectangle(),r2=new Rectangle(); //Tao hai doi tuong\n\n, class Rectangle{ int length; int width; void insert(int l,int w){ length=l;\nwidth=w; } void calculateArea(){System.out.println(length*width);} public\nstatic void main(String args[]){ Rectangle r1=new Rectangle(),r2=new\nRectangle(); //Tao hai doi tuong r1.insert(11,5); r2.insert(3,15);\nr1.calculateArea(); r2.calculateArea(); } }\n\n, Output:55 45\n\n"
    }
  },
  {
    "id": "33",
    "name": "Phương thức",
    "href": "https://www.vietjack.com/java/phuong_thuc_trong_java.jsp",
    "lesson": {
      "title": "Phương thức trong Java",
      "content": "1. **Phương thức:**\n   - Là một tập hợp các lệnh được nhóm lại để thực hiện một hành động.\n   - Có thể trả về giá trị hoặc không.\n   - Có thể có hoặc không có tham số.\n   - Được gọi bằng cách sử dụng tên phương thức theo sau là danh sách các tham số được truyền vào trong dấu ngoặc đơn.\n\n2. **Ví dụ về phương thức:**\n   - `System.out.print()` là một phương thức được sử dụng để hiển thị thông báo trên màn hình console.\n   - `Math.max()` là một phương thức được sử dụng để tìm giá trị lớn nhất giữa hai số.\n   - `String.length()` là một phương thức được sử dụng để lấy độ dài của một chuỗi.\n\n3. **Phương thức nạp chồng:**\n   - Xảy ra khi một lớp có hai hoặc nhiều phương thức cùng tên nhưng khác nhau về tham số.\n   - Khi một phương thức nạp chồng được gọi, trình biên dịch sẽ xác định phương thức nào sẽ được thực thi dựa trên các tham số được truyền vào.\n\n4. **Phương thức trừu tượng:**\n   - Là một phương thức không có thân phương thức (không có nội dung).\n   - Được sử dụng để khai báo một phương thức mà các lớp con phải định nghĩa lại.\n\n5. **Truyền tham số:**\n   - Có hai cách để truyền tham số vào một phương thức:\n     - Truyền tham số theo giá trị: Khi truyền tham số theo giá trị, một bản sao của giá trị tham số được truyền vào phương thức.\n     - Truyền tham số theo tham chiếu: Khi truyền tham số theo tham chiếu, địa chỉ của biến tham số được truyền vào phương thức.\n\n6. **Gọi phương thức:**\n   - Có hai cách để gọi một phương thức:\n     - Gọi phương thức trả về giá trị: Khi gọi phương thức trả về giá trị, giá trị trả về của phương thức sẽ được gán cho một biến.\n     - Gọi phương thức không trả về giá trị: Khi gọi phương thức không trả về giá trị, phương thức sẽ được thực thi nhưng không có giá trị trả về.public static int tenPhuongThuc(int a, int b) { // phan than phuong thuc }\n\n, modifier kieuTraVe tenPhuongThuc (Danh sach tham so) { // Than phuong thuc }\n\n, /** Vi du code tra ve so nho nhat cua hai so */ public static int\nminFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else min = n1;\nreturn min; }\n\n, System.out.println(\"Day la Vietjack.com!\");\n\n, int result = sum(6, 9);\n\n, public class ExampleMinNumber{ public static void main(String[] args) { int a\n= 11; int b = 6; int c = minFunction(a, b); System.out.println(\"Gia tri nho\nnhat = \" + c); } /** Tra ve gia tri nho nhat cua hai so */ public static int\nminFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else min = n1;\nreturn min; } }\n\n, Gia tri nho nhat = 6\n\n, public class ExampleVoid { public static void main(String[] args) {\nmethodRankPoints(255.7); } public static void methodRankPoints(double points)\n{ if (points >= 202.5) { System.out.println(\"Rank:A1\"); } else if (points >=\n122.4) { System.out.println(\"Rank:A2\"); } else {\nSystem.out.println(\"Rank:A3\"); } } }\n\n, Rank:A1\n\n, package edu.doannhg.basic; // vi du de trao doi gia tri cua hai so public\nclass Test { public static void main(String[] args) { int a = 30; int b = 45;\nSystem.out.println(\"Truoc khi trao doi, gia tri cua a = \" + a + \" va b = \" +\nb); // Trieu hoi phuong thuc hamTraoDoi hamTraoDoi(a, b);\nSystem.out.println(\"\\n**Bay gio, Truoc va Sau khi trao doi, cac gia tri se\ngiong nhu nhau o day**:\"); System.out.println(\"Sau khi trao doi, a = \" + a + \"\nva b = \" + b); } public static void hamTraoDoi(int a, int b) {\nSystem.out.println(\"Truoc khi trao doi (ben trong phuong thuc) , a = \" + a \\+\n\" va b = \" + b); // trao doi gia tri cua hai so int c = a; a = b; b = c;\nSystem.out.println(\"Sau khi trao doi (ben trong phuong thuc), a = \" + a \\+ \"\nva b = \" + b); } }\n\n, Truoc khi trao doi, gia tri cua a = 30 va b = 45 Truoc khi trao doi (ben trong\nphuong thuc) , a = 30 va b = 45 Sau khi trao doi (ben trong phuong thuc), a =\n45 va b = 30 **Bay gio, Truoc va Sau khi trao doi, cac gia tri se giong nhu\nnhau o day**: Sau khi trao doi, a = 30 va b = 45\n\n, public class ExampleOverloading{ public static void main(String[] args) { int\na = 11; int b = 6; double c = 7.3; double d = 9.4; int result1 =\nminFunction(a, b); // cung ten ham voi tham so khac nhau double result2 =\nminFunction(c, d); System.out.println(\"Gia tri nho nhat = \" + result1);\nSystem.out.println(\"Gia tri nho nhat = \" + result2); } // cho integer public\nstatic int minFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else\nmin = n1; return min; } // cho double public static double minFunction(double\nn1, double n2) { double min; if (n1 > n2) min = n2; else min = n1; return min;\n} }\n\n, Gia tri nho nhat = 6 Gia tri nho nhat = 7.3\n\n, public class CommandLine { public static void main(String args[]){ for(int\ni=0; i<args.length; i++){ System.out.println(\"args[\" + i + \"]: \" + args[i]); }\n} }\n\n, java CommandLine this is a command line 200 -100\n\n, args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]:\n200 args[6]: -100\n\n, // Mot constructor. class MyClass { int x; // Sau day la constructor MyClass()\n{ x = 10; } }\n\n, public class ConsDemo { public static void main(String args[]) { MyClass t1 =\nnew MyClass(); MyClass t2 = new MyClass(); System.out.println(t1.x + \" \" +\nt2.x); } }\n\n, // Mot constructor. class MyClass { int x; // Sau day la constructor\nMyClass(int i ) { x = i; } }\n\n, public class ConsDemo { public static void main(String args[]) { MyClass t1 =\nnew MyClass( 10 ); MyClass t2 = new MyClass( 20 ); System.out.println(t1.x + \"\n\" + t2.x); } }\n\n, 10 20\n\n, tenKieu... tenThamSo\n\n, public class VarargsDemo { public static void main(String args[]) { // Goi\nphuong thuc voi bien args printMax(34, 3, 3, 2, 56.5); printMax(new\ndouble[]{1, 2, 3}); } public static void printMax( double... numbers) { if\n(numbers.length == 0) { System.out.println(\"Khong co tham so nao duoc\ntruyen\"); return; } double result = numbers[0]; for (int i = 1; i <\nnumbers.length; i++) if (numbers[i] > result) result = numbers[i];\nSystem.out.println(\"Gia tri max la \" + result); } }\n\n, Gia tri max la 56.5 Gia tri max la 3.0\n\n, protected void finalize( ) { // tai day la phan code ket thuc }\n\n"
    }
  },
  {
    "id": "43",
    "name": "Nạp chồng phương thức (Overloading)",
    "href": "https://www.vietjack.com/java/overloading_trong_java.jsp",
    "lesson": {
      "title": "Nạp chồng phương thức trong Java",
      "content": "Nạp chồng phương thức cho phép bạn có nhiều phương thức cùng tên trong một lớp, nhưng các phương thức này phải có số lượng tham số khác nhau hoặc kiểu tham số khác nhau. Khi bạn gọi một phương thức được nạp chồng, trình biên dịch sẽ quyết định phương thức nào sẽ được gọi dựa trên các kiểu tham số của đối số bạn truyền vào.\n\nNếu các phương thức được nạp chồng có cùng số lượng tham số và cùng kiểu tham số, thì trình biên dịch sẽ báo lỗi. Đây được gọi là tình trạng mơ hồ (ambiguity).\n\nĐể tránh tình trạng mơ hồ, bạn có thể sử dụng các kiểu tham số khác nhau cho các phương thức được nạp chồng. Ví dụ, bạn có thể có một phương thức `sum()` nhận hai số nguyên và một phương thức `sum()` khác nhận hai số thực.\n\nBạn cũng có thể sử dụng số lượng tham số khác nhau cho các phương thức được nạp chồng. Ví dụ, bạn có thể có một phương thức `sum()` nhận hai số và một phương thức `sum()` khác nhận ba số.\n\nTrong Java, bạn không thể nạp chồng phương thức bằng cách thay đổi kiểu trả về của phương thức. Điều này có nghĩa là nếu bạn có hai phương thức cùng tên và cùng số lượng tham số, nhưng các phương thức này có kiểu trả về khác nhau, thì trình biên dịch sẽ báo lỗi.\n\nNạp chồng phương thức là một tính năng hữu ích của Java cho phép bạn viết mã có thể đọc và bảo trì dễ dàng hơn.class Calculation{ void sum(int a,int b){System.out.println(a+b);} void\nsum(int a,int b,int c){System.out.println(a+b+c);} public static void\nmain(String args[]){ Calculation obj=new Calculation(); obj.sum(10,10,10);\nobj.sum(20,20); } }\n\n, Output:30 40\n\n, class Calculation2{ void sum(int a,int b){System.out.println(a+b);} void\nsum(double a,double b){System.out.println(a+b);} public static void\nmain(String args[]){ Calculation2 obj=new Calculation2(); obj.sum(10.5,10.5);\nobj.sum(20,20); } }\n\n, Output:21.0 40\n\n, class Calculation3{ int sum(int a,int b){System.out.println(a+b);} double\nsum(int a,int b){System.out.println(a+b);} public static void main(String\nargs[]){ Calculation3 obj=new Calculation3(); int result=obj.sum(20,20); //Gay\nra Compile Time Error } }\n\n, class Overloading1{ public static void main(int a){ System.out.println(a); }\npublic static void main(String args[]){ System.out.println(\"Phuong thuc main()\nduoc trieu hoi\"); main(10); } }\n\n, class OverloadingCalculation1{ void sum(int a,long\nb){System.out.println(a+b);} void sum(int a,int b,int\nc){System.out.println(a+b+c);} public static void main(String args[]){\nOverloadingCalculation1 obj=new OverloadingCalculation1(); obj.sum(20,20);\n//Bay gio int literal thu hai se duoc promote thanh long obj.sum(20,20,20); }\n}\n\n, class OverloadingCalculation2{ void sum(int a,int\nb){System.out.println(\"phuong thuc int arg duoc trieu hoi\");} void sum(long\na,long b){System.out.println(\"phuong thuc long arg duoc trieu hoi\");} public\nstatic void main(String args[]){ OverloadingCalculation2 obj=new\nOverloadingCalculation2(); obj.sum(20,20); //Bay gio phuong thuc int arg sum()\nduoc trieu hoi } }\n\n, class OverloadingCalculation3{ void sum(int a,long\nb){System.out.println(\"Phuong thuc a duoc trieu hoi\");} void sum(long a,int\nb){System.out.println(\"Phuong thuc b duoc trieu hoi\");} public static void\nmain(String args[]){ OverloadingCalculation3 obj=new\nOverloadingCalculation3(); obj.sum(20,20); //Khong co tinh luong nghia o day }\n}\n\n, Output:Compile Time Error\n\n"
    }
  },
  {
    "id": "53",
    "name": "Constructor",
    "href": "https://www.vietjack.com/java/constructor_trong_java.jsp",
    "lesson": {
      "title": "Constructor trong Java",
      "content": "- Constructor là một phương thức đặc biệt trong Java được sử dụng để khởi tạo đối tượng.\n- Khi tạo đối tượng, ít nhất một constructor sẽ được gọi.\n- Constructor có cùng tên với lớp và có thể có nhiều hơn một constructor trong một lớp.\n- Có hai loại constructor: constructor mặc định và constructor được tham số hóa.\n- Constructor mặc định không có tham số và được compiler tạo ra nếu không có constructor nào được định nghĩa trong lớp.\n- Constructor được tham số hóa có tham số và được sử dụng để cung cấp các giá trị khác nhau cho các đối tượng riêng biệt.\n- Constructor được gọi tại thời điểm tạo đối tượng và xây dựng các giá trị cung cấp dữ liệu cho đối tượng đó.**Constructor và Phương thức**\n\n- Constructor:\n    - Dùng để khởi tạo trạng thái của một đối tượng.\n    - Không có kiểu trả về.\n    - Được gọi ngầm định.\n    - Nếu không có constructor nào được định nghĩa, compiler sẽ cung cấp một constructor mặc định.\n    - Tên constructor phải giống với tên lớp.\n\n\n- Phương thức:\n    - Dùng để thể hiện hành vi của một đối tượng.\n    - Có kiểu trả về.\n    - Được gọi một cách tường minh.\n    - Không được cung cấp bởi compiler trong bất kỳ trường hợp nào.\n    - Tên phương thức có thể hoặc không giống như tên lớp.public class Xecon{ public Xecon(){ } public Xecon(String ten){ // Contructor\nnay co mot tham so la ten. } }\n\n, ten_lop(){}\n\n, class Bike1{ Bike1(){System.out.println(\"Bike duoc tao\");} public static void\nmain(String args[]){ Bike1 b=new Bike1(); } }\n\n, class Student3{ int id; String name; void display(){System.out.println(id+\"\n\"+name);} public static void main(String args[]){ Student3 s1=new Student3();\nStudent3 s2=new Student3(); s1.display(); s2.display(); } }\n\n, class Student4{ int id; String name; Student4(int i,String n){ id = i; name =\nn; } void display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student4 s1 = new Student4(111,\"Karan\"); Student4 s2 =\nnew Student4(222,\"Aryan\"); s1.display(); s2.display(); } }\n\n, class Student5{ int id; String name; int age; Student5(int i,String n){ id =\ni; name = n; } Student5(int i,String n,int a){ id = i; name = n; age=a; } void\ndisplay(){System.out.println(id+\" \"+name+\" \"+age);} public static void\nmain(String args[]){ Student5 s1 = new Student5(111,\"Hoang\"); Student5 s2 =\nnew Student5(222,\"Thanh\",25); s1.display(); s2.display(); } }\n\n, class Student6{ int id; String name; Student6(int i,String n){ id = i; name =\nn; } Student6(Student6 s){ id = s.id; name =s.name; } void\ndisplay(){System.out.println(id+\" \"+name);} public static void main(String\nargs[]){ Student6 s1 = new Student6(111,\"Hoang\"); Student6 s2 = new\nStudent6(s1); s1.display(); s2.display(); } }\n\n, class Student7{ int id; String name; Student7(int i,String n){ id = i; name =\nn; } Student7(){} void display(){System.out.println(id+\" \"+name);} public\nstatic void main(String args[]){ Student7 s1 = new Student7(111,\"Hoang\");\nStudent7 s2 = new Student7(); s2.id=s1.id; s2.name=s1.name; s1.display();\ns2.display(); } }\n\n"
    }
  },
  {
    "id": "63",
    "name": "Từ khóa static",
    "href": "https://www.vietjack.com/java/tu_khoa_static_trong_java.jsp",
    "lesson": {
      "title": "Từ khóa static trong Java",
      "content": "Khối static không còn tồn tại trong JDK 17. Trong JDK 17, không thể thực thi chương trình mà không có phương thức main. Phương thức main được sử dụng để khởi tạo các thành viên dữ liệu static. Phương thức main được thực thi trước các khối static tại thời điểm tải lớp.\n\nVí dụ về khối static trong Java:\n\n```java\npublic class StaticBlockExample {\n\n    static int count = 0; // Biến static\n\n    public static void main(String[] args) {\n        System.out.println(\"Giá trị của count: \" + count);\n    }\n\n    static {\n        // Khối static\n        count++;\n        System.out.println(\"Khối static được thực thi\");\n    }\n}\n```\n\nKết quả chạy chương trình:\n\n```\nKhối static được thực thi\nGiá trị của count: 1\n```\n\nPhương thức main trong Java là static vì nó được sử dụng để khởi tạo các thành viên dữ liệu static. Các thành viên dữ liệu static được chia sẻ giữa tất cả các đối tượng của lớp. Nếu phương thức main không phải là static, thì nó sẽ không thể truy cập các thành viên dữ liệu static.\n\nPhương thức static có thể truy cập các thành viên dữ liệu static và có thể thay đổi giá trị của nó. Một phương thức static có thể được triệu hồi mà không cần tạo một instance của một lớp. Một phương thức static thuộc lớp chứ không phải đối tượng của lớp.\n\nNếu bạn áp dụng từ khóa static với bất cứ phương thức nào thì phương thức đó được gọi là phương thức static.\n\nBiến static sẽ lấy bộ nhớ chỉ một lần. Nếu bất cứ đối tượng nào thay đổi giá trị của biến static, nó sẽ vẫn ghi nhớ giá trị của nó.\n\nVí dụ về biến instance và biến static:\n\n```java\npublic class InstanceAndStaticVariableExample {\n\n    int count = 0; // Biến instance\n\n    static int staticCount = 0; // Biến static\n\n    public static void main(String[] args) {\n        InstanceAndStaticVariableExample obj1 = new InstanceAndStaticVariableExample();\n        InstanceAndStaticVariableExample obj2 = new InstanceAndStaticVariableExample();\n\n        obj1.count++;\n        obj2.count++;\n\n        staticCount++;\n\n        System.out.println(\"Giá trị của count trong obj1: \" + obj1.count);\n        System.out.println(\"Giá trị của count trong obj2: \" + obj2.count);\n        System.out.println(\"Giá trị của staticCount: \" + staticCount);\n    }\n}\n```\n\nKết quả chạy chương trình:\n\n```\nGiá trị của count trong obj1: 1\nGiá trị của count trong obj2: 1\nGiá trị của staticCount: 1\n```\n\nNhư bạn có thể thấy, biến instance count có giá trị khác nhau đối với các đối tượng khác nhau, trong khi biến static staticCount có cùng giá trị đối với tất cả các đối tượng.\n\nBiến static giúp bộ nhớ chương trình của bạn được sử dụng hiệu quả hơn, tiết kiệm bộ nhớ. Biến static lấy bộ nhớ chỉ một lần trong class area tại thời điểm tải lớp đó.\n\nBiến static có thể được sử dụng để tham chiếu thuộc tính chung của tất cả đối tượng mà không là duy nhất cho mỗi đối tượng, ví dụ như tên công ty của nhân viên, tên trường học của các sinh viên.class Student{ int rollno; String name; String college=\"BachKhoa\"; }\n\n, //Chuong trinh vi du ve bien static trong Java class Student8{ int rollno;\nString name; static String college =\"BachKhoa\"; Student8(int r,String n){\nrollno = r; name = n; } void display (){System.out.println(rollno+\" \"+name+\"\n\"+college);} public static void main(String args[]){ Student8 s1 = new\nStudent8(111,\"Hoang\"); Student8 s2 = new Student8(222,\"Thanh\"); s1.display();\ns2.display(); } }\n\n, class Counter{ int count=0; //se lay bo nho (memory) khi bien instance duoc\ntao //Ket qua thuc hien chuong trinh hien ra 3 so 1 o 3 dong Counter(){\ncount++; System.out.println(count); } public static void main(String args[]){\nCounter c1=new Counter(); Counter c2=new Counter(); Counter c3=new Counter();\n} }\n\n, class Counter2{ static int count=0; //se lay bo nho chi mot lan và giu lai gia\ntri cua no //ket qua thuc hien in ra 3 dong cac gia tri : 1,2,3 Counter2(){\ncount++; System.out.println(count); } public static void main(String args[]){\nCounter2 c1=new Counter2(); Counter2 c2=new Counter2(); Counter2 c3=new\nCounter2(); } }\n\n, //Chuong trinh thay doi thuoc tinh chung cua tat ca doi tuong (truong static).\nclass Student9{ int rollno; String name; static String college = \"BachKhoa\";\nstatic void change(){ college = \"QuocGia\"; } Student9(int r, String n){ rollno\n= r; name = n; } void display (){System.out.println(rollno+\" \"+name+\"\n\"+college);} public static void main(String args[]){ Student9.change();\nStudent9 s1 = new Student9 (111,\"Hoang\"); Student9 s2 = new Student9\n(222,\"Thanh\"); Student9 s3 = new Student9 (333,\"Nam\"); s1.display();\ns2.display(); s3.display(); } }\n\n, //Chuong trinh lay cube (gia tri lap phuong) cua so da cho boi phuong thuc\nstatic class Calculate{ static int cube(int x){ return x*x*x; } public static\nvoid main(String args[]){ int result=Calculate.cube(5);\nSystem.out.println(result); } }\n\n, class A{ int a=40;//non static public static void main(String args[]){\nSystem.out.println(a); } }\n\n, class A2{ static{System.out.println(\"Khoi static duoc trieu hoi\");} public\nstatic void main(String args[]){ System.out.println(\"Hello main\"); } }\n\n, class A3{ static{ System.out.println(\"Khoi static duoc trieu hoi\");\nSystem.exit(0); } }\n\n"
    }
  },
  {
    "id": "73",
    "name": "Từ khóa this",
    "href": "https://www.vietjack.com/java/tu_khoa_this_trong_java.jsp",
    "lesson": {
      "title": "Từ khóa this trong Java",
      "content": "1. Từ khóa có thể được sử dụng để tham chiếu biến instance của lớp hiện tại.\n2. Từ khóa có thể được truyền như là một tham số trong lời gọi constructor.\n3. Từ khóa có thể được truyền như là một tham số trong lời gọi phương thức.\n4. Từ khóa có thể được sử dụng để triệu hồi ngầm định phương thức lớp hiện tại.\n5. Từ khóa có thể được sử dụng để triệu hồi constructor của lớp hiện tại.\n6. Từ khóa có thể được sử dụng để trả về instance của lớp hiện tại.class Student10{ int id; String name; Student10(int id,String name){ id = id;\nname = name; } void display(){System.out.println(id+\" \"+name);} public static\nvoid main(String args[]){ Student10 s1 = new Student10(111,\"Hoang\"); Student10\ns2 = new Student10(321,\"Thanh\"); s1.display(); s2.display(); } }\n\n, //Vi du ve tu khoa this trong Java class Student11{ int id; String name;\nStudent11(int id,String name){ this.id = id; this.name = name; } void\ndisplay(){System.out.println(id+\" \"+name);} public static void main(String\nargs[]){ Student11 s1 = new Student11(111,\"Hoang\"); Student11 s2 = new\nStudent11(222,\"Thanh\"); s1.display(); s2.display(); } }\n\n, class Student12{ int id; String name; Student12(int i,String n){ id = i; name\n= n; } void display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student12 e1 = new Student12(111,\"Hoang\"); Student12 e2 =\nnew Student12(222,\"Thanh\"); e1.display(); e2.display(); } }\n\n, //Chuong trinh vi du loi goi this() constructor (constructor chaining) class\nStudent13{ int id; String name; Student13(){System.out.println(\"Constructor\nmac dinh duoc goi\");} Student13(int id,String name){ this (); //no duoc su\ndung de goi constructor cua lop hien tai. this.id = id; this.name = name; }\nvoid display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student13 e1 = new Student13(111,\"Hoang\"); Student13 e2 =\nnew Student13(222,\"Thanh\"); e1.display(); e2.display(); } }\n\n, class Student14{ int id; String name; String city; Student14(int id,String\nname){ this.id = id; this.name = name; } Student14(int id,String name,String\ncity){ this(id,name); //Bay gio khong can khoi tao id va name this.city=city;\n} void display(){System.out.println(id+\" \"+name+\" \"+city);} public static void\nmain(String args[]){ Student14 e1 = new Student14(111,\"Hoang\"); Student14 e2 =\nnew Student14(222,\"Thanh\",\"NamDinh\"); e1.display(); e2.display(); } }\n\n, class Student15{ int id; String name;\nStudent15(){System.out.println(\"Constructor mac dinh duoc trieu hoi\");}\nStudent15(int id,String name){ id = id; name = name; this (); //phai la lenh\ndau tien } void display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student15 e1 = new Student15(111,\"Hoang\"); Student15 e2 =\nnew Student15(222,\"Thanh\"); e1.display(); e2.display(); } }\n\n, class S{ void m(){ System.out.println(\"Phuong thuc duoc trieu hoi\"); } void\nn(){ this.m(); //khong can boi vi compiler thuc hien no cho ban. } void p(){\nn(); //complier se them this de trieu hoi phuong thuc n() duoi dang this.n() }\npublic static void main(String args[]){ S s1 = new S(); s1.p(); } }\n\n, class S2{ void m(S2 obj){ System.out.println(\"Phuong thuc duoc trieu hoi\"); }\nvoid p(){ m(this); } public static void main(String args[]){ S2 s1 = new S2();\ns1.p(); } }\n\n, class B{ A4 obj; B(A4 obj){ this.obj=obj; } void display(){\nSystem.out.println(obj.data); //su dung thanh vien du lieu cua lop A4 } }\nclass A4{ int data=10; A4(){ B b=new B(this); b.display(); } public static\nvoid main(String args[]){ A4 a=new A4(); } }\n\n, kieu_tra_ve ten_phuong_thuc(){ return this; }\n\n, class A{ A getA(){ return this; } void msg(){System.out.println(\"Hello\nWorld\");} } class Test1{ public static void main(String args[]){ new\nA().getA().msg(); } }\n\n, class A5{ void m(){ System.out.println(this);//in ra cung tham chieu ID }\npublic static void main(String args[]){ A5 obj=new A5();\nSystem.out.println(obj);//in tham chieu ID obj.m(); } }\n\n"
    }
  },
  {
    "id": "83",
    "name": "Tính kế thừa (IS-A)",
    "href": "https://www.vietjack.com/java/tinh_ke_thua_trong_java.jsp",
    "lesson": {
      "title": "Tính kế thừa trong Java - Từ khóa extends và implements trong Java",
      "content": "- Tính kế thừa trong Java cho phép một lớp kế thừa các đặc điểm và hành vi của lớp khác.\n- Trong Java, một lớp có thể kế thừa từ một lớp cha duy nhất.\n- Khi một lớp kế thừa từ một lớp cha, nó sẽ có quyền truy cập vào các thành viên public và protected của lớp cha.\n- Từ khóa `extends` được sử dụng để chỉ ra rằng một lớp là lớp con của một lớp khác.\n- Một lớp có thể kế thừa từ nhiều interface, nhưng không thể kế thừa từ nhiều lớp.\n- Từ khóa `implements` được sử dụng để chỉ ra rằng một lớp thực hiện một interface.\n- Một lớp có thể kế thừa từ một lớp cha và thực hiện nhiều interface.\n- Tính kế thừa trong Java giúp tăng tính tái sử dụng mã và giảm sự trùng lặp.\n- Tính kế thừa trong Java cũng giúp cải thiện tính bảo mật và tính bảo trì của mã.class ten_lop_con extends ten_lop_cha { //cac phuong thuc va cac truong }\n\n, class Employee{ float salary=40000; } class Programmer extends Employee{ int\nbonus=10000; public static void main(String args[]){ Programmer p=new\nProgrammer(); System.out.println(\"Luong Lap trinh vien la:\"+p.salary);\nSystem.out.println(\"Bonus cua Lap trinh vien la:\"+p.bonus); } }\n\n, class A{ void msg(){System.out.println(\"Hello\");} } class B{ void\nmsg(){System.out.println(\"Welcome\");} } class C extends A,B { //gia su neu no\nda co Public Static void main(String args[]){ C obj=new C(); obj.msg();//Bay\ngio phuong thuc msg() nao se duoc goi? } }\n\n, public interface A {} public class B implements A{ } public class C extends B{\n}\n\n, interface A{} class B implements A{} public class C extends B{ public static\nvoid main(String args[]){ B m = new B(); C d = new C(); System.out.println(m\ninstanceof A); System.out.println(d instanceof B); System.out.println(d\ninstanceof A); } }\n\n, true true true\n\n, public class Vehicle{} public class Speed{} public class Van extends Vehicle{\nprivate Speed sp; }\n\n, public class C extends A, B{}\n\n"
    }
  },
  {
    "id": "93",
    "name": "Quan hệ (HAS-A)",
    "href": "https://www.vietjack.com/java/quan_he_has_a_trong_java.jsp",
    "lesson": {
      "title": "Quan hệ HAS-A trong Java",
      "content": "Chạy chương trình sẽ cho kết quả, tệp empjava có nội dung sau, tệp addressjava có nội dung, như trong ví dụ trên đã đề cập employee có một đối tượng là address đối tượng này chứa thông tin riêng như city state country trong tình huống này mối quan hệ là employee hasa address, trong ví dụ chúng ta tạo tham chiếu của lớp operation trong lớp circle, tính kế thừa nên chỉ được sử dụng nếu mối quan hệ isa được duy trì thông qua suốt vòng đời của đối tượng có liên quan nếu không thì quan hệ hasa là lựa chọn tốt nhất, sử dụng quan hệ hasa giúp làm tăng tính tái sử dụng của code và khi không có mối quan hệ isa thì quan hệ hasa là lựa chọn tốt nhất, trong tình huống như vậy emloyee có một address là tham chiếu thực thể vì thế mối quan hệ là employee hasa address, nếu một lớp có một tham chiếu thực thể thì nó được biết đến như là một lớp có quan hệ hasa giả sử một tình huống đối tượng employee chứa nhiều thông tin như id name eamailid nó gồm một hoặc nhiều đối tượng address mà có thông tin riêng như city state country zipcode như sau.\n\nTóm lại, quan hệ hasa là một mối quan hệ trong đó một đối tượng có tham chiếu đến một đối tượng khác. Quan hệ này được sử dụng khi không có mối quan hệ isa giữa các đối tượng. Quan hệ hasa giúp tăng tính tái sử dụng của code và làm cho code dễ bảo trì hơn.class Employee{ int id; String name; Address address; //Address la mot lop ...\n}\n\n, class Operation{ int square(int n){ return n*n; } } class Circle{ Operation\nop; //quan hệ HAS-A double pi=3.14; double area(int radius){ op=new\nOperation(); int rsquare=op.square(radius); //tai su dung code (vi du: uy\nquyen cho loi goi phuong thuc). return pi*rsquare; } public static void\nmain(String args[]){ Circle c=new Circle(); double result=c.area(5);\nSystem.out.println(result); } }\n\n, public class Address { String city,state,country; public Address(String city,\nString state, String country) { this.city = city; this.state = state;\nthis.country = country; } }\n\n, public class Emp { int id; String name; Address address; public Emp(int id,\nString name,Address address) { this.id = id; this.name = name;\nthis.address=address; } void display(){ System.out.println(id+\" \"+name);\nSystem.out.println(address.city+\" \"+address.state+\" \"+address.country); }\npublic static void main(String[] args) { Address address1=new\nAddress(\"hanoi\",\"HN\",\"vietnam\"); Address address2=new\nAddress(\"hadong\",\"HN\",\"vietnam\"); Emp e=new Emp(111,\"hoang\",address1); Emp\ne2=new Emp(112,\"thanh\",address2); e.display(); e2.display(); } }\n\n, Output:111 hoang hanoi HN vietnam 112 thanh hadong HN vietnam\n\n"
    }
  },
  {
    "id": "103",
    "name": "Ghi đè phương thức (Overriding)",
    "href": "https://www.vietjack.com/java/overriding_trong_java.jsp",
    "lesson": {
      "title": "Ghi đè phương thức trong Java",
      "content": "* Ghi đè phương thức xảy ra khi một lớp con cung cấp trình triển khai cụ thể của một phương thức mà đã được cung cấp bởi lớp cha của nó.\n* Ghi đè phương thức chỉ có thể xảy ra nếu phương thức được ghi đè có cùng tên, cùng tham số và cùng kiểu trả về với phương thức được ghi đè trong lớp cha.\n* Ghi đè phương thức được sử dụng để thu được tính đa hình tại runtime.\n* Nạp chồng phương thức xảy ra khi một lớp có nhiều phương thức có cùng tên nhưng khác nhau về tham số.\n* Nạp chồng phương thức không liên quan đến các lớp cha và con.\n* Nạp chồng phương thức được sử dụng để cung cấp các chức năng khác nhau cho cùng một phương thức.1. Nạp chồng phương thức giúp tăng tính dễ đọc của chương trình trong khi ghi đè phương thức cung cấp triển khai cụ thể của phương thức được định nghĩa trong lớp cha.\n\n2. Nạp chồng phương thức được thực hiện trong một lớp duy nhất, trong khi ghi đè phương thức xảy ra giữa hai lớp có mối quan hệ kế thừa.\n\n3. Trong nạp chồng phương thức, các tham số phải khác nhau, trong khi trong ghi đè phương thức, các tham số phải giống nhau.\n\n4. Nạp chồng phương thức là ví dụ của đa hình thời gian biên dịch, trong khi ghi đè phương thức là ví dụ của đa hình thời gian chạy.\n\n5. Trong Java, nạp chồng phương thức không thể thực hiện bằng cách thay đổi kiểu trả về của phương thức, trong khi ghi đè phương thức yêu cầu kiểu trả về phải giống nhau hoặc có mối quan hệ covariant.class Vehicle{ void run(){System.out.println(\"Vehicle dang chay\");} } class\nBike extends Vehicle{ public static void main(String args[]){ Bike obj = new\nBike(); obj.run(); } }\n\n, class Vehicle{ void run(){System.out.println(\"Vehicle dang chay\");} } class\nBike2 extends Vehicle{ void run(){System.out.println(\"Bike dang chay an\ntoan\");} public static void main(String args[]){ Bike2 obj = new Bike2();\nobj.run(); }\n\n, class Bank{ int getRateOfInterest(){return 0;} } class VCB extends Bank{ int\ngetRateOfInterest(){return 8;} } class AGR extends Bank{ int\ngetRateOfInterest(){return 7;} } class CTG extends Bank{ int\ngetRateOfInterest(){return 9;} } class Test2{ public static void main(String\nargs[]){ VCB s=new VCB(); AGR i=new AGR(); CTG a=new CTG();\nSystem.out.println(\"VCB Rate of Interest: \"+s.getRateOfInterest());\nSystem.out.println(\"AGR Rate of Interest: \"+i.getRateOfInterest());\nSystem.out.println(\"CTG Rate of Interest: \"+a.getRateOfInterest()); } }\n\n"
    }
  },
  {
    "id": "113",
    "name": "Kiểu trả về Covariant",
    "href": "https://www.vietjack.com/java/kieu_tra_ve_covariant_trong_java.jsp",
    "lesson": {
      "title": "Kiểu trả về covariant trong Java",
      "content": "Nếu bạn là người mới học lập trình, bạn có thể bỏ qua chương này và tiếp tục theo dõi chương tiếp theo. Như bạn thấy trong ví dụ trên, kiểu trả về của phương thức `get()` của lớp `A` là `A`, nhưng kiểu trả về của phương thức `get()` của lớp `B` là `B`. Cả hai phương thức có kiểu trả về khác nhau và nó là ghi đè phương thức. Đây còn được biết đến như là kiểu trả về covariant. Kiểu trả về covariant xác định rằng kiểu trả về có thể thay đổi trong lớp con, tức là một phương thức có thể trả về kiểu hẹp hơn khi phương thức đó được override ở lớp con. Trước Java 5, không thể ghi đè bất kỳ phương thức nào bằng cách thay đổi kiểu trả về, nhưng bây giờ từ Java 5, có thể ghi đè phương thức bằng cách thay đổi kiểu trả về. Nếu lớp con ghi đè bất kỳ phương thức nào mà có kiểu trả về không phải là kiểu gốc, bạn có thể theo dõi ví dụ đơn giản sau.class A{ A get(){return this;} } class B1 extends A{ B1 get(){return this;}\nvoid message(){System.out.println(\"Chao mung den voi kieu tra ve covariant\");}\npublic static void main(String args[]){ new B1().get().message(); } }\n\n"
    }
  },
  {
    "id": "123",
    "name": "Từ khóa super",
    "href": "https://www.vietjack.com/java/tu_khoa_super_trong_java.jsp",
    "lesson": {
      "title": "Từ khóa super trong Java",
      "content": "- Super trong Java được sử dụng để triệu hồi phương thức lớp cha gần nhất.\n- Super trong Java được sử dụng để triệu hồi constructor của lớp cha gần nhất.\n- Super trong Java được sử dụng để tham chiếu biến instance của lớp cha gần nhất.\n- Super trong Java là một biến tham chiếu được sử dụng để tham chiếu đến đối tượng lớp cha gần nhất bất cứ khi nào bạn tạo instance của lớp con.class Vehicle{ int speed=50; } class Bike3 extends Vehicle{ int speed=100;\nvoid display(){ System.out.println(speed); //se in speed cua Bike } public\nstatic void main(String args[]){ Bike3 b=new Bike3(); b.display(); } }\n\n, //Chuong trinh vi du tu khoa super class Vehicle{ int speed=50; } class Bike4\nextends Vehicle{ int speed=100; void display(){\nSystem.out.println(super.speed); //bay gio se in speed cua Vehicle } public\nstatic void main(String args[]){ Bike4 b=new Bike4(); b.display(); } }\n\n, class Vehicle{ Vehicle(){System.out.println(\"Vehicle duoc tao\");} } class\nBike5 extends Vehicle{ Bike5(){ super();//se trieu hoi constructor cua lop cha\nSystem.out.println(\"Bike duoc tao\"); } public static void main(String args[]){\nBike5 b=new Bike5(); } }\n\n, class Vehicle{ Vehicle(){System.out.println(\"Vehicle duoc tao\");} } class\nBike6 extends Vehicle{ int speed; Bike6(int speed){ this.speed=speed;\nSystem.out.println(speed); } public static void main(String args[]){ Bike6\nb=new Bike6(10); } }\n\n, class Person{ void message(){System.out.println(\"Chao mung\");} } class\nStudent16 extends Person{ void message(){System.out.println(\"Chao mung ban den\nvoi java\");} void display(){ message();//se trieu hoi phuong thuc message()\ncua lop hien tai super.message();//se trieu hoi phuong thuc message() cua lop\ncha } public static void main(String args[]){ Student16 s=new Student16();\ns.display(); } }\n\n, class Person{ void message(){System.out.println(\"Chao mung\");} } class\nStudent17 extends Person{ void display(){ message();//se trieu hoi phuong thuc\nmessage() cua lop cha } public static void main(String args[]){ Student17\ns=new Student17(); s.display(); } }\n\n"
    }
  },
  {
    "id": "133",
    "name": "Từ khóa final",
    "href": "https://www.vietjack.com/java/tu_khoa_final_trong_java.jsp",
    "lesson": {
      "title": "Từ khóa final trong Java",
      "content": "Từ khóa final trong Java dùng để hạn chế người dùng. Có thể sử dụng từ khóa này trong nhiều ngữ cảnh, bao gồm biến, phương thức và lớp.\n\nĐối với biến, final có nghĩa là giá trị của biến không thể bị thay đổi sau khi được gán. Một biến final không có giá trị nào được gọi là biến final trống hoặc biến final không được khởi tạo. Biến final trống chỉ có thể được khởi tạo trong constructor. Biến final trống cũng có thể là static, trong trường hợp đó, nó chỉ có thể được khởi tạo trong khối static.\n\nĐối với phương thức, final có nghĩa là phương thức không thể bị ghi đè trong các lớp con.\n\nĐối với lớp, final có nghĩa là lớp không thể bị kế thừa.\n\nMột số ví dụ về sử dụng từ khóa final:\n\n* Một lớp final không thể bị kế thừa.\n* Một phương thức final không thể bị ghi đè.\n* Một biến final không thể bị thay đổi sau khi được gán.\n* Một biến final trống có thể được khởi tạo trong constructor.\n* Một biến final trống cũng có thể là static, trong trường hợp đó, nó chỉ có thể được khởi tạo trong khối static.class Bike9{ final int speedlimit=90;//bien final void run(){ speedlimit=400;\n} public static void main(String args[]){ Bike9 obj=new Bike9(); obj.run(); }\n}//phan cuoi cua lop\n\n, class Bike{ final void run(){System.out.println(\"running\");} } class Honda\nextends Bike{ void run(){System.out.println(\"Chay an toan voi 100kmph\");}\npublic static void main(String args[]){ Honda honda= new Honda(); honda.run();\n} }\n\n, final class Bike{} class Honda1 extends Bike{ void\nrun(){System.out.println(\"Chay an toan voi 100kmph\");} public static void\nmain(String args[]){ Honda1 honda= new Honda(); honda.run(); } }\n\n, class Bike{ final void run(){System.out.println(\"dang chay...\");} } class\nHonda2 extends Bike{ public static void main(String args[]){ new\nHonda2().run(); } }\n\n, class Student{ int id; String name; final String PAN_CARD_NUMBER; ... }\n\n, class Bike10{ final int speedlimit;//bien final trong Bike10(){ speedlimit=70;\nSystem.out.println(speedlimit); } public static void main(String args[]){ new\nBike10(); } }\n\n, class A{ static final int data;//bien static final trong static{ data=50;}\npublic static void main(String args[]){ System.out.println(A.data); } }\n\n, class Bike11{ int cube(final int n){ n=n+2;//khong the duoc thay doi khi n la\nfinal n*n*n; } public static void main(String args[]){ Bike11 b=new Bike11();\nb.cube(5); } }\n\n"
    }
  },
  {
    "id": "143",
    "name": "Tính đa hình",
    "href": "https://www.vietjack.com/java/da_hinh_trong_java.jsp",
    "lesson": {
      "title": "Đa hình trong Java",
      "content": "Đa hình tại runtime trong Java là một tiến trình mà trong đó một lời gọi tới một phương thức được ghi đè được xử lý tại runtime thay vì tại compile time. Khi biến tham chiếu của lớp cha tham chiếu tới đối tượng của lớp con thì đó là upcasting.\n\nVí dụ:\n- Lớp Dog có phương thức eat().\n- Lớp BabyDog kế thừa lớp Dog và ghi đè phương thức eat().\n- Khi gọi phương thức eat() thông qua biến tham chiếu của lớp cha, phương thức eat() của lớp BabyDog được triệu hồi.\n\nĐa hình tại runtime không thể có được bởi thành viên dữ liệu. Thành viên dữ liệu không bị ghi đè, vì thế khi truy cập thành viên dữ liệu thông qua biến tham chiếu của lớp cha, luôn luôn truy cập thành viên dữ liệu của lớp cha.\n\nVí dụ:\n- Lớp Vehicle có thành viên dữ liệu speedLimit.\n- Lớp Car kế thừa lớp Vehicle.\n- Khi truy cập thành viên dữ liệu speedLimit thông qua biến tham chiếu của lớp Vehicle, luôn luôn truy cập thành viên dữ liệu speedLimit của lớp Vehicle.\n\nTính đa hình trong Java là một khái niệm mà từ đó chúng ta có thể thực hiện một hành động đơn theo nhiều cách khác nhau. Tính đa hình được suy ra từ hai từ Hy Lạp là poly và morphs. Poly nghĩa là nhiều và morphs nghĩa là hình dạng. Có hai kiểu đa hình trong Java: đa hình tại compile time và đa hình runtime. Chúng ta có thể thực hiện tính đa hình trong Java bởi nạp chồng phương thức và ghi đè phương thức.class A{} class B extends A{}\n\n, A a=new B();//day la upcasting\n\n, class Bike{ void run(){System.out.println(\"dang chay\");} } class Splender\nextends Bike{ void run(){System.out.println(\"chay an toan voi 60km\");} public\nstatic void main(String args[]){ Bike b = new Splender();//day la upcasting\nb.run(); } }\n\n, class Bank{ int getRateOfInterest(){return 0;} } class VCB extends Bank{ int\ngetRateOfInterest(){return 8;} } class AGR extends Bank{ int\ngetRateOfInterest(){return 7;} } class CTG extends Bank{ int\ngetRateOfInterest(){return 9;} } class Test3{ public static void main(String\nargs[]){ Bank b1=new VCB(); Bank b2=new AGR(); Bank b3=new CTG();\nSystem.out.println(\"VCB lai suat la: \"+b1.getRateOfInterest());\nSystem.out.println(\"AGR lai suat la: \"+b2.getRateOfInterest());\nSystem.out.println(\"CTG lai suat la: \"+b3.getRateOfInterest()); } }\n\n, class Bike{ int speedlimit=90; } class Honda3 extends Bike{ int\nspeedlimit=150; public static void main(String args[]){ Bike obj=new Honda3();\nSystem.out.println(obj.speedlimit);//90 }\n\n, class Animal{ void eat(){System.out.println(\"an\");} } class Dog extends\nAnimal{ void eat(){System.out.println(\"an hoa qua\");} } class BabyDog extends\nDog{ void eat(){System.out.println(\"uong sua\");} public static void\nmain(String args[]){ Animal a1,a2,a3; a1=new Animal(); a2=new Dog(); a3=new\nBabyDog(); a1.eat(); a2.eat(); a3.eat(); } }\n\n, class Animal{ void eat(){System.out.println(\"animao dang an...\");} } class Dog\nextends Animal{ void eat(){System.out.println(\"dog dang an...\");} } class\nBabyDog1 extends Dog{ public static void main(String args[]){ Animal a=new\nBabyDog1(); a.eat(); }}\n\n"
    }
  },
  {
    "id": "153",
    "name": "Dynamic Binding",
    "href": "https://www.vietjack.com/java/dynamic_binding_trong_java.jsp",
    "lesson": {
      "title": "Gắn kết tĩnh và Gắn kết động (Dynamic Binding) trong Java",
      "content": "* Kiểu của đối tượng không thể được quyết định bởi trình biên dịch vì biểu diễn của `dog` cũng là biểu diễn của `animal`. Do đó, trình biên dịch không biết loại nào trong số chúng mà nó chỉ biết đến loại cơ sở.\n* Khi loại đối tượng được xác định tại thời gian chạy, thì đó là liên kết động (dynamic binding). Khi loại đối tượng được xác định tại thời gian biên dịch bởi trình biên dịch, thì đó là liên kết tĩnh (static binding).\n* Nếu có bất kỳ phương thức `private`, `final` hoặc `static` nào trong một lớp, thì đó là liên kết tĩnh. Trong trường hợp này, không thể có chuyện ghi đè (overloading).\n* Kết quả là, đối với lập trình hướng đối tượng trong liên kết tĩnh, `d1` là một biểu hiện của lớp `dog` nhưng nó cũng là một biểu hiện của `animal`.\n* Ba đối tượng có một loại đối tượng là một phiên bản của lớp Java cụ thể, nhưng nó cũng là một phiên bản của lớp cha.\n* Hai tham chiếu có một loại, trong trường hợp này biến `data` là kiểu `int`.\n* Một biến có một loại, nó có thể là loại gốc hoặc loại khác không phải là loại gốc.\n* Trước khi đi vào thảo luận về liên kết, chúng ta cần làm rõ `type` là gì.\n* Liên kết là kết nối một lời gọi phương thức với thân phương thức. Có hai loại liên kết là liên kết tĩnh (static binding) hay liên kết sớm (early binding) và liên kết động (dynamic binding) hay liên kết trễ (late binding).int data=30;\n\n, class Dog{ public static void main(String args[]){ Dog d1;//O day, d1 la kieu\ncua Dog } }\n\n, class Animal{} class Dog extends Animal{ public static void main(String\nargs[]){ Dog d1=new Dog(); } }\n\n, class Dog{ private void eat(){System.out.println(\"dog dang an...\");} public\nstatic void main(String args[]){ Dog d1=new Dog(); d1.eat(); } }\n\n, class Animal{ void eat(){System.out.println(\"animal dang an...\");} } class Dog\nextends Animal{ void eat(){System.out.println(\"dog dang an...\");} public\nstatic void main(String args[]){ Animal a=new Dog(); a.eat(); } }\n\n"
    }
  },
  {
    "id": "163",
    "name": "Toán tử instanceof",
    "href": "https://www.vietjack.com/java/toan_tu_instanceof_trong_java.jsp",
    "lesson": {
      "title": "Toán tử instanceof trong Java",
      "content": "Trong Java, toán tử `instanceof` được dùng để kiểm tra xem một đối tượng có thuộc một kiểu cụ thể hay không. Toán tử `instanceof` trả回 `true` hoặc `false` và có thể được dùng để kiểm tra xem một đối tượng có thuộc một lớp cụ thể, một lớp con hoặc một interface hay không.\n\nTrong ví dụ sau, biến `dog` là một đối tượng của lớp `dog`, là lớp con của lớp `animal`, và toán tử `instanceof` được dùng để kiểm tra xem biến `dog` có thuộc lớp `animal` hay không:\n\n```java\nif (dog instanceOf animal) {\n  // dog là một đối tượng của lớp animal\n} else {\n  // dog không là một đối tượng của lớp animal\n}\n```\n\nToán tử `instanceof` có thể được dùng để kiểm tra xem một đối tượng có thuộc một lớp cụ thể hay không, ngay cả khi lớp đó không phải là lớp cha trưc tiếp của đối tượng. Ví dụ, trong ví dụ sau, lớp `dog` không phải là lớp cha trưc tiếp của lớp `animal`, nhưng toán tử `instanceof` vẫn có thể được dùng để kiểm tra xem biến `dog` có thuộc lớp `animal` hay không:\n\n```java\nif (dog instanceOf animal) {\n  // dog là một đối tượng của lớp animal\n} else {\n  // dog không là một đối tượng của lớp animal\n}\n```\n\nToán tử `instanceof` cũng có thể được dùng để kiểm tra xem một đối tượng có thuộc một interface hay không. Ví dụ, trong ví dụ sau, lớp `dog` thừa kế interface `speakable`, và toán tử `instanceof` được dùng để kiểm tra xem biến `dog` có thuộc interface `speakable` hay không:\n\n```java\nif (dog instanceOf speakable) {\n  // dog là một đối tượng của interface speakable\n} else {\n  // dog không là một đối tượng của interface speakable\n}\n```class Simple1{ public static void main(String args[]){ Simple1 s=new\nSimple1(); System.out.println(s instanceof Simple);//true } }\n\n, class Animal{} class Dog1 extends Animal {//Dog ke thua Animal public static\nvoid main(String args[]){ Dog1 d=new Dog1(); System.out.println(d instanceof\nAnimal);//true } }\n\n, class Dog2{ public static void main(String args[]){ Dog2 d=null;\nSystem.out.println(d instanceof Dog2);//false } }\n\n, Dog d=new Animal();// gay ra loi tai thoi gian bien dich\n\n, Dog d=(Dog)new Animal(); //Bien dich thanh cong nhung ClassCastException bi\nnem tai runtime\n\n, class Animal { } class Dog3 extends Animal { static void method(Animal a) {\nif(a instanceof Dog3){ Dog3 d=(Dog3)a; //day la downcasting\nSystem.out.println(\"Bay gio downcasting duoc thuc hien\"); } } public static\nvoid main (String [] args) { Animal a=new Dog3(); Dog3.method(a); } }\n\n, class Animal { } class Dog4 extends Animal { static void method(Animal a) {\nDog4 d=(Dog4)a;//Day la downcasting System.out.println(\"downcasting duoc thuc\nhien\"); } public static void main (String [] args) { Animal a=new Dog4();\nDog4.method(a); } }\n\n, Animal a=new Animal(); Dog.method(a); //Bay gio la ClassCastException nhung\nkhong trong truong hop cua toan tu instanceof\n\n, interface Printable{} class A implements Printable{ public void\na(){System.out.println(\"Phuong thuc a\");} } class B implements Printable{\npublic void b(){System.out.println(\"Phuong thuc b\");} } class Call{ void\ninvoke(Printable p) { //Day la upcasting if(p instanceof A){ A a=(A)p;//Day la\nDowncasting a.a(); } if(p instanceof B){ B b=(B)p;//Day la Downcasting b.b();\n} } }//Phan cuoi cua lop Call class Test4{ public static void main(String\nargs[]){ Printable p=new B(); Call c=new Call(); c.invoke(p); } }\n\n, Output: b method\n\n"
    }
  },
  {
    "id": "173",
    "name": "Tính trừu tượng",
    "href": "https://www.vietjack.com/java/truu_tuong_trong_java.jsp",
    "lesson": {
      "title": "Tính trừu tượng trong Java",
      "content": "Nếu salary kế thừa lớp employee thì salary cần triển khai phương thức computepay. Lớp con phải triển khai phương thức abstract nếu không sẽ có một cấu trúc phân cấp của các lớp abstract mà không thể khởi tạo. Một lớp con mà kế thừa một phương thức abstract phải ghi đè nó nếu không thì nó phải là abstract và bất kỳ lớp con nào của chúng phải ghi đè nó. Bất kỳ lớp con nào phải ghi đè phương thức abstract hoặc khai báo abstract chính nó. Lớp phải được khai báo abstract nếu một lớp chứa một phương thức abstract thì lớp đó cũng phải là abstract. Khai báo một phương thức dạng abstract tạo hai kết quả sau: phương thức abstract sẽ không có định nghĩa và chữ số của nó được theo sau bởi dấu chấm phảy không có dấu ngoặc móc ôm theo sau. Từ khóa abstract được sử dụng để khai báo một phương thức dạng abstract một phương thức gồm một chữ số và không có thân phương thức. Nếu muốn một lớp chứa một phương thức cụ thể nhưng muốn triển khai thực sự phương thức đó để được quyết định bởi các lớp con thì có thể khai báo phương thức đó trong lớp cha ở dạng abstract. Ở đây không thể khởi tạo một employee mới nhưng nếu khởi tạo một đối tượng salary mới đối tượng salary này sẽ kế thừa 3 trường 7 phương thức từ employee. Có thể kế thừa lớp employee theo cách thông thường. Khi biên dịch lớp trên sẽ nhận một lỗi. Có thể thử làm như sau, không có gì khác trong lớp employee này lớp này bây giờ là abstract nhưng nó vẫn có 3 trường 7 phương thức và một constructor. Sử dụng từ khóa abstract để khai báo một lớp abstract từ khóa này xuất hiện trước từ khóa class trong khai báo lớp. Nếu một lớp là lớp trừu tượng và nó không được khởi tạo lớp này không được sử dụng trừ khi nó là lớp con. Tính trừu tượng abstraction trong java hướng đến khả năng tạo một đối tượng trừu tượng trong lập trình hướng đối tượng một lớp trừu tượng là một lớp mà không được khởi tạo tất cả các chức năng khác của lớp vẫn tồn tại và tất cả các trường phương thức và hàm khởi tạo đều được truy cập với một cách giống nhau không thể tạo một đối tượng với một lớp trừu tượng hóa./* Ten File : Employee.java */ public abstract class Employee { private String\nname; private String address; private int number; public Employee(String name,\nString address, int number) { System.out.println(\"Xay dung mot Employee\");\nthis.name = name; this.address = address; this.number = number; } public\ndouble computePay() { System.out.println(\"Ben trong Employee computePay\");\nreturn 0.0; } public void mailCheck() { System.out.println(\"Gui mail kiem tra\ntoi \" + this.name \\+ \" \" + this.address); } public String toString() { return\nname + \" \" + address + \" \" + number; } public String getName() { return name;\n} public String getAddress() { return address; } public void setAddress(String\nnewAddress) { address = newAddress; } public int getNumber() { return number;\n} }\n\n, /* Ten File : AbstractDemo.java */ public class AbstractDemo { public static\nvoid main(String [] args) { /* Phan sau la khong duoc phep va se tao mot error\n*/ Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\nSystem.out.println(\"\\n Goi mailCheck boi su dung tham chieu Employee --\");\ne.mailCheck(); } }\n\n, Employee.java:46: Employee is abstract; cannot be instantiated Employee e =\nnew Employee(\"George W.\", \"Houston, TX\", 43); ^ 1 error\n\n, /* Ten File : Salary.java */ public class Salary extends Employee { private\ndouble salary; //Annual salary public Salary(String name, String address, int\nnumber, double salary) { super(name, address, number); setSalary(salary); }\npublic void mailCheck() { System.out.println(\"Ben trong mailCheck cua Salary\nclass \"); System.out.println(\"Gui mail kiem tra toi \" + getName() \\+ \" voi\nsalary la \" + salary); } public double getSalary() { return salary; } public\nvoid setSalary(double newSalary) { if(newSalary >= 0.0) { salary = newSalary;\n} } public double computePay() { System.out.println(\"Tinh toan luong tra cho \"\n+ getName()); return salary/52; } }\n\n, /* Ten File : AbstractDemo.java */ public class AbstractDemo { public static\nvoid main(String [] args) { Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta,\nUP\", 3, 3600.00); Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2,\n2400.00); System.out.println(\"Goi mailCheck boi su dung tham chieu Salary\n--\"); s.mailCheck(); System.out.println(\"\\n Goi mailCheck boi su dung tham\nchieu Employee --\"); e.mailCheck(); } }\n\n, Xay dung mot Employee Xay dung mot Employee Goi mailCheck boi su dung tham\nchieu Salary -- Ben trong mailCheck cua Salary class Gui mail kiem tra toi\nMohd Mohtashim voi salary la 3600.0 Call mailCheck using Employee reference--\nBen trong mailCheck cua Salary class Gui mail kiem tra toi John Adams voi\nsalary la 2400.\n\n, public abstract class Employee { private String name; private String address;\nprivate int number; public abstract double computePay(); //Phan con lai cua\ndinh nghia class }\n\n, /* Ten File : Salary.java */ public class Salary extends Employee { private\ndouble salary; // Annual salary public double computePay() {\nSystem.out.println(\"Tinh toan luong tra cho \" + getName()); return salary/52;\n} //Phan con lai cua dinh nghia class }\n\n"
    }
  },
  {
    "id": "183",
    "name": "Lớp abstract",
    "href": "https://www.vietjack.com/java/lop_abstract_trong_java.jsp",
    "lesson": {
      "title": "Lớp trừu tượng -  Abstract Class trong Java",
      "content": "Tính trừu tượng trong lập trình hướng đối tượng là quá trình ẩn đi các chi tiết cụ thể của một đối tượng và chỉ hiển thị các đặc điểm cần thiết cho người dùng. Lớp trừu tượng là một lớp không thể khởi tạo đối tượng, nhưng có thể kế thừa và triển khai các phương thức trừu tượng của nó. Phương thức trừu tượng là phương thức không có định nghĩa và được theo sau bởi dấu chấm phảy. Một lớp được khai báo là abstract thì đó là lớp trừu tượng, nó cần được kế thừa và phương thức của nó được triển khai.\n\nInterface cũng là một lớp trừu tượng, nhưng nó chỉ chứa các phương thức trừu tượng và không có các phương thức cụ thể. Các lớp con của interface phải triển khai tất cả các phương thức trừu tượng của interface đó.\n\nTóm lại, lớp trừu tượng có thể có cả phương thức trừu tượng và phương thức cụ thể, trong khi interface chỉ có các phương thức trừu tượng. Lớp trừu tượng thường được sử dụng để thể hiện mối quan hệ cha-con, trong khi interface thường được sử dụng để thể hiện mối quan hệ \"có thể\".abstract class A{}\n\n, abstract void printStatus(); // Khai bao phuong thuc voi tu khoa abstract va\nkhong co than phuong thuct\n\n, // lop truu tuong Bike abstract class Bike{ abstract void run(); // phuong\nthuc truu tuong voi tu khoa abstract } // lop Honda4 ke thua lop truu tuong\nBike class Honda4 extends Bike{ void run(){ System.out.println(\"Dang chay mot\ncach an toan..\"); } // phuong thuc main() public static void main(String\nargs[]){ Bike obj = new Honda4(); obj.run(); } }\n\n, // lop truu tuong Shape abstract class Shape{ abstract void draw(); } //Trong\ntinh huong nay, trinh trien khai duoc cung cap boi ai do, vi du: nguoi su dung\ncuoi cung nao do class Rectangle extends Shape{ void draw(){\nSystem.out.println(\"Ve hinh chu nhat\"); } } class Circle1 extends Shape{ void\ndraw(){ System.out.println(\"Ve hinh tron\"); } } //Trong tinh huong nay, phuong\nthuc duoc goi boi lap trinh vien hoac nguoi dung class TestAbstraction1{\npublic static void main(String args[]){ Shape s=new Circle1(); //Trong tinh\nhuong nay, doi tuong duoc cung cap thong qua phuong thuc, chang han nhu\ngetShape() s.draw(); } }\n\n, abstract class Bank{ abstract int getRateOfInterest(); }\n\n, class SBI extends Bank{ int getRateOfInterest(){return 7;} // bat buoc phai\ncung cap trinh trien khai cua getRateOfInterest }\n\n, class PNB extends Bank{ int getRateOfInterest(){return 8;} // bat buoc phai\ncung cap trinh trien khai cua getRateOfInterest }\n\n, class TestBank{ public static void main(String args[]){ // Tao mot doi tuong\nSBI moi Bank b=new SBI(); //Neu doi tuong la PNB, phuong thuc cua PNB se duoc\ntrieu hoi int interest=b.getRateOfInterest(); //Trieu hoi phuong thuc cua SBI\nSystem.out.println(\"Ti le lai suat la: \"+interest+\" %\"); }}\n\n, //vi du ve lop abstract ma co than phuong thuc abstract class Bike{ Bike(){\nSystem.out.println(\"bike duoc tao\"); } abstract void run(); void changeGear(){\nSystem.out.println(\"gear duoc thay doi\"); } } class Honda extends Bike{ void\nrun(){ System.out.println(\"dang chay mot cach an toan..\"); } } class\nTestAbstraction2{ public static void main(String args[]){ Bike obj = new\nHonda(); obj.run(); obj.changeGear(); } }\n\n, // mot interface A interface A{ void a(); void b(); void c(); void d(); } //\nlop truu tuong B ke thua interface A abstract class B implements A{ //trong vi\ndu nay, lop truu tuong B co the chi cung cap trinh trien khai phuong thuc c()\npublic void c(){ System.out.println(\"Toi la C\"); } } // lop M ke thua lop truu\ntuong B class M extends B{ // bat buoc phai trien khai cac phuong thuc a(),\nb(), c() public void a(){ System.out.println(\"Toi la a\"); } public void b(){\nSystem.out.println(\"Toi la b\"); } public void d(){ System.out.println(\"Toi la\nd\"); } } // lop Test5 chua phuong thuc main() class Test5{ public static void\nmain(String args[]){ A a=new M(); a.a(); a.b(); a.c(); a.d(); }}\n\n"
    }
  },
  {
    "id": "193",
    "name": "Interface",
    "href": "https://www.vietjack.com/java/interface_trong_java.jsp",
    "lesson": {
      "title": "Interface trong Java",
      "content": "Khi triển khai một interface, cần lưu ý một số quy tắc sau:\n\n- Lớp triển khai có thể là abstract và vì thế các phương thức interface không cần được triển khai.\n- Khi ghi đè phương thức overriding method, signature ký số của phương thức interface và kiểu trả về nên được duy trì.\n- Các checked exception không nên được khai báo trong phương thức implements mà nên được khai báo trong phương thức interface hoặc các lớp phụ được khai báo bởi phương thức interface.\n\nMột interface có thể kế thừa từ nhiều interface khác, nhưng không thể kế thừa từ lớp. Interface không thể chứa trường nào trừ các trường vừa static và final. Tất cả các phương thức của interface đều là abstract. Interface không chứa bất cứ hàm contructor nào và không thể được khởi tạo.\n\nMặc dù vậy, interface khác với class ở một số điểm sau:\n\n- Interface xuất hiện trong package, những bytecode file tương ứng phải ở trong cấu trúc thư mục có cùng tên package.\n- Bytecode của interface xuất hiện trong một class file.\n- Interface được viết trong một file với định dạng java với tên của interface cùng với tên của file.\n- Một interface có thể bao gồm bất cứ lượng phương thức nào.\n\nMột interface tương tự với một class ở những điểm sau:\n\n- Trừ khi một lớp triển khai interface là lớp trừu tượng abstract, còn lại tất cả các phương thức của interface cần được định nghĩa trong class.\n- Interface không phải là một lớp. Viết một interface giống như viết một lớp nhưng chúng có 2 định nghĩa khác nhau. Một lớp mô tả các thuộc tính và hành vi của một đối tượng, một interface chứa các hành vi mà một class triển khai.\n\nMột interface trong Java là một tập hợp các phương thức trừu tượng. Một class triển khai một interface đó kế thừa các phương thức abstract của interface. Nói cách khác, các trường của interface là public static và final theo mặc định, các phương thức là public và abstract. Java compiler thêm từ khóa public và abstract trước phương thức của interface, các từ khóa public static và final trước các thành viên dữ liệu.\n\nMột interface trong Java là một bản thiết kế của một lớp, chỉ có các phương thức trừu tượng. Interface là một kỹ thuật để thu được tính trừu tượng hoàn toàn và đa kế thừa trong Java. Interface trong Java cũng biểu diễn mối quan hệ isa, nhưng không thể được khởi tạo giống như lớp trừu tượng.interface printable{ void print(); } class A6 implements printable{ public\nvoid print(){System.out.println(\"Hello\");} public static void main(String\nargs[]){ A6 obj = new A6(); obj.print(); } }\n\n, interface Printable{ void print(); } interface Showable{ void show(); } class\nA7 implements Printable,Showable{ public void\nprint(){System.out.println(\"Hello\");} public void\nshow(){System.out.println(\"Welcome\");} public static void main(String args[]){\nA7 obj = new A7(); obj.print(); obj.show(); } }\n\n, interface Printable{ void print(); } interface Showable{ void print(); } class\nTestTnterface1 implements Printable,Showable{ public void\nprint(){System.out.println(\"Hello\");} public static void main(String args[]){\nTestTnterface1 obj = new TestTnterface1(); obj.print(); } }\n\n, interface Printable{ void print(); } interface Showable extends Printable{\nvoid show(); } class Testinterface2 implements Showable{ public void\nprint(){System.out.println(\"Hello\");} public void\nshow(){System.out.println(\"Welcome\");} public static void main(String args[]){\nTestinterface2 obj = new Testinterface2(); obj.print(); obj.show(); } }\n\n, //Cach Serializable interface duoc viet? public interface Serializable{ }\n\n, interface printable{ void print(); interface MessagePrintable{ void msg(); } }\n\n"
    }
  },
  {
    "id": "203",
    "name": "Lớp abstract vs Interface",
    "href": "https://www.vietjack.com/java/lop_abstract_va_interface_trong_java.jsp",
    "lesson": {
      "title": "Phân biệt lớp abstract và Interface trong Java",
      "content": "Trong một buổi phỏng vấn, bạn có thể được hỏi về sự khác biệt giữa lớp trừu tượng (abstract class) và giao diện (interface). Bạn cần lưu ý rằng các phương thức của giao diện là trừu tượng 100%, trong khi trong lớp trừu tượng có thể có các phương thức không phải trừu tượng. Trong thiết kế phần mềm, giao diện thường được dùng để chỉ hai hoặc nhiều lớp cùng làm việc gì đó, ví dụ cùng thực hiện phương thức `printable`, trong khi lớp trừu tượng thường hướng đến quan hệ cha con trong lập trình hướng đối tượng. Bạn có thể đọc thêm tài liệu để hiểu rõ hơn về sự khác biệt giữa hai khái niệm này.\n\nChạy chương trình trên sẽ cho kết quả: \"Về cơ bản, lớp trừu tượng đạt được trừu tượng hóa một phần từ 0 tới 100, trong khi đó giao diện có thể đạt được trừu tượng hóa hoàn toàn 100%\". Cả lớp trừu tượng và giao diện được sử dụng để thu được tính trừu tượng, từ đó chúng ta có thể khai báo các phương thức trừu tượng. Cả lớp trừu tượng và giao diện không thể được khởi tạo. Tuy nhiên, cũng có các điểm khác nhau giữa lớp trừu tượng và giao diện như sau:\n\n- Lớp trừu tượng có thể có các phương thức trừu tượng và không trừu tượng, trong khi giao diện chỉ có thể có các phương thức trừu tượng.\n- Lớp trừu tượng có thể có các thuộc tính, trong khi giao diện không thể có các thuộc tính.\n- Lớp trừu tượng có thể được kế thừa bởi các lớp khác, trong khi giao diện không thể được kế thừa.\n- Lớp trừu tượng có thể được khởi tạo, trong khi giao diện không thể được khởi tạo.STT | Lớp trừu tượng | Interface\n---|--- | ---\n1 | Có thể có cả phương thức trừu tượng và phương thức không trừu tượng | Chỉ có thể có phương thức trừu tượng\n2 | Không hỗ trợ đa kế thừa | Hỗ trợ đa kế thừa\n3 | Có thể có các biến final, non-final, static và non-static | Chỉ có các biến static và final\n4 | Có thể có phương thức static, phương thức main và constructor | Không thể có phương thức static, main hoặc constructor\n5 | Sử dụng từ khóa abstract để khai báo | Sử dụng từ khóa interface để khai báo\n6 | Có thể cung cấp trình triển khai của Interface | Không cung cấp trình triển khai cụ thể của lớp abstract\n7 | Ví dụ:\npublic abstract class Shape{\npublic abstract void draw();\n} | Ví dụ:\npublic interface Drawable{\nvoid draw();\n}//Tao interface ma co 4 phuong thuc interface A{ void a();//theo mac dinh,\npublic va abstract void b(); void c(); void d(); } //Tao lop abstract ma cung\ncap trinh trien khai cua mot phuong thuc cua A interface abstract class B\nimplements A{ public void c(){System.out.println(\"Toi la C\");} } //Tao lop con\ncua lop abstract, bay gio chung ta can cung cap trinh trien khai cho cac\nphuong thuc con lai class M extends B{ public void a(){System.out.println(\"Toi\nla a\");} public void b(){System.out.println(\"Toi la b\");} public void\nd(){System.out.println(\"Toi la d\");} } //Tao mot lop Test ma goi cac phuong\nthuc cua A interface class Test5{ public static void main(String args[]){ A\na=new M(); a.a(); a.b(); a.c(); a.d(); }}\n\n, Toi la a Toi la b Toi la c Toi la d\n\n"
    }
  },
  {
    "id": "213",
    "name": "Java Package",
    "href": "https://www.vietjack.com/java/package_trong_java.jsp",
    "lesson": {
      "title": "Package trong Java",
      "content": "Trong Unix, sử dụng \"export CLASSPATH\" để thiết lập biến classpath và \"unset CLASSPATH\" để xóa các nội dung hiện tại. Trong Windows, sử dụng \"set CLASSPATH\" để thiết lập hoặc xóa classpath. Sử dụng \"echo $CLASSPATH\" trong Unix hoặc \"echo %CLASSPATH%\" trong Windows để hiển thị classpath hiện tại.\n\nĐể đặt hai lớp public trong một package, bạn có thể sử dụng hai tệp nguồn Java chứa một lớp public nhưng giữ tên package giống nhau. Tuy nhiên, chỉ có một lớp public trong một tệp nguồn Java và nó phải được lưu trữ bằng tên lớp public.\n\nBạn có thể đặt class file hoặc jar file trong classpath bằng cách thiết lập classpath trong biến môi trường hoặc tạo jar file chứa tất cả các class file và sao chép jar file vào thư mục jrelibext.\n\nĐể chạy chương trình từ thư mục esource, bạn có thể sử dụng class switch của Java, chẳng hạn như \"java -classpath c:\\classes mypack.simple\".\n\nĐể biên dịch chương trình, bạn có thể sử dụng \"javac c:\\classes\\simple.java\".\n\nMột package con là một package nằm bên trong một package khác. Các package được sử dụng để phân loại các lớp và giao diện để dễ quản lý hơn.\n\nĐể import một package, bạn có thể sử dụng từ khóa \"import\". Khi bạn import một package, tất cả các lớp và giao diện của package đó sẽ được import, ngoại trừ các lớp và giao diện của package con.\n\nBạn có thể sử dụng tên đầy đủ của một lớp để truy cập lớp đó mà không cần import package của lớp đó.\n\nTừ khóa \"package\" được sử dụng để tạo một package trong Java. Lệnh \"package\" nên được đặt ở dòng đầu tiên của tệp nguồn Java và chỉ có thể được khai báo một lần trong một tệp nguồn.\n\nCác package trong Java có thể được phân loại thành các package được xây dựng sẵn và các package do người dùng định nghĩa. Có nhiều package được xây dựng sẵn như java.lang, awt, javax.swing, net, io, util, sql./* Ten File : Animal.java */ package animals; interface Animal { public void\neat(); public void travel(); }\n\n, //Luu duoi dang Simple.java package mypack; public class Simple{ public static\nvoid main(String args[]){ System.out.println(\"Chao mung ban den voi package\ntrong Java\"); } }\n\n, javac -d thu_muc ten_javafile\n\n, javac -d . Simple.java\n\n, package payroll; public class Boss { public void payEmployee(Employee e) {\ne.mailCheck(); } }\n\n, payroll.Employee\n\n, import payroll.*;\n\n, import payroll.Employee;\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B{ public static\nvoid main(String args[]){ A obj = new A(); obj.msg(); } }\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.A; class B{ public static\nvoid main(String args[]){ A obj = new A(); obj.msg(); } }\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; class B{ public static void main(String\nargs[]){ pack.A obj = new pack.A();//Su dung ten day du obj.msg(); } }\n\n, package com.vietjack.core; class Simple{ public static void main(String\nargs[]){ System.out.println(\"Hello subpackage\"); } }\n\n, //Luu duoi dang Simple.java package mypack; public class Simple{ public static\nvoid main(String args[]){ System.out.println(\"Chao mung den voi package\"); } }\n\n, //Luu duoi dang C.java neu khong se gay ra Compilte Time Error class A{} class\nB{} public class C{}\n\n, //Luu duoi dang A.java package vietjack; public class A{}\n\n, //Luu duoi dang B.java package vietjack; public class B{}\n\n"
    }
  },
  {
    "id": "223",
    "name": "Các kiểu Modifier",
    "href": "https://www.vietjack.com/java/cac_kieu_modifier_trong_java.jsp",
    "lesson": {
      "title": "Các kiểu Modifier trong Java",
      "content": "Chương tiếp theo sẽ thảo luận về các toán tử cơ bản trong ngôn ngữ Java. Nó sẽ cung cấp cho bạn cái nhìn tổng quan về cách các toán tử có thể được sử dụng trong khi phát triển ứng dụng. Chương này cũng sẽ bao gồm các thông tin về các từ khóa synchronized và volatile được sử dụng cho các thread, từ khóa abstract để tạo các lớp và phương thức trừu tượng, từ khóa final để kết thúc sự thi hành của các lớp, phương thức và biến, từ khóa static để tạo các phương thức lớp và biến. Java cũng cung cấp một số từ khóa nonaccess để thực hiện các tính năng khác. Từ khóa protected được sử dụng để hạn chế truy cập từ bên ngoài, từ khóa public cho phép truy cập tự do từ bên ngoài, từ khóa private cho phép truy cập trong nội bộ lớp, từ khóa default cho phép truy cập trong nội bộ package. Java cung cấp một số từ khóa access để thiết lập chỉ định truy cập cho các lớp, biến, phương thức và constructor. Có 4 mức độ truy cập: public, protected, private và default. Để sử dụng một từ khóa, bạn bao gồm từ khóa đó trong định nghĩa của một lớp, phương thức hoặc biến. Từ khóa đặt trước phần còn lại của lệnh như trong ví dụ sau:\n```java\n// Nonaccess modifier trong Java\npublic class MyClass {\n    private int x;\n    protected int y;\n    int z; // Default access\n}\n\n// Access modifier trong Java\nclass MyClass {\n    public int x;\n    protected int y;\n    private int z;\n}\n```public class tenClass { // ... } private boolean myFlag; static final double\nweeks = 9.5; protected static final int BOXWIDTH = 42; public static void\nmain(String[] arguments) { // Phan than phuong thuc }\n\n"
    }
  },
  {
    "id": "233",
    "name": "Non-Access Modifier",
    "href": "https://www.vietjack.com/java/nonaccess_modifier_trong_java.jsp",
    "lesson": {
      "title": "Non Access Modifier trong Java",
      "content": "- run() thường được gọi trong một thread mà bạn bắt đầu sử dụng runnable và stop() được gọi từ một thread khác.\n- Trong dòng 1, nếu giá trị được lưu trữ được sử dụng trong vòng lặp, vòng lặp có thể không dừng lại khi bạn đặt giá trị đó thành false ở dòng 2. Đó là lúc bạn muốn sử dụng volatile.\n- Truy cập một biến volatile đồng bộ hóa tất cả các bản sao của biến đó trong bộ nhớ chính.\n- volatile chỉ có thể được áp dụng cho các biến instance là kiểu đối tượng hoặc private.\n- Một tham chiếu đối tượng volatile có thể là null.\n- volatile được sử dụng để chỉ cho JVM biết rằng một thread đang truy cập biến đó phải luôn hợp nhất bản sao biến private của riêng nó với bản sao master trong bộ nhớ.\n- Trình sửa đổi này được bao gồm trong lệnh tạo biến đó và đứng trước lớp hoặc kiểu dữ liệu của biến đó.\n- Một biến instance được đánh dấu là transient để chỉ rằng JVM bỏ qua biến cụ thể khi tuần tự hóa đối tượng đang chứa nó.\n- Từ khóa synchronized được sử dụng để chỉ rằng một phương thức chỉ có thể được truy cập bởi một thread tại một thời điểm.\n- Trình sửa đổi synchronized có thể được áp dụng với bất kỳ một trong bốn mức độ truy cập nào.\n- Một phương thức trừu tượng kết thúc bằng dấu chấm phảy. Ví dụ: public abstract sample.\n- Nếu một lớp chứa một hoặc nhiều phương thức trừu tượng, thì lớp đó phải được khai báo là abstract.\n- Một lớp trừu tượng không cần chứa các phương thức trừu tượng.\n- Bất kỳ lớp nào kế thừa một lớp trừu tượng phải triển khai tất cả các phương thức trừu tượng của lớp cha, trừ khi lớp con này cũng là một lớp trừu tượng.\n- Một phương thức trừu tượng là một phương thức được khai báo mà không có bất kỳ triển khai nào. Thân phương thức này được cung cấp bởi lớp con.\n- Các phương thức trừu tượng không bao giờ có thể là final.\n- Một lớp trừu tượng có thể chứa cả các phương thức trừu tượng cũng như các phương thức thông thường.\n- Một lớp không thể vừa trừu tượng và vừa là final.\n- Một lớp final không thể được kế thừa.\n- Nếu một lớp chứa các phương thức trừu tượng, thì lớp đó nên được khai báo là abstract. Nếu không, nó sẽ gây ra lỗi biên dịch.\n- Một lớp trừu tượng không bao giờ có thể được khởi tạo.\n- Nếu một lớp được khai báo là abstract, thì mục đích duy nhất cho lớp này là để được kế thừa.\n- Mục đích chính của việc sử dụng một lớp được khai báo final là để ngăn cản lớp bị phân lớp thành lớp con.\n- Nếu một lớp được đánh dấu là final, thì không có lớp nào có thể kế thừa bất kỳ đặc điểm nào từ lớp final đó.\n- Bạn khai báo các phương thức sử dụng trình sửa đổi final trong khai báo lớp như trong ví dụ sau.\n- Mục đích chính của việc tạo phương thức final là nội dung của phương thức không nên bị thay đổi bởi bên ngoài.\n- Một phương thức final không thể bị ghi đè (override) bởi bất kỳ lớp con nào.\n- Như đã đề cập trước đó, trình sửa đổi final ngăn cản một phương thức bị sửa đổi trong một lớp con.\n- Với các biến, trình sửa đổi final thường được sử dụng với static để tạo hằng số cho một biến lớp.\n- Tuy nhiên, dữ liệu bên trong đối tượng có thể bị thay đổi, vì thế trạng thái của đối tượng có thể thay đổi nhưng không phải là tham chiếu.\n- Một biến final có thể được khởi tạo một cách rõ ràng chỉ một lần.\n- Một biến tham chiếu được khai báo final không bao giờ có thể được gán lại để tham chiếu tới một đối tượng khác.\n- Trình sửa đổi static trong Java được sử dụng để tạo các phương thức lớp và biến lớp như trong ví dụ sau.\n- Các biến lớp và phương thức lớp có thể được truy cập bằng cách sử dụng tên lớp được theo sau bởi một dấu chấm và tên biến hoặc phương thức.\n- Các phương thức static không sử dụng bất kỳ biến instance nào của bất cứ đối tượng nào trong lớp mà chúng được định nghĩa.\n- Các phương thức static nhận tất cả dữ liệu từ các tham số và tính toán mọi thứ từ các tham số của chúng mà không tham chiếu tới các biến.\n- Từ khóa static được sử dụng để tạo các phương thức mà sẽ tồn tại một cách độc lập trong bất kỳ instance được tạo cho lớp đó.\n- Các biến static cũng được biết đến như là các biến lớp.\n- Các biến local không thể được khai báo là static.\n- Từ khóa static được sử dụng để tạo các biến mà sẽ tồn tại một cách độc lập trong bất kỳ instance được tạo cho lớp đó.\n- Chỉ có một bản sao biến static tồn tại cho dù có nhiều instance của lớp đi chăng nữa.\n- Trình sửa đổi synchronized và trình sửa đổi volatile được sử dụng cho các thread.\n- Trình sửa đổi abstract để tạo các lớp và các phương thức trừu tượng.\n- Trình sửa đổi final để kết thúc sự thi hành của các lớp, các phương thức và các biến.\n- Trình sửa đổi static để tạo các phương thức lớp và các biến.\n- Java cũng cung cấp một số trình sửa đổi nonaccess để thực hiện các tính năng khác.public class InstanceCounter { private static int numInstances = 0; protected\nstatic int getCount() { return numInstances; } private static void\naddInstance() { numInstances++; } InstanceCounter() {\nInstanceCounter.addInstance(); } public static void main(String[] arguments) {\nSystem.out.println(\"Bat dau voi \" + InstanceCounter.getCount() + \"\ninstances\"); for (int i = 0; i < 500; ++i){ new InstanceCounter(); }\nSystem.out.println(\"Duoc tao voi \" + InstanceCounter.getCount() + \"\ninstances\"); } }\n\n, Bat dau voi 0 instances Duoc tao voi 500 instances\n\n, public class Test{ final int value = 10; // Sau day la cac vi du ve khai bao\nconstant: public static final int BOXWIDTH = 6; static final String TITLE =\n\"Manager\"; public void changeValue(){ value = 12; //se cho mot error } }\n\n, public class Test{ public final void changeName(){ // Phan than phuong thuc }\n}\n\n, public final class Test { // Phan than Class }\n\n, abstract class Caravan{ private double price; private String model; private\nString year; public abstract void goFast(); //mot phuong thuc abstract public\nabstract void changeColor(); }\n\n, public abstract class SuperClass{ abstract void m(); //phuong thuc abstract }\nclass SubClass extends SuperClass{ // trien khai phuong thuc abstract void\nm(){ ......... } }\n\n, public synchronized void showDetails(){ ....... }\n\n, public transient int limit = 55; //JVM bo qua bien khi xep thu tu doi tuong\ndang chua no public int b; //day la truong hop thong thuong\n\n, public class MyRunnable implements Runnable { private volatile boolean active;\npublic void run() { active = true; while (active) // dong 1 { // o day la code\n} } public void stop() { active = false; // dong 2 } }\n\n"
    }
  },
  {
    "id": "243",
    "name": "Access Modifier",
    "href": "https://www.vietjack.com/java/access_modifier_trong_java.jsp",
    "lesson": {
      "title": "Access Modifier trong Java",
      "content": "* Các phương thức được khai báo `private` không được kế thừa.\n* Các phương thức được khai báo mà không có điều khiển truy cập (không sử dụng bất kỳ modifier nào) có thể được khai báo là `private` trong các lớp phụ.\n* Các phương thức được khai báo là `protected` trong một lớp cha phải là `protected` hoặc `public` trong các lớp phụ (không thể là `private`).\n* Các phương thức được khai báo là `public` trong một lớp cha cũng phải là `public` trong tất cả các lớp phụ.\n* Default modifier hạn chế hơn `protected`, vì vậy không thể ghi đè phương thức `protected` bằng phương thức `default`.\n* Public access modifier có thể truy cập ở bất kỳ đâu.\n* Protected access modifier có thể truy cập bên trong package và bên ngoài package nhưng chỉ thông qua tính kế thừa.\n* Default access modifier chỉ có thể truy cập bên trong package.\n* Private access modifier chỉ có thể truy cập trong chính lớp được khai báo.**Access Modifier**\n\n| **Trong lớp** | **Trong package** | **Bên ngoài package chỉ bởi lớp con** | **Bên ngoài package** |\n|---|---|---|---|\n| **private** | Có thể truy cập | Không thể truy cập | Không thể truy cập | Không thể truy cập |\n| **default** | Có thể truy cập | Có thể truy cập | Không thể truy cập | Không thể truy cập |\n| **protected** | Có thể truy cập | Có thể truy cập | Có thể truy cập | Không thể truy cập |\n| **public** | Có thể truy cập | Có thể truy cập | Có thể truy cập | Có thể truy cập |class A{ private int data=40; private void msg(){System.out.println(\"Hello\njava\");} } public class Simple{ public static void main(String args[]){ A\nobj=new A(); System.out.println(obj.data);//Compile Time Error\nobj.msg();//Compile Time Error } }\n\n, class A{ private A(){}//private constructor void\nmsg(){System.out.println(\"Hello java\");} } public class Simple{ public static\nvoid main(String args[]){ A obj=new A();//Compile Time Error } }\n\n, //Luu duoi dang A.java package pack; class A{ void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B{ public static\nvoid main(String args[]){ A obj = new A();//Compile Time Error\nobj.msg();//Compile Time Error } }\n\n, //Luu duoi dang A.java package pack; public class A{ protected void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B extends A{\npublic static void main(String args[]){ B obj = new B(); obj.msg(); } }\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B{ public static\nvoid main(String args[]){ A obj = new A(); obj.msg(); } }\n\n, class A{ protected void msg(){System.out.println(\"Hello java\");} } public\nclass Simple extends A{ void msg(){System.out.println(\"Hello java\");}//Compile\nTime Error public static void main(String args[]){ Simple obj=new Simple();\nobj.msg(); } }\n\n"
    }
  },
  {
    "id": "253",
    "name": "Tính bao đóng",
    "href": "https://www.vietjack.com/java/tinh_bao_dong_trong_java.jsp",
    "lesson": {
      "title": "Tính bao đóng trong Java",
      "content": "chương trình java trên sẽ cho kết quả, để chạy java comimtatest, để biên dịch javac testjava, bạn theo dõi ví dụ sau về tính bao đóng mà chỉ có một trường với phương thức setter và getter của nó, người sử dụng của class không biết cách các class lưu trữ dữ liệu một class có thể thay đổi kiểu dữ liệu của một trường và người dùng class không cần sự thay đổi trong code, một lớp có thể có toàn bộ điều khiển thông qua những gì được lưu giữ trong các trường của nó, tất cả các lớp có thể có chế độ chỉ đọc hoặc chỉ ghi chỉ có hàm getter hoặc setter, bởi cung cấp phương thức setter hoặc getter bạn có thể làm cho lớp là readonly hoặc writeonly nó cung cấp cho bạn sự điều khiển thông qua dữ liệu giả sử bạn muốn thiết lập giá trị của id là lớn hơn 100 thì bạn có thể viết biểu thức logic bên trong phương thức setter, tính bao đóng có thể được mô tả như là một tấm bảo vệ code và tránh code và dữ liệu của bạn bị truy cập một cách ngẫu nhiên bởi các code khác bên ngoài class truy cập dữ liệu và code được điều khiển một cách chặt chẽ bởi một interface, tính bao đóng là kỹ thuật tạo một trường của lớp private và cung cấp khả năng truy cập trường này qua các phương thức pullic nếu một trường được khai báo là private nó không thể được truy cập bởi bên ngoài lớp đó có thể che dấu các trường có lớp này vì lý này tính bao đóng được ám chỉ như việc dấu dữ liệu data hiding, tính bao đóng trong java là một tiến trình đóng gói code và dữ liệu lại với nhau vào trong một đơn vị unit đơn ví dụ như một gói bột giặt là hỗn hợp của các hạt bột giặt khác nhau chúng ta có thể tạo một lớp được bao đóng hoàn toàn trong java bằng việc tạo tất cả thành viên dữ liệu của lớp là private bây giờ chúng ta sử dụng phương thức setter và getter để thiết lập và lấy dữ liệu trong nó lớp java bean là ví dụ về một lớp được bao đóng hoàn toàn//Luu duoi dang Student.java package com.vietjack; public class Student{\nprivate String name; public String getName(){ return name; } public void\nsetName(String name){ this.name=name } }\n\n, //Luu duoi dang Test.java package com.vietjack; class Test{ public static void\nmain(String[] args){ Student s=new Student(); s.setname(\"vietjackteam\");\nSystem.out.println(s.getName()); } }\n\n, output: vietjackteam\n\n"
    }
  },
  {
    "id": "263",
    "name": "Lớp Object",
    "href": "https://www.vietjack.com/java/lop_object_trong_java.jsp",
    "lesson": {
      "title": "Lớp Object trong Java",
      "content": "Lớp Object là lớp mặc định của Java và là lớp đặc biệt mà tất cả các lớp khác trong Java phải kế thừa. Để thuận tiện, người ta thường ẩn đi phần kế thừa này, ví dụ như không cần viết class Student extends Object. Trên thực tế, nó vẫn mặc định extends.\n\nBảng dưới đây liệt kê một số phương thức mà lớp Object cung cấp:\n\nPhương thức\tMô tả\ngetClass()\tTrả về lớp của đối tượng\nhashCode()\tTrả về một số nguyên đại diện cho đối tượng\nequals(Object obj)\tKiểm tra xem đối tượng này có bằng với đối tượng obj hay không\ntoString()\tTrả về một chuỗi biểu diễn đối tượng\nnotify()\tĐánh thức một luồng đang chờ đợi đối tượng này\nnotifyAll()\tĐánh thức tất cả các luồng đang chờ đợi đối tượng này\nwait()\tKhiến luồng hiện tại chờ đợi đối tượng này\n\nLớp Object cung cấp một số hành vi chung cho tất cả các đối tượng, chẳng hạn như đối tượng có thể được so sánh, có thể được mô phỏng, có thể được thông báo.\n\nBạn có thể theo dõi ví dụ sau:\n\nclass Object {\n    public Object getObject() {\n        return new Employee();\n    }\n}\n\nclass Employee {\n\n}\n\nCó phương thức getObject() mà trả về một đối tượng, nhưng nó có thể là bất kỳ kiểu nào như Employee, Student. Chúng ta có thể sử dụng tham chiếu lớp Object để tham chiếu tới đối tượng đó, ví dụ:\n\nObject obj = new Employee();\n\nTheo mặc định, lớp Object là lớp cha của tất cả các lớp trong Java. Nói cách khác, nó là lớp cao nhất của Java. Lớp Object khá hữu ích nếu bạn muốn tham chiếu bất kỳ đối tượng nào có kiểu mà bạn không biết. Chú ý rằng biến tham chiếu của lớp cha có thể tham chiếu tới đối tượng lớp con và được gọi là upcasting.**Phương thức**\n\n**getClass()**\n\nTrả về đối tượng lớp Class của đối tượng này. Lớp Class có thể được sử dụng để lấy metadata của lớp này.\n\n**hashCode()**\n\nTrả về hashcode cho đối tượng này.\n\n**equals(Object obj)**\n\nSo sánh đối tượng đã cho với đối tượng này.\n\n**clone()**\n\nTạo và trả về bản sao (bản mô phỏng) của đối tượng này.\n\n**toString()**\n\nTrả về biểu diễn chuỗi của đối tượng này.\n\n**notify()**\n\nThông báo Thread đơn, đợi trên monitor của đối tượng này.\n\n**notifyAll()**\n\nThông báo tất cả Thread, đợi trên monitor của đối tượng này.\n\n**wait(long timeout)**\n\nLàm cho Thread hiện tại đợi trong khoảng thời gian là số mili giây cụ thể, tới khi Thread khác thông báo (triệu hồi phương thức notify() hoặc notifyAll()).\n\n**wait(long timeout,int nanos)**\n\nLàm cho Thread hiện tại đợi trong khoảng thời gian là số mili giây và nano giây cụ thể, tới khi Thread khác thông báo (triệu hồi phương thức notify() hoặc notifyAll()).\n\n**wait()**\n\nLàm Thread hiện tại đợi, tới khi Thread khác thông báo (invokes notify() or notifyAll() method).\n\n**finalize()**\n\nĐược triệu hồi bởi Garbage Collector trước khi đối tượng bị dọn rác.Object obj=getObject();//Chung ta khong biet doi tuong nao se duoc tra ve tu\nphuong thuc nay\n\n"
    }
  },
  {
    "id": "273",
    "name": "Nhân bản đối tượng",
    "href": "https://www.vietjack.com/java/mo_phong_doi_tuong_trong_java.jsp",
    "lesson": {
      "title": "Nhân bản đối tượng trong Java",
      "content": "Nếu tạo một đối tượng mới bằng từ khóa `new` và gán giá trị của một đối tượng khác cho nó thì quá trình này sẽ tốn nhiều tiến trình xử lý hơn. Để tiết kiệm các tiến trình xử lý phụ, ta nên sử dụng phương thức `clone()`. Như bạn thấy trong ví dụ trên, các biến tham chiếu đều có cùng giá trị vì phương thức `clone()` sao chép các giá trị của một đối tượng sang đối tượng khác, do đó ta không cần viết code tường minh để sao chép giá trị từ đối tượng này sang đối tượng khác.\n\nPhương thức `clone()` được định nghĩa trong lớp `Object`. Cú pháp của phương thức `clone()` như sau:\n\n```java\npublic Object clone() throws CloneNotSupportedException\n```\n\nPhương thức `clone()` tạo một bản sao của một đối tượng. Để thực hiện mục đích này, bạn sử dụng phương thức `clone()`. Giao diện `java.lang.Cloneable` phải được triển khai bởi lớp có đối tượng cần nhân bản mà bạn muốn tạo. Nếu bạn không triển khai giao diện `Cloneable`, phương thức `clone()` sẽ tạo `CloneNotSupportedException`.protected Object clone() throws CloneNotSupportedException\n\n, class Student18 implements Cloneable{ int rollno; String name; Student18(int\nrollno,String name){ this.rollno=rollno; this.name=name; } public Object\nclone()throws CloneNotSupportedException{ return super.clone(); } public\nstatic void main(String args[]){ try{ Student18 s1=new Student18(101,\"hoang\");\nStudent18 s2=(Student18)s1.clone(); System.out.println(s1.rollno+\" \"+s1.name);\nSystem.out.println(s2.rollno+\" \"+s2.name); }catch(CloneNotSupportedException\nc){} } }\n\n, Output:101 hoang 101 hoang\n\n"
    }
  },
  {
    "id": "283",
    "name": "Mảng (Array)",
    "href": "https://www.vietjack.com/java/mang_trong_java.jsp",
    "lesson": {
      "title": "Mảng (Array) trong Java",
      "content": "- Java cung cấp nhiều phương thức để sắp xếp và tìm kiếm mảng.\n- Bạn có thể sử dụng phương thức `arraycopy` để sao chép một mảng sang mảng khác.\n- Một mảng là một đối tượng trong Java.\n- Bạn có thể khai báo, khởi tạo và khởi tạo mảng một chiều và đa chiều trong Java.\n- Bạn có thể truy cập các phần tử mảng bằng cách sử dụng chỉ mục.\n- Bạn có thể lặp qua các phần tử mảng bằng cách sử dụng vòng lặp `for` hoặc vòng lặp `foreach`.\n- Bạn có thể truyền mảng cho phương thức.\n- Bạn có thể trả về một mảng từ phương thức.\n- Mảng trong Java là dựa trên chỉ mục, với phần tử đầu tiên được lưu trữ tại chỉ mục 0.1. Phương thức `binarySearch` thực hiện tìm kiếm nhị phân trong mảng các đối tượng đã cho, trả về chỉ mục của khóa tìm kiếm nếu nó nằm trong mảng, hoặc bằng `-(điểm chèn + 1)` nếu không tìm thấy.\n\n\n2. Phương thức `equals` kiểm tra xem hai mảng `long` đã cho có bằng nhau hay không, trả về `true` nếu cả hai mảng chứa cùng số lượng phần tử và tất cả các cặp phần tử tương ứng của hai mảng đều bằng nhau. Phương thức tương tự có thể được sử dụng cho các kiểu dữ liệu gốc khác (byte, short, int, ...).\n\n\n3. Phương thức `fill` gán một giá trị `int` đã cho cho mỗi phần tử của mảng `int` đã cho. Phương thức tương tự có thể được sử dụng cho các kiểu dữ liệu gốc khác (byte, short, int, ...).\n\n\n4. Phương thức `sort` sắp xếp mảng các đối tượng đã cho theo thứ tự tăng dần, dựa trên thứ tự tự nhiên của các phần tử. Phương thức tương tự có thể được sử dụng cho các kiểu dữ liệu gốc khác (byte, short, int, ...).Kieu_du_lieu[] Bien_tham_chieu_mang; // cach uu tien. hoac Kieu_du_lieu\nBien_tham_chieu_mang[]; // lam viec nhung khong la cach uu tien.\n\n, double[] BK49; // cach uu tien. hoac double BK49[]; // lam viec nhung khong la\ncach uu tien.\n\n, Bien_tham_chieu_mang = new Kieu_du_lieu[Kich_co_mang];\n\n, Kieu_du_lieu[] Bien_tham_chieu_mang = new Kieu_du_lieu[Kich_co_mang];\n\n, Kieu_du_lieu[] Bien_tham_chieu_mang = {giatri0, giatri1, ..., giatriN};\n\n, double[] BK49 = new double[10];\n\n, class Array1{ public static void main(String args[]){ int a[]=new\nint[5];//phan khai bao va khoi tao a[0]=10;//Phan khoi tao a[1]=20; a[2]=70;\na[3]=40; a[4]=50; //in mang for(int i=0;i<a.length;i++)//length la thuoc tinh\ncua mang System.out.println(a[i]); }}\n\n, int a[]={33,3,4,5};//khai bao, khoi tao va khoi tao\n\n, class Testarray1{ public static void main(String args[]){ int\na[]={33,3,4,5};//khai bao, khoi tao va khoi tao //in mang for(int\ni=0;i<a.length;i++)//length la thuoc tinh cua mang System.out.println(a[i]);\n}}\n\n, class Testarray2{ static void min(int arr[]){ int min=arr[0]; for(int\ni=1;i<arr.length;i++) if(min>arr[i]) min=arr[i]; System.out.println(min); }\npublic static void main(String args[]){ int a[]={33,3,4,5}; min(a);//Truyen\nmang toi phuong thuc }}\n\n, public class TestArray3 { public static void main(String[] args) { double[]\nBK49 = {1.9, 2.9, 3.4, 3.5}; // In tat ca cac phan tu mang for (double\nelement: BK49) { System.out.println(element); } } }\n\n, package edu.doannhg.basic; public class ArrayDemo { public static void\nhamDaoNguoc(int[] list) { int[] result = new int[list.length]; // vong lap de\ndao nguoc mang for (int i = 0, j = result.length - 1; i < list.length; i++,\nj--) { result[j] = list[i]; } // vong lap foreach de hien thi cac phan tu\ntrong mang dao nguoc for (int a: result) { System.out.print(a+ \" \"); } }\npublic static void main(String [] args){ int [] arr = {9, 8, 7, 6, 5, 4, 3, 2,\n1}; hamDaoNguoc(arr); } }\n\n, Kieu_du_lieu[][] Bien_tham_chieu_mang; (hoac) Kieu_du_lieu\n[][]Bien_tham_chieu_mang; (hoac) Kieu_du_lieu Bien_tham_chieu_mang[][]; (hoac)\nKieu_du_lieu []Bien_tham_chieu_mang[];\n\n, int[][] arr=new int[3][3];//3 hang va 3 cot\n\n, arr[0][0]=1; arr[0][1]=2; arr[0][2]=3; arr[1][0]=4; arr[1][1]=5; arr[1][2]=6;\narr[2][0]=7; arr[2][1]=8; arr[2][2]=9;\n\n, class Testarray3{ public static void main(String args[]){ //khai bao va khoi\ntao mang 2 chieu int arr[][]={{1,2,3},{2,4,5},{4,4,5}}; //in mang hai chieu\nfor(int i=0;i<3;i++){ for(int j=0;j<3;j++){ System.out.print(arr[i][j]+\" \"); }\nSystem.out.println(); } }}\n\n, class Testarray4{ public static void main(String args[]){ int arr[]={4,4,5};\nClass c=arr.getClass(); String name=c.getName(); System.out.println(name); }}\n\n, public static void arraycopy( Object src, int srcPos,Object dest, int destPos,\nint length )\n\n, class TestArrayCopyDemo { public static void main(String[] args) { char[]\ncopyFrom = { 'd', 'e', 'c', 'a', 'f', 'f', 'e', 'i', 'n', 'a', 't', 'e', 'd'\n}; char[] copyTo = new char[7]; System.arraycopy(copyFrom, 2, copyTo, 0, 7);\nSystem.out.println(new String(copyTo)); } }\n\n, class Testarray5{ public static void main(String args[]){ //tao hai ma tran\nint a[][]={{1,3,4},{3,4,5}}; int b[][]={{1,3,4},{3,4,5}}; //tao ma tran khac\nde luu giu ket qua phep cong hai ma tran int c[][]=new int[2][3]; //cong va in\ntong hai ma tran for(int i=0;i<2;i++){ for(int j=0;j<3;j++){\nc[i][j]=a[i][j]+b[i][j]; System.out.print(c[i][j]+\" \"); }\nSystem.out.println();//new line } }}\n\n"
    }
  },
  {
    "id": "293",
    "name": "Lớp Wrapper",
    "href": "https://www.vietjack.com/java/lop_wrapper_trong_java.jsp",
    "lesson": {
      "title": "Lớp Wrapper trong Java",
      "content": "Lớp wrapper trong Java là một lớp cung cấp cách thức chuyển đổi các kiểu dữ liệu nguyên thủy (primitive) thành các đối tượng và ngược lại. Bắt đầu từ phiên bản Java 5.0, Java đã hỗ trợ tính năng tự động chuyển đổi (autoboxing) và tự động hoàn nguyên (unboxing) giữa các kiểu dữ liệu nguyên thủy và các lớp wrapper của chúng.\n\nCó tổng cộng 8 lớp wrapper trong Java, mỗi lớp tương ứng với một kiểu dữ liệu nguyên thủy. Các lớp wrapper này đều nằm trong gói java.lang. Bảng dưới đây liệt kê danh sách 8 lớp wrapper và các kiểu dữ liệu nguyên thủy tương ứng của chúng:\n\n| Lớp wrapper | Kiểu dữ liệu nguyên thủy |\n|---|---|\n| Boolean | boolean |\n| Byte | byte |\n| Character | char |\n| Short | short |\n| Integer | int |\n| Long | long |\n| Float | float |\n| Double | double |\n\nTính năng tự động chuyển đổi (autoboxing) cho phép chúng ta sử dụng các kiểu dữ liệu nguyên thủy như thể chúng là các đối tượng. Ví dụ, thay vì sử dụng kiểu dữ liệu int, chúng ta có thể sử dụng lớp Integer. Khi trình biên dịch gặp một biểu thức có chứa cả kiểu dữ liệu nguyên thủy và đối tượng, nó sẽ tự động chuyển đổi kiểu dữ liệu nguyên thủy thành đối tượng tương ứng.\n\nTính năng tự động hoàn nguyên (unboxing) cho phép chúng ta sử dụng các đối tượng như thể chúng là các kiểu dữ liệu nguyên thủy. Ví dụ, thay vì sử dụng lớp Integer, chúng ta có thể sử dụng kiểu dữ liệu int. Khi trình biên dịch gặp một biểu thức có chứa cả đối tượng và kiểu dữ liệu nguyên thủy, nó sẽ tự động chuyển đổi đối tượng thành kiểu dữ liệu nguyên thủy tương ứng.\n\nLớp wrapper trong Java cung cấp nhiều phương thức tiện ích để thao tác với các kiểu dữ liệu nguyên thủy. Ví dụ, lớp Integer có phương thức parseInt() để chuyển đổi một chuỗi thành số nguyên, lớp Double có phương thức toString() để chuyển đổi một số thực thành chuỗi, v.v...Lớp Wrapper là một lớp trong Java được sử dụng để đại diện cho các kiểu dữ liệu nguyên thủy. Các lớp Wrapper này cung cấp các phương thức để thao tác với các kiểu dữ liệu nguyên thủy theo cách an toàn và tiện lợi hơn.\n\nCác lớp Wrapper bao gồm:\n\n* `boolean`: Lớp này đại diện cho kiểu dữ liệu `boolean`.\n* `Boolean`: Lớp này là lớp Wrapper cho kiểu dữ liệu `boolean`.\n* `char`: Lớp này đại diện cho kiểu dữ liệu `char`.\n* `Character`: Lớp này là lớp Wrapper cho kiểu dữ liệu `char`.\n* `byte`: Lớp này đại diện cho kiểu dữ liệu `byte`.\n* `Byte`: Lớp này là lớp Wrapper cho kiểu dữ liệu `byte`.\n* `short`: Lớp này đại diện cho kiểu dữ liệu `short`.\n* `Short`: Lớp này là lớp Wrapper cho kiểu dữ liệu `short`.\n* `int`: Lớp này đại diện cho kiểu dữ liệu `int`.\n* `Integer`: Lớp này là lớp Wrapper cho kiểu dữ liệu `int`.\n* `long`: Lớp này đại diện cho kiểu dữ liệu `long`.\n* `Long`: Lớp này là lớp Wrapper cho kiểu dữ liệu `long`.\n* `float`: Lớp này đại diện cho kiểu dữ liệu `float`.\n* `Float`: Lớp này là lớp Wrapper cho kiểu dữ liệu `float`.\n* `double`: Lớp này đại diện cho kiểu dữ liệu `double`.\n* `Double`: Lớp này là lớp Wrapper cho kiểu dữ liệu `double`.public class WrapperExample1{ public static void main(String args[]){ //Chuyen\ndoi int thanh Integer int a=20; Integer i=Integer.valueOf(a);//Chuyen doi int\nthanh Integer Integer j=a;//Day la autoboxing, bay gio compiler se viet la\nInteger.valueOf(a) System.out.println(a+\" \"+i+\" \"+j); }}\n\n, public class WrapperExample2{ public static void main(String args[]){ //Chuyen\ndoi Integer thanh int Integer a=new Integer(3); int i=a.intValue();//Chuyen\ndoi Integer thanh int int j=a;//Day la unboxing, bay gio compiler se viet la\na.intValue() System.out.println(a+\" \"+i+\" \"+j); }}\n\n"
    }
  },
  {
    "id": "303",
    "name": "Gọi bởi giá trị",
    "href": "https://www.vietjack.com/java/goi_boi_gia_tri_trong_java.jsp",
    "lesson": {
      "title": "Gọi bởi giá trị trong Java",
      "content": "Khi chạy chương trình Java, bạn có thể gọi các phương thức theo hai cách: gọi theo tham chiếu hoặc gọi theo giá trị.\n\n* Gọi theo tham chiếu: khi gọi một phương thức theo tham chiếu, bạn đang truyền đối tượng làm đối số. Điều này có nghĩa là bất kỳ thay đổi nào đối với đối tượng trong phương thức được gọi cũng sẽ được phản ánh trong đối tượng trong phương thức gọi.\n* Gọi theo giá trị: khi gọi một phương thức theo giá trị, bạn đang truyền một bản sao của đối tượng làm đối số. Điều này có nghĩa là bất kỳ thay đổi nào đối với đối tượng trong phương thức được gọi sẽ không được phản ánh trong đối tượng trong phương thức gọi.\n\nTrong ví dụ đầu tiên, đối tượng `student` được truyền theo tham chiếu cho phương thức `changeName`. Điều này có nghĩa là khi tên của đối tượng `student` được thay đổi trong phương thức `changeName`, tên của đối tượng `student` trong phương thức `main` cũng sẽ bị thay đổi.\n\nTrong ví dụ thứ hai, đối tượng `student` được truyền theo giá trị cho phương thức `changeName`. Điều này có nghĩa là khi tên của đối tượng `student` được thay đổi trong phương thức `changeName`, tên của đối tượng `student` trong phương thức `main` sẽ không bị thay đổi.\n\nTrong Java, chỉ có gọi theo giá trị. Không có gọi theo tham chiếu. Nếu bạn gọi một phương thức và truyền một giá trị, thì đó là gọi theo giá trị. Bất kỳ thay đổi nào đối với giá trị trong phương thức được gọi sẽ không ảnh hưởng đến giá trị trong phương thức gọi.class Vidu{ int data=50; void change(int data){ data=data+100;//cac thay doi\nse chi o trong bien cuc bo } public static void main(String args[]){ Vidu\nop=new Vidu(); System.out.println(\"Truoc khi thay doi \"+op.data);\nop.change(500); System.out.println(\"Sau khi thay doi \"+op.data); } }\n\n, Output:Truoc khi thay doi 50 Sau khi thay doi 50\n\n, class Vidu2{ int data=50; void change(Vidu2 op){ op.data=op.data+100;//Cac\nthay doi se la trong bien instance } public static void main(String args[]){\nVidu2 op=new Vidu2(); System.out.println(\"Truoc khi thay doi \"+op.data);\nop.change(op);//truyen doi tuong System.out.println(\"Sau khi thay doi\n\"+op.data); } }\n\n, Output:Truoc khi thay doi 50 Sau khi thay doi 150\n\n"
    }
  },
  {
    "id": "313",
    "name": "Từ khóa strictfp",
    "href": "https://www.vietjack.com/java/tu_khoa_strictfp_trong_java.jsp",
    "lesson": {
      "title": "Từ khóa strictfp trong Java",
      "content": "- Strictfp không thể áp dụng cho các phương thức trừu tượng, biến hoặc constructor.\n- Strictfp có thể áp dụng cho các phương thức, lớp và interface.\n- Strictfp đảm bảo rằng bạn sẽ lấy cùng một kết quả trên mọi nền tảng nếu bạn thực hiện các phép toán trong giá trị số thực dấu chấm động.\n- Độ chính xác (precision) có thể khác nhau giữa các nền tảng và đó là lý do tại sao ngôn ngữ lập trình Java cung cấp từ khóa strictfp để bạn có thể nhận được cùng một kết quả trên mọi nền tảng.\n- Với strictfp, bạn sẽ có sự kiểm soát tốt hơn với các phép toán về số thực.strictfp class A{}//strictfp ap dung tren lop\n\n, strictfp interface M{}//strictfp ap dung tren interface\n\n, class A{ strictfp void m(){}//strictfp ap dung tren phuong thuc }\n\n, class B{ strictfp abstract void m();//su to hop khong hop le cua các modifier\n}\n\n, class B{ strictfp int data=10;//modifier strictfp khong duoc cho phep o day }\n\n, class B{ strictfp B(){}//modifier strictfp khong duoc cho phep o day }\n\n"
    }
  },
  {
    "id": "323",
    "name": "Date & Time",
    "href": "https://www.vietjack.com/java/date_time_trong_java.jsp",
    "lesson": {
      "title": "Date và Time trong Java",
      "content": "- Date và Time trong Java:\n  - Lớp Date: biểu diễn ngày tháng và thời gian hiện tại.\n  - Lớp Calendar: cung cấp các phương thức để thao tác với ngày tháng và thời gian.\n  - Lớp SimpleDateFormat: định dạng và parse ngày tháng và thời gian.\n\n\n- Các phương thức hữu ích trong lớp Date:\n  - compareTo(): so sánh hai đối tượng Date.\n  - equals(): kiểm tra xem hai đối tượng Date có bằng nhau không.\n  - getTime(): trả về số mili giây đã trôi qua kể từ nửa đêm ngày 1/1/1970.\n  - toString(): trả về một chuỗi biểu diễn ngày tháng và thời gian hiện tại.\n\n\n- Các phương thức hữu ích trong lớp Calendar:\n  - getInstance(): trả về một đối tượng Calendar được khởi tạo với ngày tháng và thời gian hiện tại.\n  - get(): trả về giá trị của một trường ngày tháng và thời gian cụ thể.\n  - set(): thiết lập giá trị của một trường ngày tháng và thời gian cụ thể.\n  - add(): cộng hoặc trừ một số lượng đơn vị thời gian nhất định vào một trường ngày tháng và thời gian cụ thể.\n\n\n- Các phương thức hữu ích trong lớp SimpleDateFormat:\n  - applyPattern(): thiết lập một mẫu định dạng cho ngày tháng và thời gian.\n  - format(): định dạng một đối tượng Date thành một chuỗi.\n  - parse(): parse một chuỗi thành một đối tượng Date.### Phương thức và Miêu tả\n\n- `boolean after(Date date)`: Kiểm tra xem ngày trong đối tượng `Date` hiện tại có muộn hơn ngày trong đối tượng `date` đã cho hay không. Trả về `true` nếu muộn hơn, nếu không trả về `false`.\n\n- `boolean before(Date date)`: Kiểm tra xem ngày trong đối tượng `Date` hiện tại có sớm hơn ngày trong đối tượng `date` đã cho hay không. Trả về `true` nếu sớm hơn, nếu không trả về `false`.\n\n- `Object clone()` : Tạo một bản sao của đối tượng `Date` hiện tại.\n\n- `int compareTo(Date date)`: So sánh ngày trong đối tượng `Date` hiện tại với ngày trong đối tượng `date` đã cho. Trả về 0 nếu bằng nhau, trả về một giá trị âm nếu sớm hơn và trả về một giá trị dương nếu muộn hơn.\n\n- `int compareTo(Object obj)`: Tương tự như `compareTo(Date date)`, nhưng có thể so sánh với bất kỳ đối tượng nào, nếu đối tượng không phải là kiểu `Date`, sẽ trả về lỗi `ClassCastException`.\n\n- `boolean equals(Object date)`: Kiểm tra xem ngày và thời gian trong đối tượng `Date` hiện tại có bằng với ngày và thời gian trong đối tượng `date` đã cho hay không. Trả về `true` nếu bằng nhau, nếu không trả về `false`.\n\n- `long getTime()` : Trả về số mili giây đã trôi qua kể từ 00:00:00 UTC ngày 1 tháng 1 năm 1970.\n\n- `int hashCode()` : Trả về một mã băm của đối tượng `Date` hiện tại.\n\n- `void setTime(long time)` : Thiết lập ngày và thời gian trong đối tượng `Date` hiện tại thành ngày và thời gian tương ứng với số mili giây đã trôi qua kể từ 00:00:00 UTC ngày 1 tháng 1 năm 1970.\n\n- `String toString()` : Trả về một chuỗi đại diện cho ngày và thời gian trong đối tượng `Date` hiện tại.\n\n### Định dạng ngày và thời gian\n\nBảng sau liệt kê các ký tự định dạng ngày và thời gian có thể sử dụng trong lớp `SimpleDateFormat`:\n\n| Ký tự | Miêu tả | Ví dụ |\n|---|---|---|\n| G | Tên kỷ nguyên | AD |\n| y | Năm (4 chữ số) | 2023 |\n| M | Tháng trong năm (số) | 03 |\n| d | Ngày trong tháng (số) | 08 |\n| h | Giờ trong ngày (1-12) | 09 |\n| H | Giờ trong ngày (0-23) | 21 |\n| m | Phút trong giờ (số) | 30 |\n| s | Giây trong phút (số) | 00 |\n| S | Mili giây trong giây (số) | 000 |\n| E | Ngày trong tuần | Wed |\n| D | Ngày trong năm | 067 |\n| F | Ngày trong tuần trong tháng | 2 (Thứ tư thứ hai trong tháng) |\n| w | Tuần trong năm | 10 |\n| W | Tuần trong tháng | 1 |\n| a | Sáng/Chiều | AM |\n| k | Giờ trong ngày (1-24) | 24 |\n| K | Giờ trong ngày (0-11) | 11 |\n| z | Múi giờ | PST |\n| ' | Ký tự thoát | `'d'` |\n| \" | Trích dẫn đơn | `'d\"'` |\n\n### Constructor và miêu tả\n\n- `GregorianCalendar()` : Tạo một đối tượng `GregorianCalendar` mặc định, sử dụng ngày giờ hiện tại, múi giờ mặc định và ngôn ngữ mặc định.\n\n- `GregorianCalendar(int year, int month, int date)` : Tạo một đối tượng `GregorianCalendar` với ngày, tháng và năm đã cho, sử dụng múi giờ mặc định và ngôn ngữ mặc định.\n\n- `GregorianCalendar(int year, int month, int date, int hour, int minute)` : Tạo một đối tượng `GregorianCalendar` với ngày, tháng, năm, giờ và phút đã cho, sử dụng múi giờ mặc định và ngôn ngữ mặc định.\n\n- `GregorianCalendar(int year, int month, int date, int hour, int minute, int second)` : Tạo một đối tượng `GregorianCalendar` với ngày, tháng, năm, giờ, phút và giây đã cho, sử dụng múi giờ mặc định và ngôn ngữ mặc định.\n\n- `GregorianCalendar(Locale aLocale)` : Tạo một đối tượng `GregorianCalendar` sử dụng ngày giờ hiện tại, múi giờ mặc định và ngôn ngữ đã cho.\n\n- `GregorianCalendar(TimeZone zone)` : Tạo một đối tượng `GregorianCalendar` sử dụng ngày giờ hiện tại, múi giờ đã cho và ngôn ngữ mặc định.\n\n- `GregorianCalendar(TimeZone zone, Locale aLocale)` : Tạo một đối tượng `GregorianCalendar` sử dụng ngày giờ hiện tại, múi giờ đã cho và ngôn ngữ đã cho.\n\n### Phương thức và miêu tả\n\n- `void add(int field, int amount)` : Cộng hoặc trừ một số lượng đơn vị thời gian nhất định vào một trường thời gian đã cho.\n\n- `protected void computeFields()` : Chuyển đổi thời gian UTC dạng mili giây thành các giá trị trường thời gian.\n\n- `protected void computeTime()` : Chuyển đổi các giá trị trường thời gian thành thời gian UTC dạng mili giây.\n\n- `boolean equals(Object obj)` : So sánh đối tượng `GregorianCalendar` hiện tại với một đối tượng khác.\n\n- `int get(int field)` : Trả về giá trị của một trường thời gian đã cho.\n\n- `int getActualMaximum(int field)` : Trả về giá trị lớn nhất mà một trường thời gian có thể có, với ngày hiện tại.\n\n- `int getActualMinimum(int field)` : Trả về giá trị nhỏ nhất mà một trường thời gian có thể có, với ngày hiện tại.\n\n- `int getGreatestMinimum(int field)` : Trả về giá trị tối thiểu lớn nhất của một trường thời gian, nếu trường đó thay đổi.\n\n- `Date getGregorianChange()` : Trả về ngày chuyển đổi sang lịch Gregorian.\n\n- `int getLeastMaximum(int field)` : Trả về giá trị tối đa nhỏ nhất của một trường thời gian, nếu trường đó thay đổi.\n\n- `int getMaximum(int field)` : Trả về giá trị tối đa của một trường thời gian.\n\n- `Date getTime()` : Trả về ngày giờ hiện tại của đối tượng `GregorianCalendar`.\n\n- `long getTimeInMillis()` : Trả về ngày giờ hiện tại của đối tượng `GregorianCalendar` dưới dạng số mili giây.\n\n- `TimeZone getTimeZone()` : Trả về múi giờ của đối tượng `GregorianCalendar`.\n\n- `int getMinimum(int field)` : Trả về giá trị tối thiểu của một trường thời gian.\n\n- `int hashCode()` : Trả về mã băm của đối tượng `GregorianCalendar`.\n\n- `boolean isLeapYear(int year)` : Kiểm tra xem một năm có phải là năm nhuận hay không.\n\n- `void roll(int field, boolean up)` : Cộng hoặc trừ một đơn vị thời gian của một trường thời gian đã cho, mà không thay đổi các trường lớn hơn.\n\n- `void set(int field, int value)` : Thiết lập giá trị của một trường thời gian.\n\n- `void set(int year, int month, int date)` : Thiết lập giá trị của các trường năm, tháng và ngày.\n\n- `void set(int year, int month, int date, int hour, int minute)` : Thiết lập giá trị của các trường năm, tháng, ngày, giờ và phút.\n\n- `void set(int year, int month, int date, int hour, int minute, int second)` : Thiết lập giá trị của các trường năm, tháng, ngày, giờ, phút và giây.\n\n- `void setGregorianChange(Date date)` : Thiết lập ngày chuyển đổi sang lịch Gregorian.\n\n- `void setTime(Date date)` : Thiết lập ngày giờ hiện tại của đối tượng `GregorianCalendar` thành ngày giờ của đối tượng `Date` đã cho.\n\n- `void setTimeInMillis(long millis)` : Thiết lập ngày giờ hiện tại của đối tượng `GregorianCalendar` thành ngày giờ tương ứng với số mili giây đã cho.\n\n- `void setTimeZone(TimeZone value)` : Thiết lập múi giờ của đối tượng `GregorianCalendar`.\n\n- `String toString()` : Trả về một chuỗi đại diện cho ngày giờ hiện tại của đối tượng `GregorianCalendar`.Date( )\n\n, Date(long millisec)\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // hien thi\ndate va time boi su dung toString() System.out.println(date.toString()); } }\n\n, Mon May 04 09:51:52 CDT 2009\n\n, import java.util.*; import java.text.*; public class DateDemo { public static\nvoid main(String args[]) { Date dNow = new Date( ); SimpleDateFormat ft = new\nSimpleDateFormat (\"E yyyy.MM.dd 'at' hh:mm:ss a zzz\");\nSystem.out.println(\"Date hien tai: \" + ft.format(dNow)); } }\n\n, Date hien tai: Sun 2004.07.18 at 04:14:09 PM PDT\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // Hien thi\ndate va time boi su dung toString() String str = String.format(\"Date hien\ntai/Time : %tc\", date ); System.out.printf(str); } }\n\n, Date hien tai/Time : Sat Dec 15 16:37:57 MST 2012\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // Hien thi\ndate va time boi su dung toString() System.out.printf(\"%1$s %2$tB %2$td,\n%2$tY\", \"Date la:\", date); } }\n\n, Date la: February 09, 2004\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // Hien thi\ndate da duoc dinh dang System.out.printf(\"%s %tB %<te, %<tY\", \"Date la:\",\ndate); } }\n\n, Date la: February 09, 2004\n\n, import java.util.*; import java.text.*; public class DateDemo { public static\nvoid main(String args[]) { SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-\nMM-dd\"); String input = args.length == 0 ? \"1818-11-11\" : args[0];\nSystem.out.print(input + \" Duoc parse thanh dang \"); Date t; try { t =\nft.parse(input); System.out.println(t); } catch (ParseException e) {\nSystem.out.println(\"Khong the parse duoc boi su dung \" + ft); } } }\n\n, $ java DateDemo 1818-11-11 Duoc parse thanh dang Wed Nov 11 00:00:00 GMT 1818\n$ java DateDemo 2007-12-01 2007-12-01 Duoc parse thanh dang Sat Dec 01\n00:00:00 GMT 2007\n\n, import java.util.*; public class SleepDemo { public static void main(String\nargs[]) { try { System.out.println(new Date( ) + \"\\n\"); Thread.sleep(5*60*10);\nSystem.out.println(new Date( ) + \"\\n\"); } catch (Exception e) {\nSystem.out.println(\"Nhan mot exception!\"); } } }\n\n, Sun May 03 18:04:41 GMT 2009 Sun May 03 18:04:51 GMT 2009\n\n, import java.util.*; public class DiffDemo { public static void main(String\nargs[]) { try { long start = System.currentTimeMillis( );\nSystem.out.println(new Date( ) + \"\\n\"); Thread.sleep(5*60*10);\nSystem.out.println(new Date( ) + \"\\n\"); long end = System.currentTimeMillis(\n); long diff = end - start; System.out.println(\"Khac nhau la : \" + diff); }\ncatch (Exception e) { System.out.println(\"Nhan mot exception!\"); } } }\n\n, Sun May 03 18:16:51 GMT 2009 Sun May 03 18:16:57 GMT 2009 Difference is : 5993\n\n, import java.util.*; public class GregorianCalendarDemo { public static void\nmain(String args[]) { String months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n\"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"}; int year; // Tao mot\nGregorian calendar duoc khoi tao // voi date va time hien tai trong // locale\nva timezone mac dinh. GregorianCalendar gcalendar = new GregorianCalendar();\n// Hien thi thon tin date va time hien tai. System.out.print(\"Date: \");\nSystem.out.print(months[gcalendar.get(Calendar.MONTH)]); System.out.print(\" \"\n+ gcalendar.get(Calendar.DATE) + \" \"); System.out.println(year =\ngcalendar.get(Calendar.YEAR)); System.out.print(\"Time: \");\nSystem.out.print(gcalendar.get(Calendar.HOUR) + \":\");\nSystem.out.print(gcalendar.get(Calendar.MINUTE) + \":\");\nSystem.out.println(gcalendar.get(Calendar.SECOND)); // Kiem tra xem year hien\ntai co phai la leap year khong if(gcalendar.isLeapYear(year)) {\nSystem.out.println(\"Year hien tai la mot leap year\"); } else {\nSystem.out.println(\"Year hien tai khong la mot leap year\"); } } }\n\n, Date: Apr 22 2009 Time: 11:25:27 Year hien tai khong la mot leap year\n\n"
    }
  },
  {
    "id": "333",
    "name": "Regular Expression",
    "href": "https://www.vietjack.com/java/regular_expression_trong_java.jsp",
    "lesson": {
      "title": "Regular Expression trong Java",
      "content": "- Java cung cấp gói `javautilregex` để khớp với các biểu thức chính quy (regular expression).\n- Regular expression là một chuỗi các ký tự đặc biệt cho phép bạn khớp hoặc tìm kiếm chuỗi hoặc tập hợp các chuỗi khác.\n- Regular expression có thể được sử dụng để tìm, chỉnh sửa và thao tác văn bản và dữ liệu.\n- Các regular expression trong Java tương tự như trong ngôn ngữ lập trình Perl và rất dễ học.\n- Lớp `Pattern` là một đối tượng biểu diễn biên dịch của một regular expression.\n- Lớp `Matcher` là một đối tượng cho phép bạn giải thích mẫu và thực hiện các hoạt động khớp với một chuỗi đầu vào.\n- Lớp `PatternSyntaxException` là một ngoại lệ chưa được kiểm tra cho biết lỗi cú pháp trong một mẫu regular expression.\n- Các phương thức `matches()` và `lookingAt()` khớp một chuỗi đầu vào với một mẫu, nhưng `matches()` yêu cầu toàn bộ chuỗi đầu vào phải khớp trong khi `lookingAt()` thì không.\n- Các phương thức `start()` và `end()` trả về chỉ mục bắt đầu và kết thúc của chuỗi con được khớp bởi nhóm đã cho.\n- Các phương thức `groupCount()` và `group()` trả về số lượng nhóm khớp và chuỗi con được khớp bởi nhóm đã cho.\n- Các phương thức `replaceFirst()` và `replaceAll()` thay thế chuỗi con khớp với một mẫu đã cho bằng một chuỗi thay thế.\n- Các phương thức `appendReplacement()` và `appendTail()` cho phép bạn xây dựng một chuỗi kết quả bằng cách nối chuỗi đầu vào với các chuỗi thay thế.\n- Các phương thức `study()` cho phép bạn biên dịch lại mẫu và trả về `boolean` cho biết mẫu có được tìm thấy hay không.\n- Các phương thức `region()` cho phép bạn đặt khu vực tìm kiếm trong chuỗi đầu vào.\n- Bảng dưới đây liệt kê tất cả các cú pháp siêu ký tự cho regular expression có sẵn trong Java.SubexpressionSo khớp\n\n^\nPhần bắt đầu của dòng\n\n\n$\nPhần cuối của dòng\n\n\n.\nBất kỳ ký tự nào ngoại trừ dòng mới\n\n\n[...]\nBất kỳ ký tự nào trong dấu ngoặc vuông\n\n\n[^...]\nBất kỳ ký tự nào không trong dấu ngoặc vuông\n\n\n\\A\nPhần bắt đầu của chuỗi\n\n\n\\z\nPhần cuối của chuỗi\n\n\n\\Z\nPhần cuối của chuỗi\n\n\nre*\n0 hoặc nhiều sự xuất hiện của biểu thức đặt trước\n\n\nre+\n1 hoặc nhiều sự xuất hiện của biểu thức đặt trước\n\n\nre?\n0 hoặc 1 sự xuất hiện của biểu thức đặt trước\n\n\nre{ n}\nChính xác n lần xuất hiện của biểu thức đặt trước\n\n\nre{ n,}\nn lần xuất hiện hoặc nhiều hơn của biểu thức đặt trước\n\n\nre{ n, m}\nÍt nhất n và nhiều nhất m lần xuất hiện của biểu thức đặt trước\n\n\na| b\nHoặc a hoặc b\n\n\n(re)\nNhóm các biểu thức chính quy và ghi nhớ văn bản đã khớp\n\n\n(?: re)\nNhóm các biểu thức chính quy mà không ghi nhớ văn bản đã khớp\n\n\n(?> re)\nSo khớp với mẫu độc lập mà không truy xuất ngược (backtrack)\n\n\n\\w\nCác ký tự từ\n\n\n\\W\nCác ký tự không phải từ\n\n\n\\s\nKhoảng trắng\n\n\n\\S\nCác ký tự không phải khoảng trắng\n\n\n\\d\nChữ số\n\n\n\\D\nKý tự không phải chữ số\n\n\n\\A\nPhần bắt đầu của chuỗi\n\n\n\\Z\nPhần kết thúc của chuỗi. Nếu một dòng mới tồn tại, nó khớp ngay trước dòng mới.\n\n\n\\z\nPhần kết thúc của chuỗi\n\n\n\\G\nĐiểm nơi kết thúc lần khớp cuối cùng\n\n\n\\n\nTham chiếu ngược để bắt nhóm số \"n\"\n\n\n\\b\nCác giới hạn từ bên ngoài dấu ngoặc vuông. Phù hợp với phím lùi (0x08) khi ở trong dấu ngoặc vuông\n\n\n\\B\nCác giới hạn không phải từ\n\n\n\\n, \\t, v.v.\nDòng mới, trả về xe, tab, v.v.\n\n\n\\Q\nThoát (trích dẫn) tất cả các ký tự cho đến \\E\n\n\n\\E\nKết thúc trích dẫn bắt đầu từ \\Q\n\n\nPhương thức và Mô tả\n\n1\npublic int start()\nTrả về chỉ mục bắt đầu của lần khớp trước\n\n\n\n2\npublic int start(int group)\nTrả về chỉ mục bắt đầu của chuỗi con được nắm bắt bởi nhóm đã cho trong hoạt động khớp trước.\n\n\n\n3\npublic int end()\nTrả về bù đắp sau ký tự cuối cùng được khớp\n\n\n\n4\npublic int end(int group)\nTrả về bù đắp sau ký tự cuối cùng của chuỗi con được nắm bắt bởi nhóm đã cho trong hoạt động khớp trước\n\n\nPhương thức và Mô tả\n\n1\npublic boolean lookingAt()\nPhù hợp với chuỗi đầu vào, bắt đầu từ khu vực đó, với mẫu\n\n\n\n2\npublic boolean find()\nTìm chuỗi tiếp theo của chuỗi đầu vào khớp với mẫu\n\n\n\n3\npublic boolean find(int start)\nĐặt lại Matcher này và sau đó cố gắng tìm chuỗi tiếp theo của chuỗi đầu vào khớp với mẫu, bắt đầu từ chỉ mục đã xác định\n\n\n\n4\npublic boolean matches()\nPhù hợp với toàn bộ khu vực với mẫu\n\n\nPhương thức và Mô tả\n\n1\npublic Matcher appendReplacement(StringBuffer sb, String replacement)\nTriển khai một bước phụ thêm-và-thay thế có giới hạn\n\n\n\n2\npublic StringBuffer appendTail(StringBuffer sb)\nTriển khai một bước phụ thêm-và-thay thế không giới hạn\n\n\n\n3\npublic String replaceAll(String replacement)\nThay thế mỗi chuỗi con của chuỗi đầu vào khớp với mẫu bằng chuỗi thay thế đã cho\n\n\n\n4\npublic String replaceFirst(String replacement)\nThay thế chuỗi con đầu tiên của chuỗi đầu vào khớp với mẫu bằng chuỗi thay thế đã cho\n\n\n\n5\npublic static String quoteReplacement(String s)\nTrả về một chuỗi thay thế cho chuỗi đã xác định. Phương pháp này tạo một chuỗi sẽ hoạt động như một sự thay thế theo nghĩa đen trong phương thức appendReplacement của lớp Matcher.\n\n\nPhương thức và Mô tả\n\n1\npublic String getDescription()\nLấy mô tả về lỗi\n\n\n\n2\npublic int getIndex()\nLấy chỉ mục của lỗi\n\n\n\n3\npublic String getPattern()\nLấy mẫu biểu thức chính quy bị lỗi\n\n\n\n4\npublic String getMessage()\nTrả về một chuỗi nhiều dòng chứa mô tả về lỗi cú pháp và chỉ mục của nó, mẫu biểu thức chính quy bị lỗi và chỉ báo có thể nhìn thấy của chỉ mục lỗi trong mẫu đó.import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { public static void main( String args[] ){ // String de duoc\nquet de tim pattern. String line = \"Vietjack xin chao cac ban. Day la vi du ve\nRegex! 1000 0USD\"; String pattern = \"(.*)(\\\\\\d+)(.*)\"; // Tao mot doi tuong\nPattern Pattern r = Pattern.compile(pattern); // Tao doi tuong matcher.\nMatcher m = r.matcher(line); if (m.find( )) { System.out.println(\"Gia tri duoc\ntim thay la: \" + m.group(0) ); System.out.println(\"Gia tri duoc tim thay la: \"\n+ m.group(1) ); System.out.println(\"Gia tri duoc tim thay la: \" + m.group(2)\n); } else { System.out.println(\"Khong co ket noi\"); } } }\n\n, Gia tri duoc tim thay la: Vietjack xin chao cac ban. Day la vi du ve Regex!\n1000 0USD Gia tri duoc tim thay la: Vietjack xin chao cac ban. Day la vi du ve\nRegex! 1000 Gia tri duoc tim thay la: 0\n\n, import java.util.regex.*; class RegexExample5{ public static void main(String\nargs[]){ System.out.println(\"cac metacharacter d....\");//d nghia la ky so\n(digit) System.out.println(Pattern.matches(\"\\\\\\d\", \"abc\"));//false (non-digit)\nSystem.out.println(Pattern.matches(\"\\\\\\d\", \"1\"));//true (digit va xuat hien\nmot lan) System.out.println(Pattern.matches(\"\\\\\\d\", \"4443\"));//false (digit\nnhung xuat hien nhieu hon mot lan) System.out.println(Pattern.matches(\"\\\\\\d\",\n\"323abc\"));//false (digit va char) System.out.println(\"cac metacharacter\nD....\");//D nghia la khong phai ky so (non-digit)\nSystem.out.println(Pattern.matches(\"\\\\\\D\", \"abc\"));//false (non-digit nhung\nxuat hien nhieu hon mot lan) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"1\"));//false (digit) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"4443\"));//false (digit) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"323abc\"));//false (digit va char) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"m\"));//true (non-digit va xuat hien mot lan) System.out.println(\"cac\nmetacharacter D voi quantifier....\");\nSystem.out.println(Pattern.matches(\"\\\\\\D*\", \"mak\"));//true (non-digit va co\nthe xuat hien 0 hoac nhie lan) }}\n\n, cac metacharacter d.... false true false false cac metacharacter D.... false\nfalse false false true cac metacharacter D voi quantifier.... true\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static final String REGEX = \"\\\\\\bplay\\\\\\b\"; private\nstatic final String INPUT = \"play play play football tennis play\"; public\nstatic void main( String args[] ){ Pattern p = Pattern.compile(REGEX); Matcher\nm = p.matcher(INPUT); // Lay mot doi tuong matcher int count = 0;\nwhile(m.find()) { count++; System.out.println(\"So ket noi \"+count);\nSystem.out.println(\"start(): \"+m.start()); System.out.println(\"end():\n\"+m.end()); } } }\n\n, So ket noi 1 start(): 0 end(): 4 So ket noi 2 start(): 5 end(): 9 So ket noi 3\nstart(): 10 end(): 14 So ket noi 4 start(): 31 end(): 35\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static final String REGEX = \"it\"; private static final\nString INPUT = \"itttttttttttttgaphot\"; private static Pattern pattern; private\nstatic Matcher matcher; public static void main( String args[] ){ pattern =\nPattern.compile(REGEX); matcher = pattern.matcher(INPUT);\nSystem.out.println(\"REGEX hien tai la: \"+REGEX); System.out.println(\"INPUT\nhien tai la: \"+INPUT); System.out.println(\"lookingAt():\n\"+matcher.lookingAt()); System.out.println(\"matches(): \"+matcher.matches()); }\n}\n\n, REGEX hien tai la: it INPUT hien tai la: itttttttttttttgaphot lookingAt():\ntrue matches(): false\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static String REGEX = \"HaDong\"; private static String\nINPUT = \"HaDong nam o mien nam. \" + \"HaDong la thanh pho cua BinhDuong.\";\nprivate static String REPLACE = \"BinhDuong\"; public static void main(String[]\nargs) { Pattern p = Pattern.compile(REGEX); // lay mot doi tuong matcher\nMatcher m = p.matcher(INPUT); INPUT = m.replaceAll(REPLACE);\nSystem.out.println(INPUT); } }\n\n, BinhDuong nam o mien nam. BinhDuong la thanh pho cua BinhDuong.\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static String REGEX = \"a*b\"; private static String\nINPUT = \"aabfooaabfooabfoob\"; private static String REPLACE = \"-\"; public\nstatic void main(String[] args) { Pattern p = Pattern.compile(REGEX); // lay\nmot doi tuong matcher Matcher m = p.matcher(INPUT); StringBuffer sb = new\nStringBuffer(); while(m.find()){ m.appendReplacement(sb,REPLACE); }\nm.appendTail(sb); System.out.println(sb.toString()); } }\n\n, -foo-foo-foo- \n\n"
    }
  },
  {
    "id": "14",
    "name": "File và I/O",
    "href": "https://www.vietjack.com/java/file_io_trong_java.jsp",
    "lesson": {
      "title": "File và I/O trong Java",
      "content": "- Để đọc file ảnh phim nên dùng InputStream.\n- Để đọc file văn bản nên dùng FileReader.\n- Để liệt kê các file và thư mục có sẵn trong một thư mục, sử dụng phương thức list của đối tượng File.\n- Để tạo một thư mục, sử dụng phương thức mkdir hoặc mkdirs của đối tượng File.\n- Để ghi dữ liệu vào file, sử dụng lớp FileOutputStream.\n- Để đọc dữ liệu từ file, sử dụng lớp FileInputStream.\n- Để sao chép một file, sử dụng hai lớp FileInputStream và FileOutputStream.\n- Byte stream trong Java được sử dụng để thực hiện input và output của các byte 8 bit.\n- Character stream trong Java được sử dụng để thực hiện input và output cho unicode 16 bit.\n- Các lớp thường dùng nhất liên quan đến character stream là FileReader và FileWriter.\n- Các lớp thường dùng nhất liên quan đến byte stream là FileInputStream và FileOutputStream.1. Phương thức `close()` dùng để đóng luồng đầu ra và giải phóng bất kỳ tài nguyên hệ thống nào liên kết với tệp. Nó có thể ném ngoại lệ `IOException`.\n\n\n2. Phương thức `finalize()` dùng để xóa kết nối đến tệp đó. Nó đảm bảo rằng phương thức `close()` của luồng đầu ra này được gọi khi không còn tham chiếu nào đến luồng này nữa. Nó có thể ném ngoại lệ `IOException`.\n\n\n3. Phương thức `read(int r)` dùng để đọc một byte dữ liệu đã xác định từ luồng đầu vào và trả về dưới dạng số nguyên. Nếu kết thúc tệp, nó sẽ trả về -1.\n\n\n4. Phương thức `read(byte[] r)` dùng để đọc `r` byte từ luồng đầu vào vào một mảng và trả về tổng số byte đã đọc. Nếu kết thúc tệp, nó sẽ trả về -1.\n\n\n5. Phương thức `available()` dùng để cung cấp số byte có thể được đọc từ luồng đầu vào này. Nó trả về một số nguyên.import java.io.*; public class CopyFile { public static void main(String\nargs[]) throws IOException { FileInputStream in = null; FileOutputStream out =\nnull; try { in = new FileInputStream(\"input.txt\"); out = new\nFileOutputStream(\"output.txt\"); int c; while ((c = in.read()) != -1) {\nout.write(c); } }finally { if (in != null) { in.close(); } if (out != null) {\nout.close(); } } } }\n\n, Day la vi du ve sao chep file.\n\n, $javac CopyFile.java $java CopyFile\n\n, import java.io.*; public class CopyFile { public static void main(String\nargs[]) throws IOException { FileReader in = null; FileWriter out = null; try\n{ in = new FileReader(\"input.txt\"); out = new FileWriter(\"output.txt\"); int c;\nwhile ((c = in.read()) != -1) { out.write(c); } }finally { if (in != null) {\nin.close(); } if (out != null) { out.close(); } } } }\n\n, Day la vi du ve sao chep file.\n\n, $javac CopyFile.java $java CopyFile\n\n, import java.io.*; public class ReadConsole { public static void main(String\nargs[]) throws IOException { InputStreamReader cin = null; try { cin = new\nInputStreamReader(System.in); System.out.println(\"Nhap cac ky tu, 'q' de\nthoat.\"); char c; do { c = (char) cin.read(); System.out.print(c); } while(c\n!= 'q'); }finally { if (cin != null) { cin.close(); } } } }\n\n, $javac ReadConsole.java $java ReadConsole Nhap cac ky tu, 'q' de thoat. 1 1 e\ne q q\n\n, InputStream f = new FileInputStream(\"C:/java/hello\");\n\n, File f = new File(\"C:/java/hello\"); InputStream f = new FileInputStream(f);\n\n, OutputStream f = new FileOutputStream(\"C:/java/hello\")\n\n, File f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f);\n\n, import java.io.*; public class fileStreamTest{ public static void main(String\nargs[]){ try{ byte bWrite [] = {11,21,3,40,5}; OutputStream os = new\nFileOutputStream(\"test.txt\"); for(int x=0; x < bWrite.length ; x++){ os.write(\nbWrite[x] ); // writes the bytes } os.close(); InputStream is = new\nFileInputStream(\"test.txt\"); int size = is.available(); for(int i=0; i< size;\ni++){ System.out.print((char)is.read() + \" \"); } is.close();\n}catch(IOException e){ System.out.print(\"Exception\"); } } }\n\n, import java.io.File; public class CreateDir { public static void main(String\nargs[]) { String dirname = \"/tmp/user/java/bin\"; File d = new File(dirname);\n// Bay gio tao thu muc. d.mkdirs(); } }\n\n, import java.io.File; public class ReadDir { public static void main(String[]\nargs) { File file = null; String[] paths; try{ // Tao doi tuong file moi file\n= new File(\"/tmp\"); // mang cac file va thu muc paths = file.list(); // voi\nmoi ten trong path array for(String path:paths) { // in ten file va ten thu\nmuc System.out.println(path); } }catch(Exception e){ // neu co bat cu error\nnao xuat hien e.printStackTrace(); } } }\n\n, test1.txt test2.txt ReadDir.java ReadDir.class\n\n"
    }
  },
  {
    "id": "24",
    "name": "ByteArrayInputStream",
    "href": "https://www.vietjack.com/java/bytearrayinputstream_trong_java.jsp",
    "lesson": {
      "title": "ByteArrayInputStream trong Java",
      "content": "Chương trình này tạo ra một mảng byte, sau đó sử dụng các lớp ByteArrayInputStream và ByteArrayOutputStream để đọc và ghi vào mảng byte đó. Phương thức skip() cho phép bỏ qua một số byte nhất định từ luồng, trong khi phương thức mark() thiết lập vị trí đánh dấu hiện tại trong luồng. Phương thức reset() đặt lại vị trí đánh dấu hiện tại thành vị trí đã đánh dấu trước đó. Phương thức read() đọc một byte duy nhất từ luồng, trong khi phương thức read(byte[] b, int off, int len) đọc một số byte nhất định từ luồng. Phương thức available() trả về số byte có thể đọc được từ luồng. Phương thức close() đóng luồng.\n\nLớp ByteArrayInputStream cho phép sử dụng một mảng byte làm nguồn input stream. Nó có một số constructor để tạo đối tượng ByteArrayInputStream, bao gồm constructor nhận một mảng byte, constructor nhận một mảng byte và một int là vị trí bắt đầu đọc, và constructor nhận một mảng byte, một int là vị trí bắt đầu đọc và một int là số byte để đọc.\n\nLớp ByteArrayOutputStream cho phép sử dụng một mảng byte làm nguồn output stream. Nó có một số constructor để tạo đối tượng ByteArrayOutputStream, bao gồm constructor nhận một int là kích thước ban đầu của mảng byte, constructor nhận một mảng byte và constructor không tham số.1. `public int read()`: Phương thức này đọc byte tiếp theo của dữ liệu từ `InputStream`. Nếu là cuối tệp, nó trả về -1.\n\n2. `public int read(byte[] r, int off, int len)`: Phương thức này đọc `len` byte bắt đầu từ `off` từ `InputStream` vào mảng `r`. Nó trả về tổng số byte đã đọc. Nếu là cuối tệp, nó trả về -1.\n\n3. `public int available()`: Cung cấp số lượng byte có thể được đọc từ luồng đầu vào này. Nó trả về một số nguyên cung cấp số byte có thể đọc được.\n\n4. `public void mark(int read)`: Phương thức này thiết lập vị trí đã đánh dấu hiện tại trong luồng. Tham số cung cấp giới hạn tối đa của các byte có thể được đọc trước khi vị trí đã đánh dấu trở nên vô hiệu.\n\n5. `public long skip(long n)`: Bỏ qua `n` byte từ luồng. Phương thức này trả về số byte thực sự bị bỏ qua.ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] a);\n\n, ByteArrayInputStream bArray = new ByteArrayInputStream(byte []a, int off, int\nlen)\n\n, import java.io.*; public class ByteStreamTest { public static void main(String\nargs[])throws IOException { ByteArrayOutputStream bOutput = new\nByteArrayOutputStream(12); while( bOutput.size()!= 10 ) { // Nhan input tu\nnguoi dung bOutput.write(System.in.read()); } byte b [] =\nbOutput.toByteArray(); System.out.println(\"In noi dung\"); for(int x= 0 ; x <\nb.length; x++) { // in cac ky tu System.out.print((char)b[x] + \" \"); }\nSystem.out.println(\" \"); int c; ByteArrayInputStream bInput = new\nByteArrayInputStream(b); System.out.println(\"Chuyen doi cac ky tu thanh chu\nhoa \" ); for(int y = 0 ; y < 1; y++ ) { while(( c= bInput.read())!= -1) {\nSystem.out.println(Character.toUpperCase((char)c)); } bInput.reset(); } } }\n\n, asdfghjkly In noi dung a s d f g h j k l y Chuyen doi cac ky tu thanh chu hoa\nA S D F G H J K L Y\n\n"
    }
  },
  {
    "id": "34",
    "name": "DataInputStream",
    "href": "https://www.vietjack.com/java/datainputstream_trong_java.jsp",
    "lesson": {
      "title": "DataInputStream trong Java",
      "content": "DataInputStream và DataOutputStream là hai lớp trong Java được sử dụng để đọc và ghi dữ liệu gốc nguyên thủy vào một luồng. DataInputStream có thể được sử dụng để đọc các loại dữ liệu như int, float, double, char, boolean và String. DataOutputStream có thể được sử dụng để ghi các loại dữ liệu tương tự.\n\nTrong ví dụ này, DataInputStream được sử dụng để đọc 5 dòng từ một tệp văn bản tên là \"test.txt\" và chuyển đổi các dòng này thành chữ hoa. Sau đó, các dòng đã chuyển đổi được ghi vào một tệp văn bản khác tên là \"test1.txt\".\n\nĐể đọc một dòng từ tệp, DataInputStream sử dụng phương thức readLine(). Phương thức này đọc các byte liên tiếp từ luồng và chuyển đổi chúng thành các ký tự cho đến khi gặp ký tự ngắt dòng hoặc kết thúc tệp. Ký tự được đọc sau đó được trả về dưới dạng một chuỗi.\n\nĐể đọc một số byte từ luồng, DataInputStream sử dụng phương thức read(). Phương thức này đọc một số byte đã chỉ định từ luồng và lưu chúng vào một mảng byte. Phương thức trả về tổng số byte đã đọc vào trong bộ đệm. Nếu đã đến cuối tệp, phương thức trả về -1.\n\nĐể đọc một số byte có độ dài cụ thể từ luồng, DataInputStream sử dụng phương thức readFully(). Phương thức này đọc len byte dữ liệu từ luồng vào một mảng byte. Phương thức trả về tổng số byte đã đọc vào trong bộ đệm. Nếu đã đến cuối tệp, phương thức trả về -1.\n\nNgoài các phương thức đọc, DataInputStream còn có một số phương thức khác có thể được sử dụng để đọc luồng hoặc thực hiện các hoạt động khác trên luồng.\n\nĐể tạo một đối tượng DataInputStream, bạn có thể sử dụng constructor DataInputStream(InputStream in). Constructor này nhận một đối tượng InputStream làm đối số và tạo một đối tượng DataInputStream mới được kết nối với luồng đó.1. Phương thức `read(byte[] r, int off, int len)` trong `InputStream` đọc `len` byte dữ liệu từ luồng đầu vào vào một mảng byte, bắt đầu tại chỉ mục `off`. Nó trả về tổng số byte đã đọc hoặc `-1` nếu đã đạt đến cuối tệp.\n\n\n2. Phương thức `read(byte [] b)` trong `InputStream` đọc một số byte từ luồng đầu vào và lưu chúng vào mảng byte `b`. Nó trả về tổng số byte đã đọc hoặc `-1` nếu đã đạt đến cuối tệp.\n\n\n3. Các phương thức `readBooolean()`, `readByte()`, `readShort()`, `readInt()` trong `InputStream` đọc các byte từ luồng đầu vào và trả về giá trị gốc tương ứng.\n\n\n4. Phương thức `readLine()` trong `InputStream` đọc dòng văn bản tiếp theo từ luồng đầu vào. Nó đọc các byte liên tiếp và chuyển đổi chúng thành các ký tự cho đến khi gặp ký tự xuống dòng hoặc cuối tệp. Các ký tự được đọc sau đó được trả về dưới dạng một chuỗi `String`.InputStream in = DataInputStream(InputStream in);\n\n, import java.io.*; public class Test{ public static void main(String\nargs[])throws IOException{ DataInputStream d = new DataInputStream(new\nFileInputStream(\"test.txt\")); DataOutputStream out = new DataOutputStream(new\nFileOutputStream(\"test1.txt\")); String count; while((count = d.readLine()) !=\nnull){ String u = count.toUpperCase(); System.out.println(u); out.writeBytes(u\n+ \" ,\"); } d.close(); out.close(); } }\n\n, DAY LA TEST 1 , DAY LA TEST 2 , DAY LA TEST 3 , DAY LA TEST 4 , DAY LA TEST 5\n,\n\n"
    }
  },
  {
    "id": "44",
    "name": "ByteArrayOutputStream",
    "href": "https://www.vietjack.com/java/bytearrayoutputstream_trong_java.jsp",
    "lesson": {
      "title": "ByteArrayOutputStream trong Java",
      "content": "Bytearrayoutputstream là một lớp trong Java dùng để tạo một luồng đầu ra trong bộ nhớ. Khi sử dụng lớp này, dữ liệu được ghi vào luồng sẽ được lưu trữ trong bộ nhớ tạm thời, sau đó có thể được truy xuất hoặc xử lý theo nhu cầu.\n\nLớp Bytearrayoutputstream có một số phương thức chính:\n\n- Ghi toàn bộ nội dung của luồng này vào một luồng đã xác định.\n- Ghi một số byte bắt đầu từ một vị trí nhất định vào luồng.\n- Ghi một mảng byte đã xác định vào luồng.\n- Chuyển đổi nội dung của bộ đệm thành một chuỗi.\n- Tạo một mảng byte mới có kích thước bằng kích thước hiện tại của luồng đầu ra và sao chép nội dung của bộ đệm vào đó.\n- Trả về nội dung hiện tại của luồng đầu ra dưới dạng một mảng byte.\n- Đặt lại số lượng byte hợp lệ trong luồng đầu ra về 0, loại bỏ tất cả dữ liệu đã lưu trữ trước đó.\n\nNgoài ra, lớp Bytearrayoutputstream còn có một số constructor để tạo các đối tượng khác nhau, bao gồm:\n\n- Tạo một bộ đệm có kích thước là int.\n- Tạo một bộ đệm 32 byte.1. `public void reset()`: Đặt lại số byte hợp lệ trong mảng byte trong luồng đầu ra về 0, do đó loại bỏ mọi đầu ra tích lũy trong luồng.\n\n\n2. `public byte[] toByteArray()`: Tạo một mảng byte mới có kích thước bằng kích thước hiện tại của luồng đầu ra và sao chép nội dung của bộ đệm vào đó. Trả về nội dung hiện tại của luồng đầu ra dưới dạng mảng byte.\n\n\n3. `public String toString()`: Chuyển đổi nội dung của bộ đệm thành chuỗi. Chuyển đổi được thực hiện theo mã hóa ký tự mặc định. Trả về chuỗi được chuyển đổi từ nội dung của bộ đệm.\n\n\n4. `public void write(int w)`: Ghi một byte đã xác định vào luồng đầu ra.\n\n\n5. `public void write(byte []b, int of, int len)`: Ghi `len` byte bắt đầu từ `offset off` vào luồng.\n\n\n6. `public void writeTo(OutputStream outSt)`: Ghi toàn bộ nội dung của luồng này vào luồng tham số đã xác định.OutputStream bOut = new ByteArrayOutputStream()\n\n, OutputStream bOut = new ByteArrayOutputStream(int a)\n\n, import java.io.*; public class ByteStreamTest { public static void main(String\nargs[])throws IOException { ByteArrayOutputStream bOutput = new\nByteArrayOutputStream(12); while( bOutput.size()!= 10 ) { // Nhan input tu\nnguoi dung bOutput.write(System.in.read()); } byte b [] =\nbOutput.toByteArray(); System.out.println(\"In noi dung\"); for(int x= 0 ; x <\nb.length; x++) { //In cac ky tu System.out.print((char)b[x] + \" \"); }\nSystem.out.println(\" \"); int c; ByteArrayOutputStream bInput = new\nByteArrayOutputStream(b); System.out.println(\"Chuyen doi cac ky tu thanh chu\nhoa \" ); for(int y = 0 ; y < 1; y++ ) { while(( c= bInput.read())!= -1) {\nSystem.out.println(Character.toUpperCase((char)c)); } bInput.reset(); } } }\n\n, asdfghjkly In noi dung a s d f g h j k l y Chuyen doi cac ky tu thanh chu hoa\nA S D F G H J K L Y\n\n"
    }
  },
  {
    "id": "54",
    "name": "DataOutputStream",
    "href": "https://www.vietjack.com/java/dataoutputstream_trong_java.jsp",
    "lesson": {
      "title": "DataOutputStream trong Java",
      "content": "DataoutputStream là một lớp trong Java cho phép bạn ghi các kiểu dữ liệu gốc vào một nguồn đầu ra. Nó cung cấp các phương thức để ghi các loại dữ liệu khác nhau, chẳng hạn như số nguyên, số thực, chuỗi và mảng byte. Bạn có thể sử dụng lớp này để ghi dữ liệu vào một tệp, một luồng mạng hoặc bất kỳ loại nguồn đầu ra nào khác.\n\nĐể sử dụng DataoutputStream, bạn cần tạo một đối tượng của lớp này. Bạn có thể làm điều này bằng cách gọi hàm tạo của lớp, chẳng hạn như:\n\n```\nDataOutputStream output = new DataOutputStream(new FileOutputStream(\"test.txt\"));\n```\n\nĐối số của hàm tạo là một đối tượng OutputStream, đại diện cho nguồn đầu ra mà bạn muốn ghi dữ liệu. Trong ví dụ trên, chúng tôi đang tạo một đối tượng DataOutputStream để ghi dữ liệu vào tệp \"test.txt\".\n\nSau khi bạn có đối tượng DataoutputStream, bạn có thể sử dụng các phương thức của lớp này để ghi dữ liệu vào nguồn đầu ra. Ví dụ, để ghi một chuỗi vào nguồn đầu ra, bạn có thể sử dụng phương thức writeBytes():\n\n```\noutput.writeBytes(\"Hello, world!\");\n```\n\nPhương thức writeBytes() sẽ ghi chuỗi \"Hello, world!\" vào nguồn đầu ra.\n\nNgoài phương thức writeBytes(), DataoutputStream còn cung cấp các phương thức để ghi các loại dữ liệu khác, chẳng hạn như số nguyên, số thực và mảng byte. Để biết thêm thông tin, vui lòng tham khảo tài liệu của lớp DataOutputStream.\n\nKhi bạn đã ghi xong dữ liệu vào nguồn đầu ra, bạn nên gọi phương thức close() của đối tượng DataoutputStream để đóng luồng dữ liệu và giải phóng các tài nguyên được sử dụng.1. Phương thức `write(byte[], int, int)` dùng để ghi một mảng byte vào luồng đầu ra, bắt đầu từ vị trí `off` và có độ dài `len`.\n\n\n2. Phương thức `write(byte[])` dùng để ghi một mảng byte vào luồng đầu ra và trả về số lượng byte đã được ghi.\n\n\n3. Các phương thức `writeBoolean()`, `writeByte()`, `writeShort()`, `writeInt()` dùng để ghi các kiểu dữ liệu nguyên thủy vào luồng đầu ra dưới dạng byte.\n\n\n4. Phương thức `flush()` dùng để xóa sạch luồng đầu ra, đảm bảo rằng tất cả dữ liệu đã được ghi vào tệp.\n\n\n5. Phương thức `writeBytes(String)` dùng để ghi một chuỗi ký tự vào luồng đầu ra dưới dạng một dãy byte. Mỗi ký tự trong chuỗi được ghi liên tiếp nhau.DataOutputStream out = DataOutputStream(OutputStream out);\n\n, import java.io.*; public class Test{ public static void main(String\nargs[])throws IOException{ DataInputStream d = new DataInputStream(new\nFileInputStream(\"test.txt\")); DataOutputStream out = new DataOutputStream(new\nFileOutputStream(\"test1.txt\")); String count; while((count = d.readLine()) !=\nnull){ String u = count.toUpperCase(); System.out.println(u); out.writeBytes(u\n+ \" ,\"); } d.close(); out.close(); } }\n\n, DAY LA TEST 1 , DAY LA TEST 2 , DAY LA TEST 3 , DAY LA TEST 4 , DAY LA TEST 5\n,\n\n"
    }
  },
  {
    "id": "64",
    "name": "Lớp File",
    "href": "https://www.vietjack.com/java/lop_file_trong_java.jsp",
    "lesson": {
      "title": "Lớp File trong Java",
      "content": "Lớp File trong Java đại diện cho các pathname của các tệp và thư mục theo cách trừu tượng. Lớp này được sử dụng để tạo các tệp và thư mục, để tìm kiếm các tệp, xóa các tệp, v.v.\n\nCó một số constructor khác nhau có thể được sử dụng để tạo một đối tượng File trong Java. Cú pháp sau tạo một đối tượng File mới bằng cách chuyển đổi URI đã cho thành một pathname trừu tượng:\n\n```java\nFile(URI uri)\n```\n\nCú pháp sau tạo một đối tượng File mới từ một chuỗi pathname cha và một chuỗi pathname con:\n\n```java\nFile(String parent, String child)\n```\n\nCú pháp sau tạo một đối tượng File mới bằng cách chuyển đổi chuỗi pathname đã cho thành một pathname trừu tượng:\n\n```java\nFile(String pathname)\n```\n\nCú pháp sau tạo một đối tượng File mới từ một pathname trừu tượng cha và một chuỗi pathname con:\n\n```java\nFile(AbstractPath parent, String child)\n```\n\nKhi bạn có một đối tượng File, có một số phương thức có thể được sử dụng để thao tác các tệp trong Java. Một số phương thức phổ biến nhất bao gồm:\n\n* **exists()**: Kiểm tra xem tệp hoặc thư mục được biểu thị bởi đối tượng File có tồn tại hay không.\n* **isDirectory()**: Kiểm tra xem tệp hoặc thư mục được biểu thị bởi đối tượng File có phải là thư mục hay không.\n* **isFile()**: Kiểm tra xem tệp hoặc thư mục được biểu thị bởi đối tượng File có phải là tệp hay không.\n* **length()**: Trả về độ dài của tệp được biểu thị bởi đối tượng File.\n* **lastModified()**: Trả về thời gian mà tệp được biểu thị bởi đối tượng File được sửa đổi lần cuối.\n* **delete()**: Xóa tệp hoặc thư mục được biểu thị bởi đối tượng File.\n* **renameTo()**: Đổi tên tệp hoặc thư mục được biểu thị bởi đối tượng File.\n* **mkdir()**: Tạo một thư mục mới được biểu thị bởi đối tượng File.\n* **mkdirs()**: Tạo một thư mục mới cùng với bất kỳ thư mục cha nào cần thiết được biểu thị bởi đối tượng File.\n* **list()**: Trả về một mảng các tên tệp của các tệp và thư mục trong thư mục được biểu thị bởi đối tượng File.\n* **listFiles()**: Trả về một mảng các đối tượng File của các tệp và thư mục trong thư mục được biểu thị bởi đối tượng File.\n\nNgoài các phương thức này, còn có một số phương thức khác có thể được sử dụng để thao tác các tệp và thư mục trong Java. Để biết thêm thông tin, hãy tham khảo tài liệu của lớp File trong Java API.**Phương thức và Miêu tả**\n\n1. **getName()**: Trả về tên của file hoặc thư mục được biểu thị bởi pathname trừu tượng này.\n\n\n2. **getParent()**: Trả về chuỗi pathname của pathname trừu tượng cha, hoặc null nếu pathname này không là tên của một thư mục cha.\n\n\n3. **getParentFile()**: Trả về pathname trừu tượng của pathname trừu tượng cha, hoặc null nếu pathname này không là tên của một thư mục cha.\n\n\n4. **getPath()**: Biến đổi pathname trừu tượng này thành một chuỗi pathname.\n\n\n5. **isAbsolute()**: Kiểm tra có hay không pathname trừu tượng này là absolute. Trả về true nếu là absolute, nếu không là false.\n\n\n6. **getAbsolutePath()**: Trả về chuỗi pathname tuyệt đối của pathname trừu tượng này.\n\n\n7. **canRead()**: Kiểm tra có hay không ứng dụng có thể đọc file, được biểu thị bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu file đã xác định bởi pathname trừu tượng này là tồn tại và có thể được đọc từ ứng dụng; nếu không là false.\n\n\n8. **canWrite()**: Kiểm tra có hay không ứng dụng có thể sửa đổi file, được biểu thị bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu hệ thống file thực sự chứa một file được biểu thị bằng pathname trừu tượng này và ứng dụng được phép write tới file đó; nếu không là false.\n\n\n9. **exists()**: Kiểm tra có hay không file hoặc thư mục được biểu thị bởi pathname trừu tượng này là tồn tại. Trả về true nếu và chỉ nếu file hoặc thư mục được biểu thị bởi pathname trừu tượng này là tồn tại; nếu không là false.\n\n\n10. **isDirectory()**: Kiểm tra có hay không file được biểu thị bởi pathname trừu tượng này là một thư mục. Trả về true nếu và chỉ nếu file được biểu thị bởi pathname trừu tượng này là tồn tại và là một thư mục; nếu không là false.\n\n\n11. **isFile()**: Kiểm tra có hay không file được biểu thị bởi pathname trừu tượng này là một normal file. Một file là normal nếu nó không là một thư mục và ngoài ra, thỏa mãn các tiêu chuẩn khác phụ thuộc vào hệ thống. Bất kỳ một non-directory file được tạo bởi một ứng dụng Java được bảo đảm là một normal file. Trả về true nếu và chỉ nếu file được biểu thị bởi pathname trừu tượng này là một normal file; nếu không là false.\n\n\n12. **lastModified()**: Trả về time mà file được biểu thị bởi pathname trừu tượng này được sửa đổi lần cuối cùng. Trả về giá trị long biểu diễn thời gian mà file được sửa đổi lần cuối cùng, được tính toán bằng mili giây từ 00:00:00 GMT, 1/1/1970, hoặc 0L nếu file không tồn tại hoặc nếu một I/O error xuất hiện.\n\n\n13. **length()**: Trả về độ dài của file được biểu thị bởi pathname trừu tượng này. Giá trị trả về là không rõ ràng nếu pathname này biểu thị một thư mục.\n\n\n14. **createNewFile()**: Tạo một file mới, trống với tên pathname trừu tượng này nếu và chỉ nếu một file với tên này chưa tồn tại. Trả về true nếu và chỉ nếu file với tên này không tồn tại và được tạo thành công; nếu file với tên này đã tồn tại, thì trả về false.\n\n\n15. **delete()**: Xóa file hoặc thư mục được biểu thị bởi pathname trừu tượng này. Nếu pathname này biểu thị một thư mục, thì thư mục phải là trống để bị xóa. Trả về true nếu và chỉ nếu file hoặc thư mục bị xóa thành công; nếu không là false.\n\n\n16. **deleteOnExit()**: Yêu cầu rằng file hoặc thư mục được biểu thị bởi pathname trừu tượng này để bị xóa khi thiết bị ảo kết thúc.\n\n\n17. **list()**: Trả về một mảng các chuỗi chỉ các file và thư mục trong thư mục được biểu thị bởi pathname trừu tượng này.\n\n\n18. **list(FilenameFilter filter)**: Trả về một mảng các chuỗi chỉ các file và thư mục trong thư mục được biểu thị bởi pathname trừu tượng này mà thỏa mãn filter đã cho.\n\n\n19. **listFiles()**: Trả về một mảng các pathname trừu tượng biểu thị các file trong thư mục được biểu thị bởi pathname trừu tượng này.\n\n\n20. **listFiles(FileFilter filter)**: Trả về một mảng các pathname trừu tượng biểu thị các file và thư mục trong thư mục được biểu thị bởi pathname trừu tượng này mà thỏa mãn filter đã cho.\n\n\n21. **mkdir()**: Tạo thư mục được chỉ bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu thư mục được tạo; nếu không là false.\n\n\n22. **mkdirs()**: Tạo thư mục được chỉ bởi pathname trừu tượng này, bao gồm bất kỳ thư mục cha nào cần thiết nhưng không tồn tại. Trả về true nếu và chỉ nếu thư mục được tạo, cùng với tất cả thư mục cha cần thiết; nếu không là false.\n\n\n23. **renameTo(File dest)**: Đổi tên file được biểu thị bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu việc đổi tên thành công; nếu không là false.\n\n\n24. **setLastModified(long time)**: Thiết lập thời gian chỉnh sửa cuối cùng của file hoặc thư mục được chỉ bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu hoạt động này thành công; nếu không là false.\n\n\n25. **setReadOnly()**: Đánh dấu file hoặc thư mục được chỉ bởi pathname trừu tượng này để mà các hoạt động read-only được cho phép. Trả về true nếu hoạt động này thành công; nếu không là false.\n\n\n26. **createTempFile(String prefix, String suffix, File directory)**: Tạo một file trống trong thư mục đã cho, bởi sử dụng các chuỗi tiền tố và hậu tố đã cung cấp để tạo tên của nó. Trả về pathname trừu tượng biểu thị một file trống mới được tạo.\n\n\n27. **createTempFile(String prefix, String suffix)**: Tạo một file trống trong thư mục temporary-file, bởi sử dụng tiền tố và hậu tố đã cung cấp để tạo tên của nó. Triệu hồi phương thức này tương đương với gọi phương thức createTempFile(prefix, suffix, null). Trả về pathname trừu tượng biểu thị một file trống mới được tạo.\n\n\n28. **compareTo(File pathname)**: So sánh 2 pathname trừu tượng theo từ điển. Trả về 0 nếu tham số là cân bằng với pathname trừu tượng này, một giá trị nhỏ hơn 0 nếu pathname trừu tượng này nhỏ hơn tham số theo từ điển, hoặc một giá trị lớn hơn 0 nếu pathname trừu tượng này lớn hơn tham số theo từ điển.\n\n\n29. **compareTo(Object o)**: So sánh pathname trừu tượng này với đối tượng khác. Trả về 0 nếu tham số là cân bằng với pathname trừu tượng này, một giá trị nhỏ hơn 0 nếu pathname trừu tượng nhỏ hơn tham số theo từ điển, hoặc một giá trị lớn hơn 0 nếu pathname trừu tượng này lớn hơn tham số theo từ điển.\n\n\n30. **equals(Object obj)**: Kiểm tra pathname trừu tượng này có cân bằng với đối tượng đã cung cấp không. Trả về true nếu và chỉ nếu tham số là không null và là một pathname trừu tượng mà biểu thị file hoặc thư mục giống như với pathname trừu tượng này.\n\n\n31. **toString()**: Trả về chuỗi pathname của pathname trừu tượng này. Đây là chuỗi được trả về bởi phương thức getPath().File(File parent, String child);\n\n, File(String pathname)\n\n, File(String parent, String child)\n\n, File(URI uri)\n\n, package com.tutorialspoint; import java.io.File; public class FileDemo {\npublic static void main(String[] args) { File f = null; String[] strs =\n{\"test1.txt\", \"test2.txt\"}; try{ // voi moi string trong mang string\nfor(String s:strs ) { // tao file moi f= new File(s); // true neu file la\nexecutable boolean bool = f.canExecute(); // tim absolute path String a =\nf.getAbsolutePath(); // in absolute path System.out.print(a); // prints\nSystem.out.println(\" la executable: \"+ bool); } }catch(Exception e){ // neu co\nbat cu I/O error nao xuat hien e.printStackTrace(); } } }\n\n, test1.txt la executable: true test2.txt la executable: false\n\n"
    }
  },
  {
    "id": "74",
    "name": "Lớp FileReader",
    "href": "https://www.vietjack.com/java/lop_filereader_trong_java.jsp",
    "lesson": {
      "title": "Lớp FileReader trong Java",
      "content": "Lớp FileReader trong Java là một lớp được sử dụng để đọc các ký tự từ một tệp văn bản. Nó có một số constructor để tạo các đối tượng cần thiết. Lớp này có một số phương thức giúp bạn có thể thao tác các tệp, chẳng hạn như phương thức read() để đọc các ký tự bên trong một mảng trả về số ký tự đã đọc, phương thức read(char[]) để đọc một ký tự đơn trả về một int mà biểu diễn ký tự đã đọc.**STT** | **Phương thức** | **Miêu tả**\n\n--- | --- | ---\n\n**1** | `public int read()` | Đọc một ký tự duy nhất và trả về giá trị int biểu diễn ký tự đã đọc.\n\n**2** | `public int read(char [] c, int offset, int len)` | Đọc các ký tự vào mảng `c` bắt đầu từ vị trí `offset` và có độ dài `len`. Trả về số ký tự đã đọc.FileReader(File file)\n\n, FileReader(FileDescriptor fd)\n\n, FileReader(String fileName)\n\n, import java.io.*;public class FileRead{ public static void main(String\nargs[])throws IOException{ File file = new File(\"Hello1.txt\"); // tao file\nfile.createNewFile(); // tao mot doi tuong FileWriter FileWriter writer = new\nFileWriter(file); // ghi noi dung vao file writer.write(\"Day\\n la\\n mot\\n vi\\n\ndu\\n\"); writer.flush(); writer.close(); //Tao mot doi tuong FileReader\nFileReader fr = new FileReader(file); char [] a = new char[50]; fr.read(a); //\ndoc noi dung toi mang for(char c : a) System.out.print(c); //in tung ky tu mot\nfr.close(); } }\n\n, Day la mot vi du\n\n"
    }
  },
  {
    "id": "84",
    "name": "Lớp FileWriter",
    "href": "https://www.vietjack.com/java/lop_filewriter_trong_java.jsp",
    "lesson": {
      "title": "Lớp FileWriter trong Java",
      "content": "FileWriter là một lớp trong Java được sử dụng để ghi dữ liệu vào một tệp. Lớp này cung cấp một số phương thức để thao tác với các tệp, bao gồm:\n\n- `FileWriter(String fileName, boolean append)`: Constructor này tạo một đối tượng FileWriter được cung cấp một tên tệp và một boolean chỉ dẫn có nên nối thêm dữ liệu đã ghi vào tệp hiện có hay không.\n- `FileWriter(String fileName)`: Constructor này tạo một đối tượng FileWriter được cung cấp một tên tệp.\n- `FileWriter(File file, boolean append)`: Constructor này tạo một đối tượng FileWriter được liên kết với một đối tượng File và một boolean chỉ dẫn có nên nối thêm dữ liệu đã ghi vào tệp hiện có hay không.\n- `FileWriter(File file)`: Constructor này tạo một đối tượng FileWriter được liên kết với một đối tượng File.\n\nLớp FileWriter có một số phương thức để ghi dữ liệu vào tệp, bao gồm:\n\n- `write(String str)`: Phương thức này ghi một phần của chuỗi bắt đầu từ vị trí offset và có độ dài len vào tệp.\n- `write(char[] cbuf)`: Phương thức này ghi một phần của mảng ký tự bắt đầu từ vị trí offset và có độ dài len vào tệp.\n- `write(char c)`: Phương thức này ghi một ký tự đơn vào tệp.\n\nLớp FileWriter kế thừa từ lớp OutputStreamWriter, lớp này được sử dụng để ghi các luồng ký tự.1. Phương thức `write(int c)` được sử dụng để ghi một ký tự đơn vào luồng đầu ra.\n\n\n2. Phương thức `write(char [] c, int offset, int len)` được sử dụng để ghi một phần của mảng ký tự vào luồng đầu ra. Phần được ghi bắt đầu từ vị trí `offset` và có độ dài `len`.\n\n\n3. Phương thức `write(String s, int offset, int len)` được sử dụng để ghi một phần của chuỗi ký tự vào luồng đầu ra. Phần được ghi bắt đầu từ vị trí `offset` và có độ dài `len`.FileWriter(File file)\n\n, FileWriter(File file, boolean append)\n\n, FileWriter(FileDescriptor fd)\n\n, FileWriter(String fileName)\n\n, FileWriter(String fileName, boolean append)\n\n, import java.io.*; public class FileRead{ public static void main(String\nargs[])throws IOException{ File file = new File(\"Hello1.txt\"); // tao file\nfile.createNewFile(); // Tao mot doi tuong FileWriter FileWriter writer = new\nFileWriter(file); // ghi noi dung vao file writer.write(\"Day\\n la\\n mot\\n vi\\n\ndu\\n\"); writer.flush(); writer.close(); //Tao mot doi tuong FileReader\nFileReader fr = new FileReader(file); char [] a = new char[50]; fr.read(a); //\ndoc noi dung toi mang for(char c : a) System.out.print(c); //in tung ky tu mot\nfr.close(); } }\n\n, Day la mot vi du\n\n"
    }
  },
  {
    "id": "15",
    "name": "Đối tượng String",
    "href": "https://www.vietjack.com/java/string_trong_java.jsp",
    "lesson": {
      "title": "String trong Java",
      "content": "Phương thức static format của đối tượng string cho phép tạo chuỗi đã được định dạng để tái sử dụng, trái ngược với lệnh một lần. Thay vì sử dụng phương thức printf và format để xuất ra các số được định dạng, lớp string có phương thức lớp tương đương là format, trả về một đối tượng string chứ không phải là một đối tượng printstream. Trong trường hợp này, JVM sẽ tạo một đối tượng mới trong bộ nhớ heap, không phải trong pool, và hằng xinchao sẽ được đặt trong pool. Biến sẽ tham chiếu tới đối tượng trong heap chứ không phải trong pool. Để làm cho Java hiệu quả hơn trong việc sử dụng bộ nhớ, không có đối tượng mới nào được tạo khi nó đã tồn tại trong pool. Trong ví dụ trên, chỉ có một đối tượng được tạo đầu tiên. JVM sẽ không tìm thấy bất kỳ đối tượng string nào với giá trị xinchao trong pool, vì thế nó sẽ tạo một đối tượng mới. Sau đó, nó sẽ tìm thấy chuỗi với giá trị xinchao trong pool, nó sẽ không tạo đối tượng mới nhưng sẽ trả về tham chiếu tới cùng instance của đối tượng đó. Mỗi khi tạo một hằng chuỗi đầu tiên, JVM kiểm tra pool chứa các hằng chuỗi. Nếu chuỗi đã tồn tại trong pool, một tham chiếu tới pool được trả về. Nếu chuỗi không tồn tại trong pool, một instance của chuỗi mới được tạo và được đặt trong pool. Theo mặc định, Java không lưu trữ tất cả đối tượng string vào string pool. Thay vào đó, họ cung cấp một cách thức linh hoạt để lưu trữ bất kỳ một đối tượng nào trong string pool sử dụng phương thức intern để lưu trữ mọi object bất kỳ vào string pool. Khi sử dụng string literal, theo mặc định nó sẽ gọi phương thức intern để làm việc này. Đây chính là điểm khác biệt lớn nhất giữa string literal và sử dụng new. Các đối tượng string được lưu trữ trong một khu vực bộ nhớ đặc biệt gọi là string constant pool. String literal trong Java được tạo bởi sử dụng dấu trích dẫn kép. Có hai cách để tạo đối tượng string: bởi hằng chuỗi string literal và bởi từ khóa new. Nói chung, chuỗi là một dãy ký tự liên tục. Trong Java, string là một đối tượng biểu diễn một dãy ký tự liên tục. Lớp string được sử dụng để tạo đối tượng string. Chúng ta sẽ tìm hiểu về chuỗi dạng immutable sau. Trong chương này, chúng ta sẽ tìm hiểu chuỗi trong Java là gì và cách để tạo đối tượng string. Lớp java.lang.String triển khai các serializable, comparable và charsequence interface. Chuỗi string trong Java là không thể thay đổi (immutable), ví dụ nó không thể bị thay đổi nhưng sẽ có một instance được tạo. Tuy nhiên, nếu muốn sử dụng các lớp có thể thay đổi, bạn có thể lựa chọn sử dụng các lớp stringbuffer và stringbuilder. Là tương tự như vậy, chuỗi trong Java xử lý chuỗi trong Java. Chuỗi string trong Java cung cấp nhiều khái niệm đa dạng giúp thao tác và xử lý với chuỗi như sánh, cắt nối, tìm độ dài, thay thế, tìm chuỗi con. Trong Java, về cơ bản chuỗi là một đối tượng biểu diễn dãy các giá trị char, một mảng các ký tự làm việc khá giống như chuỗi trong Java.char[] ch={'j','a','v','a','t','p','o','i','n','t'}; String s=new String(ch);\n\n, String s=\"vietjack\";\n\n, String s=\"xinchao\";\n\n, String s1=\"xinchao\"; String s2=\"xinchao\";//se khong tao instance moi\n\n, String s=new String(\"xinchao\");//tao hai doi tuong va mot bien tham chieu\n\n, public class StringExample{ public static void main(String args[]){ String\ns1=\"java\";//tao string boi string literal char\nch[]={'s','t','r','i','n','g','s'}; String s2=new String(ch);//chuyen doi mang\nky tu thanh string String s3=new String(\"Vidu\");//tao string boi tu khoa new\nSystem.out.println(s1); System.out.println(s2); System.out.println(s3); }}\n\n, System.out.printf(\"Gia tri cua bien float la \" + \"%f, trong khi gia tri cua\nbien integer \" + \"bien la %d, va chuoi la \" + \"is %s\", floatVar, intVar,\nstringVar);\n\n, String fs; fs = String.format(\"Gia tri cua bien float la \" + \"%f, trong khi\ngia tri cua bien integer \" + \"bien la %d, va chuoi la \" + \"is %s\", floatVar,\nintVar, stringVar); System.out.println(fs);\n\n"
    }
  },
  {
    "id": "25",
    "name": "Immutable String",
    "href": "https://www.vietjack.com/java/immutable_string_trong_java.jsp",
    "lesson": {
      "title": "Immutable String trong Java",
      "content": "Trong Java, khái niệm string literal được sử dụng. Khi có nhiều biến tham chiếu đến cùng một đối tượng, nếu một biến tham chiếu thay đổi giá trị của đối tượng, thì tất cả các biến tham chiếu khác cũng sẽ bị ảnh hưởng. Do đó, đối tượng string trong Java là immutable (không thể thay đổi).\n\nVí dụ, nếu có biến tham chiếu `imta` trỏ đến đối tượng `imtateam`, nếu gán `imtateam` cho biến tham chiếu `imta`, thì biến `imta` sẽ tham chiếu đến đối tượng `imtateam` thay vì `imta`. Trong trường hợp này, đối tượng `imta` vẫn không bị sửa đổi, nhưng biến tham chiếu `imta` bây giờ trỏ đến một đối tượng khác.\n\nDo đó, string trong Java là immutable. Trong ví dụ trên, hai đối tượng được tạo ra, nhưng biến tham chiếu `imta` vẫn trỏ đến đối tượng `imta` chứ không phải đối tượng `imtateam`.\n\nImmutable có nghĩa là không thể thay đổi hoặc sửa đổi. Một khi một đối tượng string được tạo, thì dữ liệu hoặc trạng thái của nó không thể bị thay đổi. Tuy nhiên, bạn vẫn có thể tạo một đối tượng string mới với giá trị khác.class Testimmutablestring{ public static void main(String args[]){ String\ns=\"vietjack\"; s.concat(\" vietjackteam\");//phuong thuc concat() phu them vao\ncuoi chuoi System.out.println(s);//se in vietjack vi string la immutable } }\n\n, class Testimmutablestring1{ public static void main(String args[]){ String\ns=\"vietjack\"; s=s.concat(\" vietjackteam\"); System.out.println(s); } }\n\n"
    }
  },
  {
    "id": "35",
    "name": "So sánh chuỗi",
    "href": "https://www.vietjack.com/java/so_sanh_chuoi_trong_java.jsp",
    "lesson": {
      "title": "So sánh chuỗi trong Java",
      "content": "Chuỗi trong Java có thể được so sánh theo nội dung hoặc theo tham chiếu. So sánh theo nội dung có nghĩa là so sánh các ký tự thực tế trong chuỗi, trong khi so sánh theo tham chiếu có nghĩa là so sánh các vị trí bộ nhớ của các chuỗi.\n\nCó một số phương thức khác nhau có thể được sử dụng để so sánh chuỗi trong Java. Phương thức `compareTo()` trả về giá trị âm nếu chuỗi đầu tiên nhỏ hơn chuỗi thứ hai, giá trị dương nếu chuỗi đầu tiên lớn hơn chuỗi thứ hai và 0 nếu hai chuỗi bằng nhau. Phương thức `equals()` trả về `true` nếu hai chuỗi bằng nhau và `false` nếu chúng khác nhau. Phương thức `equalsIgnoreCase()` giống như phương thức `equals()`, nhưng nó bỏ qua sự khác biệt về kiểu chữ.\n\nNgoài các phương thức này, cũng có thể sử dụng toán tử `==` để so sánh chuỗi. Toán tử `==` trả về `true` nếu hai chuỗi bằng nhau và `false` nếu chúng khác nhau. Tuy nhiên, toán tử `==` so sánh tham chiếu của các chuỗi chứ không phải nội dung của chúng. Điều này có nghĩa là nếu hai chuỗi có cùng nội dung nhưng được lưu trữ ở các vị trí bộ nhớ khác nhau, thì toán tử `==` sẽ trả về `false`.\n\nKhi so sánh chuỗi, điều quan trọng là phải xem xét loại so sánh nào là phù hợp nhất cho tình huống cụ thể. Nếu cần so sánh nội dung của các chuỗi, thì nên sử dụng phương thức `compareTo()` hoặc `equals()`. Nếu cần so sánh tham chiếu của các chuỗi, thì nên sử dụng toán tử `==`.class Sosanhchuoi1{ public static void main(String args[]){ String\ns1=\"Vietjack\"; String s2=\"Vietjack\"; String s3=new String(\"Vietjack\"); String\ns4=\"Vietjackteam\"; System.out.println(s1.equals(s2));//true\nSystem.out.println(s1.equals(s3));//true\nSystem.out.println(s1.equals(s4));//false } }\n\n, class Sosanhchuoi2{ public static void main(String args[]){ String\ns1=\"Vietjack\"; String s2=\"VIETJACK\"; System.out.println(s1.equals(s2));//false\nSystem.out.println(s1.equalsIgnoreCase(s3));//true } }\n\n, class Sosanhchuoi3{ public static void main(String args[]){ String\ns1=\"Vietjack\"; String s2=\"Vietjack\"; String s3=new String(\"Vietjack\");\nSystem.out.println(s1==s2);//true (boi vi ca hai cung tham chieu toi cung\ninstance) System.out.println(s1==s3);//false(boi vi s3 tham chieu toi instance\nduoc tao khong phai trong Pool) } }\n\n, class Teststringcomparison4{ public static void main(String args[]){ String\ns1=\"Vietjack\"; String s2=\"Vietjack\"; String s3=\"Doan\";\nSystem.out.println(s1.compareTo(s2));//0\nSystem.out.println(s1.compareTo(s3));//1(boi vi s1 > s3)\nSystem.out.println(s3.compareTo(s1));//-1(boi vi s3 < s1 ) } }\n\n"
    }
  },
  {
    "id": "45",
    "name": "Nối chuỗi",
    "href": "https://www.vietjack.com/java/noi_chuoi_trong_java.jsp",
    "lesson": {
      "title": "Nối chuỗi trong Java",
      "content": "Phương thức concat trong Java được sử dụng để nối chuỗi đã cho vào phần cuối của chuỗi hiện tại. Cú pháp của phương thức concat là:\n\n```java\npublic String concat(String str)\n```\n\nTrong đó:\n\n* `str` là chuỗi cần nối vào chuỗi hiện tại.\n\nPhương thức concat trả về một chuỗi mới là sự kết hợp của chuỗi hiện tại và chuỗi `str`.\n\nNgoài phương thức concat, Java còn cung cấp một toán tử nối chuỗi (`+`) để nối hai chuỗi. Toán tử nối chuỗi có thể được sử dụng để nối hai chuỗi hoặc để nối một chuỗi với một giá trị ở kiểu dữ liệu gốc. Ví dụ:\n\n```java\nString str1 = \"Hello\";\nString str2 = \"World\";\nString str3 = str1 + str2; // str3 = \"HelloWorld\"\n```\n\nToán tử nối chuỗi cũng có thể được sử dụng để nối một chuỗi với một giá trị ở kiểu dữ liệu gốc. Ví dụ:\n\n```java\nint num1 = 10;\nString str4 = \"The number is \" + num1; // str4 = \"The number is 10\"\n```\n\nToán tử nối chuỗi có thể được sử dụng để nối nhiều chuỗi và giá trị ở kiểu dữ liệu gốc. Ví dụ:\n\n```java\nString str5 = \"Hello\" + \" \" + \"World\" + \"!\" + 10; // str5 = \"Hello World!10\"\n```class Noichuoi1{ public static void main(String args[]){ String s=\"Vietjack\"+\"\nTeam\"; System.out.println(s);//in ra ket qua Vietjack Team } }\n\n, String s=(new StringBuilder()).append(\"Vietjack\").append(\" Team).toString();\n\n, class Noichuoi2{ public static void main(String args[]){ String\ns=50+30+\"Vietjack\"+40+40; System.out.println(s);//in ra ket qua 80Vietjack4040\n} }\n\n, public String concat(String khac)\n\n, class Noichuoi3{ public static void main(String args[]){ String s1=\"Vietjack\n\"; String s2=\"Team\"; String s3=s1.concat(s2); System.out.println(s3);//in ra\nket qua Vietjack Team } }\n\n"
    }
  },
  {
    "id": "55",
    "name": "Chuỗi con",
    "href": "https://www.vietjack.com/java/chuoi_con_trong_java.jsp",
    "lesson": {
      "title": "Chuỗi con trong Java",
      "content": "Chuỗi con là một phần của chuỗi. Trong Java, bạn có thể lấy chuỗi con từ một chuỗi đã cho bằng phương thức `substring()`. Phương thức này có hai dạng:\n\n* `substring(int startIndex, int endIndex)`: Trả về một chuỗi con mới chứa chuỗi con của chuỗi đã cho từ chỉ mục `startIndex` (bao gồm) đến chỉ mục `endIndex` (không bao gồm).\n* `substring(int startIndex)`: Trả về một chuỗi con mới chứa chuỗi con của chuỗi đã cho từ chỉ mục `startIndex` (bao gồm) đến cuối chuỗi.\n\nChỉ mục bắt đầu được tính từ 0. Ví dụ:\n\n```java\nString str = \"Hello, world!\";\n\nString substring1 = str.substring(0, 5); // \"Hello\"\nString substring2 = str.substring(7); // \"world!\"\n```\n\nBạn cũng có thể sử dụng phương thức `substring()` để lấy một ký tự duy nhất từ một chuỗi. Ví dụ:\n\n```java\nString str = \"Hello, world!\";\n\nchar firstChar = str.substring(0, 1).charAt(0); // 'H'\n```String s=\"hello\"; System.out.println(s.substring(0,2));//he\n\n, public class Chuoicon{ public static void main(String args[]){ String s=\"Trang\nVietjack\"; System.out.println(s.substring(5));//Vietjack\nSystem.out.println(s.substring(0,5));//Trang } }\n\n"
    }
  },
  {
    "id": "65",
    "name": "Phương thức của lớp String",
    "href": "https://www.vietjack.com/java/phuong_thuc_cua_lop_string_trong_java.jsp",
    "lesson": {
      "title": "Phương thức của lớp String trong Java",
      "content": "- Phương thức `valueOf` trả về một chuỗi biểu diễn của một giá trị đã cho. Nó chuyển đổi các kiểu dữ liệu nguyên thủy như `int`, `long`, `float`, `double`, `boolean`, `char` và mảng `char` thành chuỗi. Ví dụ:\n\n```java\nString str1 = String.valueOf(10); // str1 = \"10\"\nString str2 = String.valueOf(3.14); // str2 = \"3.14\"\nString str3 = String.valueOf(true); // str3 = \"true\"\n```\n\n- Phương thức `intern` trả về một biểu diễn chuẩn tắc của đối tượng `String` này. Một nhóm các chuỗi trống được duy trì riêng cho lớp `String` khi phương thức `intern` được gọi. Nếu nhóm đã chứa một chuỗi bằng với đối tượng `String` (như được xác định bởi phương thức `equals`) thì chuỗi từ nhóm được trả về. Nếu không, đối tượng `String` này được thêm vào nhóm và một tham chiếu đến đối tượng `String` này được trả về. Ví dụ:\n\n```java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\n\n// Kiểm tra xem str1 và str2 có tham chiếu đến cùng một đối tượng String hay không\nif (str1 == str2) {\n  System.out.println(\"str1 và str2 tham chiếu đến cùng một đối tượng String\");\n} else {\n  System.out.println(\"str1 và str2 không tham chiếu đến cùng một đối tượng String\");\n}\n\n// Intern str2\nString str3 = str2.intern();\n\n// Kiểm tra xem str1 và str3 có tham chiếu đến cùng một đối tượng String hay không\nif (str1 == str3) {\n  System.out.println(\"str1 và str3 tham chiếu đến cùng một đối tượng String\");\n} else {\n  System.out.println(\"str1 và str3 không tham chiếu đến cùng một đối tượng String\");\n}\n```\n\n- Phương thức `length` trả về độ dài của chuỗi. Ví dụ:\n\n```java\nString str = \"Hello World\";\nint length = str.length(); // length = 11\n```\n\n- Phương thức `charAt` trả về ký tự tại chỉ mục đã cho. Ví dụ:\n\n```java\nString str = \"Hello World\";\nchar ch = str.charAt(0); // ch = 'H'\n```\n\n- Phương thức `trim` loại bỏ các khoảng trắng ở trước và sau chuỗi (leading và trailing). Ví dụ:\n\n```java\nString str = \"   Hello World   \";\nString trimmedStr = str.trim(); // trimmedStr = \"Hello World\"\n```\n\n- Phương thức `toUpperCase` chuyển đổi tất cả các ký tự trong chuỗi thành chữ hoa. Ví dụ:\n\n```java\nString str = \"hello world\";\nString upperCaseStr = str.toUpperCase(); // upperCaseStr = \"HELLO WORLD\"\n```\n\n- Phương thức `toLowerCase` chuyển đổi tất cả các ký tự trong chuỗi thành chữ thường. Ví dụ:\n\n```java\nString str = \"HELLO WORLD\";\nString lowerCaseStr = str.toLowerCase(); // lowerCaseStr = \"hello world\"\n```\n\n- Phương thức `replace` thay thế tất cả các lần xuất hiện của một chuỗi con bằng một chuỗi khác. Ví dụ:\n\n```java\nString str = \"Hello World\";\nString replacedStr = str.replace(\"World\", \"Universe\"); // replacedStr = \"Hello Universe\"\n```\n\n- Phương thức `substring` trả về một chuỗi con của chuỗi này. Ví dụ:\n\n```java\nString str = \"Hello World\";\nString subStr1 = str.substring(0, 5); // subStr1 = \"Hello\"\nString subStr2 = str.substring(6); // subStr2 = \"World\"\n```\n\n- Phương thức `concat` nối một chuỗi đã cho vào cuối chuỗi này. Ví dụ:\n\n```java\nString str1 = \"Hello\";\nString str2 = \"World\";\nString concatenatedStr = str1.concat(str2); // concatenatedStr = \"HelloWorld\"\n```\n\n- Phương thức `compareTo` so sánh chuỗi này với một chuỗi khác. Nó trả về một số nguyên âm nếu chuỗi này nhỏ hơn chuỗi khác, một số nguyên dương nếu chuỗi này lớn hơn chuỗi khác và 0 nếu hai chuỗi bằng nhau. Ví dụ:\n\n```java\nString str1 = \"Hello\";\nString str2 = \"World\";\nint comparisonResult = str1.compareTo(str2); // comparisonResult = -5\n\nString str3 = \"Hello\";\nint comparisonResult2 = str1.compareTo(str3); // comparisonResult2 = 0\n```\n\n- Phương thức `compareToIgnoreCase` so sánh chuỗi này với một chuỗi khác bỏ qua sự khác biệt về kiểu chữ. Nó trả về một số nguyên âm nếu chuỗi này nhỏ hơn chuỗi khác, một số nguyên dương nếu chuỗi này lớn hơn chuỗi khác và 0 nếu hai chuỗi bằng nhau. Ví dụ:\n\n```java\nString str1 = \"Hello\";\nString str2 = \"WORLD\";\nint comparisonResult = str1.compareToIgnoreCase(str2); // comparisonResult = 0\n```\n\n- Phương thức `equals` kiểm tra xem chuỗi này có bằng với một chuỗi khác hay không. Nó trả về `true` nếu hai chuỗi bằng nhau và `false` nếu không bằng nhau. Ví dụ:\n\n```java\nString str1 = \"Hello\";\nString str2 = \"Hello\";\n\n// Kiểm tra xem str1 và str2 có bằng nhau hay không\nif (str1.equals(str2)) {\n  System.out.println(\"str1 và str2 bằng nhau\");\n} else {\n  System.out.println(\"str1 và str2 không bằng nhau\");\n}\n```\n\n- Phương thức `equalsIgnoreCase` kiểm tra xem chuỗi này có bằng với một chuỗi khác hay không, bỏ qua sự khác biệt về kiểu chữ. Nó trả về `true` nếu hai chuỗi bằng nhau và `false` nếu không bằng nhau. Ví dụ:\n\n```java\nString str1 = \"Hello\";\nString str2 = \"hELLO\";\n\n// Kiểm tra xem str1 và str2 có bằng nhau hay không, bỏ qua sự khác biệt về kiểu chữ\nif (str1.equalsIgnoreCase(str2)) {\n  System.out.println(\"str1 và str2 bằng nhau, bỏ qua sự khác biệt về kiểu chữ\");\n} else {\n  System.out.println(\"str1 và str2 không bằng nhau, bỏ qua sự khác biệt về kiểu chữ\");\n}\n```1. Phương thức charAt() trả về ký tự tại chỉ mục đã cho trong chuỗi.\n\n\n2. Phương thức compareTo() so sánh chuỗi này với một đối tượng khác và trả về một số nguyên dương nếu chuỗi này lớn hơn đối tượng đó, một số nguyên âm nếu chuỗi này nhỏ hơn đối tượng đó hoặc 0 nếu hai chuỗi bằng nhau.\n\n\n3. Phương thức compareTo(String anotherString) so sánh hai chuỗi theo thứ tự từ điển và trả về một số nguyên dương nếu chuỗi này lớn hơn chuỗi kia, một số nguyên âm nếu chuỗi này nhỏ hơn chuỗi kia hoặc 0 nếu hai chuỗi bằng nhau.\n\n\n4. Phương thức compareToIgnoreCase(String str) so sánh hai chuỗi theo thứ tự từ điển, bỏ qua sự khác biệt về kiểu chữ, và trả về một số nguyên dương nếu chuỗi này lớn hơn chuỗi kia, một số nguyên âm nếu chuỗi này nhỏ hơn chuỗi kia hoặc 0 nếu hai chuỗi bằng nhau.\n\n\n5. Phương thức concat(String str) nối chuỗi đã cho vào cuối chuỗi này và trả về một chuỗi mới.\n\n\n6. Phương thức contentEquals(StringBuffer sb) trả về true nếu và chỉ nếu chuỗi này biểu diễn cùng một dãy các ký tự như StringBuffer đã cho.\n\n\n7. Phương thức copyValueOf(char[] data) trả về một chuỗi biểu diễn dãy ký tự trong mảng đã cho.\n\n\n8. Phương thức copyValueOf(char[] data, int offset, int count) trả về một chuỗi biểu diễn dãy ký tự trong mảng đã cho, bắt đầu từ vị trí offset và có độ dài count.\n\n\n9. Phương thức endsWith(String suffix) kiểm tra xem chuỗi này có kết thúc bằng hậu tố đã cho hay không và trả về true nếu có, ngược lại trả về false.\n\n\n10. Phương thức equals(Object anObject) so sánh chuỗi này với đối tượng đã cho và trả về true nếu hai đối tượng bằng nhau, ngược lại trả về false.\n\n\n11. Phương thức equalsIgnoreCase(String anotherString) so sánh chuỗi này với chuỗi khác, bỏ qua sự khác biệt về kiểu chữ, và trả về true nếu hai chuỗi bằng nhau, ngược lại trả về false.\n\n\n12. Phương thức getBytes() mã hóa chuỗi này thành một mảng byte bằng bộ ký tự mặc định của hệ thống.\n\n\n13. Phương thức getBytes(String charsetName) mã hóa chuỗi này thành một mảng byte bằng bộ ký tự đã cho.\n\n\n14. Phương thức getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) sao chép các ký tự từ chuỗi này vào mảng ký tự đích.\n\n\n15. Phương thức hashCode() trả về một mã băm cho chuỗi này.\n\n\n16. Phương thức indexOf(int ch) trả về chỉ mục đầu tiên của ký tự đã cho trong chuỗi này.\n\n\n17. Phương thức indexOf(int ch, int fromIndex) trả về chỉ mục đầu tiên của ký tự đã cho trong chuỗi này, bắt đầu tìm kiếm từ chỉ mục fromIndex.\n\n\n18. Phương thức indexOf(String str) trả về chỉ mục đầu tiên của chuỗi con đã cho trong chuỗi này.\n\n\n19. Phương thức indexOf(String str, int fromIndex) trả về chỉ mục đầu tiên của chuỗi con đã cho trong chuỗi này, bắt đầu tìm kiếm từ chỉ mục fromIndex.\n\n\n20. Phương thức intern() trả về một tham chiếu đến chuỗi này trong bộ nhớ chung của máy ảo Java.\n\n\n21. Phương thức lastIndexOf(int ch) trả về chỉ mục cuối cùng của ký tự đã cho trong chuỗi này.\n\n\n22. Phương thức lastIndexOf(int ch, int fromIndex) trả về chỉ mục cuối cùng của ký tự đã cho trong chuỗi này, bắt đầu tìm kiếm ngược từ chỉ mục fromIndex.\n\n\n23. Phương thức lastIndexOf(String str) trả về chỉ mục cuối cùng của chuỗi con đã cho trong chuỗi này.\n\n\n24. Phương thức lastIndexOf(String str, int fromIndex) trả về chỉ mục cuối cùng của chuỗi con đã cho trong chuỗi này, bắt đầu tìm kiếm ngược từ chỉ mục fromIndex.\n\n\n25. Phương thức length() trả về độ dài của chuỗi này.\n\n\n26. Phương thức matches(String regex) kiểm tra xem chuỗi này có khớp với biểu thức chính quy đã cho hay không và trả về true nếu có, ngược lại trả về false.\n\n\n27. Phương thức regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) kiểm tra xem hai chuỗi có khớp nhau trong một khoảng nhất định hay không, bỏ qua sự khác biệt về kiểu chữ nếu ignoreCase là true.\n\n\n28. Phương thức regionMatches(int toffset, String other, int ooffset, int len) kiểm tra xem hai chuỗi có khớp nhau trong một khoảng nhất định hay không.\n\n\n29. Phương thức replace(char oldChar, char newChar) trả về một chuỗi mới trong đó tất cả các lần xuất hiện của ký tự oldChar trong chuỗi này được thay thế bằng ký tự newChar.\n\n\n30. Phương thức replaceAll(String regex, String replacement) trả về một chuỗi mới trong đó tất cả các chuỗi con khớp với biểu thức chính quy regex trong chuỗi này được thay thế bằng chuỗi replacement.\n\n\n31. Phương thức replaceFirst(String regex, String replacement) trả về một chuỗi mới trong đó chuỗi con đầu tiên khớp với biểu thức chính quy regex trong chuỗi này được thay thế bằng chuỗi replacement.\n\n\n32. Phương thức split(String regex) chia chuỗi này thành một mảng các chuỗi con bằng cách sử dụng biểu thức chính quy regex làm bộ phân tách.\n\n\n33. Phương thức split(String regex, int limit) chia chuỗi này thành một mảng các chuỗi con bằng cách sử dụng biểu thức chính quy regex làm bộ phân tách và giới hạn số lượng chuỗi con được trả về là limit.\n\n\n34. Phương thức startsWith(String prefix) kiểm tra xem chuỗi này có bắt đầu bằng tiền tố đã cho hay không và trả về true nếu có, ngược lại trả về false.\n\n\n35. Phương thức startsWith(String prefix, int toffset) kiểm tra xem chuỗi này có bắt đầu bằng tiền tố đã cho từ chỉ mục toffset hay không và trả về true nếu có, ngược lại trả về false.\n\n\n36. Phương thức subSequence(int beginIndex, int endIndex) trả về một chuỗi con của chuỗi này, bắt đầu từ chỉ mục beginIndex và kết thúc tại chỉ mục endIndex-1.\n\n\n37. Phương thức substring(int beginIndex) trả về một chuỗi con của chuỗi này, bắt đầu từ chỉ mục beginIndex và kết thúc tại chỉ mục cuối cùng của chuỗi.\n\n\n38. Phương thức substring(int beginIndex, int endIndex) trả về một chuỗi con của chuỗi này, bắt đầu từ chỉ mục beginIndex và kết thúc tại chỉ mục endIndex-1.\n\n\n39. Phương thức toCharArray() trả về một mảng các ký tự biểu diễn chuỗi này.\n\n\n40. Phương thức toLowerCase() trả về một chuỗi mới trong đó tất cả các ký tự trong chuỗi này được chuyển thành chữ thường.\n\n\n41. Phương thức toLowerCase(Locale locale) trả về một chuỗi mới trong đó tất cả các ký tự trong chuỗi này được chuyển thành chữ thường theo quy tắc của ngôn ngữ đã cho.\n\n\n42. Phương thức toString() trả về chuỗi này.\n\n\n43. Phương thức toUpperCase() trả về một chuỗi mới trong đó tất cả các ký tự trong chuỗi này được chuyển thành chữ hoa.\n\n\n44. Phương thức toUpperCase(Locale locale) trả về một chuỗi mới trong đó tất cả các ký tự trong chuỗi này được chuyển thành chữ hoa theo quy tắc của ngôn ngữ đã cho.\n\n\n45. Phương thức trim() trả về một chuỗi mới trong đó tất cả các khoảng trắng ở đầu và cuối chuỗi này bị xóa bỏ.\n\n\n46. Phương thức valueOf(primitive data type x) trả về một chuỗi biểu diễn giá trị của tham số kiểu dữ liệu đã truyền.String s=\"Vietjack\"; System.out.println(s.toUpperCase());//Chuyen doi thanh\nVIETJACK System.out.println(s.toLowerCase());//Chuyen doi thanh vietjack\nSystem.out.println(s);//Vietjack(khong co thay doi nao)\n\n, VIETJACK vietjack Vietjack\n\n, String s=\" Vietjack \"; System.out.println(s);//in ra chuoi nhu ban dau\nVietjack (van con khoang trang whitespace) System.out.println(s.trim());//in\nra chuoi sau khi da cat cac khoang trong trang Vietjack\n\n, String s=\"Vietjack\"; System.out.println(s.startsWith(\"Vi\"));//true\nSystem.out.println(s.endsWith(\"k\"));//true\n\n, String s=\"Vietjack\"; System.out.println(s.charAt(0));//tra ve V\nSystem.out.println(s.charAt(3));//tra ve t\n\n, String s=\"Vietjack\"; System.out.println(s.length());//tra ve do dai la 7\n\n, String s=new String(\"Vietjack\"); String s2=s.intern();\nSystem.out.println(s2);//tra ve Vietjack\n\n, int a=10; String s=String.valueOf(a); System.out.println(s+10); //In ra ket\nqua la 1010\n\n, String s1=\"Java la mot ngon ngu lap trinh. Java la mot nen tang. Java la mot\nhon dao.\"; String replaceString=s1.replace(\"Java\",\"HaLong\");//thay the tat ca\nsu xuat hien cua \"Java\" thanh \"HaLong\" System.out.println(replaceString);\n\n, HaLong la mot ngon ngu lap trinh. HaLong la mot nen tang. HaLong la mot hon\ndao.\n\n"
    }
  },
  {
    "id": "75",
    "name": "Lớp StringBuffer",
    "href": "https://www.vietjack.com/java/lop_stringbuffer_trong_java.jsp",
    "lesson": {
      "title": "Lớp StringBuffer trong Java",
      "content": "Lớp StringBuilder trong Java là một lớp có thể thay đổi được, có nghĩa là bạn có thể thêm, xóa hoặc thay thế các ký tự trong chuỗi. Nó cũng cung cấp một số phương thức hữu ích để thao tác chuỗi, chẳng hạn như `reverse()`, `delete()` và `insert()`.\n\nĐể tạo một đối tượng StringBuilder, bạn có thể sử dụng một trong ba constructor sau:\n\n* `StringBuilder()`: Tạo một đối tượng StringBuilder trống.\n* `StringBuilder(String str)`: Tạo một đối tượng StringBuilder từ một chuỗi đã cho.\n* `StringBuilder(int capacity)`: Tạo một đối tượng StringBuilder với dung lượng ban đầu là `capacity`.\n\nPhương thức `ensureCapacity()` đảm bảo rằng dung lượng của đối tượng StringBuilder ít nhất bằng với giá trị `minimum` đã cho. Nếu dung lượng hiện tại nhỏ hơn `minimum`, nó sẽ được tăng lên theo công thức `oldCapacity * 2`.\n\nPhương thức `capacity()` trả về dung lượng hiện tại của đối tượng StringBuilder.\n\nPhương thức `reverse()` đảo ngược thứ tự các ký tự trong chuỗi.\n\nPhương thức `delete()` xóa các ký tự trong chuỗi từ chỉ mục `startIndex` đến chỉ mục `endIndex`.\n\nPhương thức `replace()` thay thế các ký tự trong chuỗi từ chỉ mục `startIndex` đến chỉ mục `endIndex` bằng chuỗi đã cho.\n\nPhương thức `insert()` chèn một chuỗi vào chuỗi hiện tại tại vị trí đã cho.\n\nPhương thức `append()` nối một chuỗi vào chuỗi hiện tại.\n\nLớp StringBuilder cũng cung cấp một số phương thức hữu ích khác, chẳng hạn như `substring()`, `charAt()`, `length()`, `indexOf()` và `lastIndexOf()`.class VIETJACK{ public static void main(String args[]){ StringBuffer sb=new\nStringBuffer(\"Hello \"); sb.append(\"Java\");//bay gio chuoi ban dau bi thay doi\nSystem.out.println(sb);//in ra ket qua la Hello Java } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuffer sb=new\nStringBuffer(\"Hello \"); sb.insert(1,\"Java\");//bay gio chuoi ban dau bi thay\ndoi System.out.println(sb);//in ra ket qua la HJavaello } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuffer sb=new\nStringBuffer(\"Hello\"); sb.replace(1,3,\"Java\"); System.out.println(sb);//in ra\nket qua la HJavalo } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuffer sb=new\nStringBuffer(\"Hello\"); sb.delete(1,3); System.out.println(sb);//in ra ket qua\nla Hlo } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuffer sb=new\nStringBuffer(\"Hello\"); sb.reverse(); System.out.println(sb);//in ra ket qua la\nolleH } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuffer sb=new\nStringBuffer(); System.out.println(sb.capacity());//mac dinh la 16\nsb.append(\"Hello\"); System.out.println(sb.capacity());//bay gio la 16\nsb.append(\"Java la mot ngon ngu lap trinh manh me\");\nSystem.out.println(sb.capacity());//bay gio la (16*2)+2=34 vi du cua cong thuc\n(oldcapacity*2)+2 } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuffer sb=new\nStringBuffer(); System.out.println(sb.capacity());//mac dinh la 16\nsb.append(\"Hello\"); System.out.println(sb.capacity());//bay gio la 16\nsb.append(\"Java la mot ngon ngu lap trinh manh me\");\nSystem.out.println(sb.capacity());//bay gio la (16*2)+2=34 vi du cua cong thuc\n(oldcapacity*2)+2 sb.ensureCapacity(10);//bay gio khong phai thay doi\nSystem.out.println(sb.capacity());//bay gio la 34 sb.ensureCapacity(50);//bay\ngio la (34*2)+2 System.out.println(sb.capacity());//bay gio la 70 } }\n\n"
    }
  },
  {
    "id": "85",
    "name": "Lớp StringBuilder",
    "href": "https://www.vietjack.com/java/lop_stringbuilder_trong_java.jsp",
    "lesson": {
      "title": "StringBuilder trong Java",
      "content": "Phương thức ensureCapacity đảm bảo rằng capacity ít nhất bằng với minimum đã cho. Nếu nó lớn hơn capacity hiện tại, nó sẽ tăng capacity theo công thức oldCapacity*2 + 2. Ví dụ, nếu dung lượng hiện tại là 16, nó sẽ là 16*2 + 2 = 34.\n\nPhương thức capacity trả về dung lượng capacity hiện tại của bộ đệm. Dung lượng capacity mặc định của bộ đệm là 16. Nếu số ký tự tăng lên từ dung lượng hiện tại, nó sẽ tăng dung lượng theo công thức oldCapacity*2 + 2. Ví dụ, nếu dung lượng hiện tại là 16, nó sẽ là 16*2 + 2 = 34.\n\nPhương thức reverse đảo ngược chuỗi hiện tại.\n\nPhương thức delete xóa chuỗi bắt đầu từ chỉ mục beginIndex tới endIndex đã cho.\n\nPhương thức replace thay thế chuỗi đã cho bắt đầu từ chỉ mục beginIndex tới endIndex.\n\nPhương thức insert chèn chuỗi đã cho vào chuỗi này tại vị trí đã cho.\n\nPhương thức append được sử dụng để nối chuỗi tham số đã cho với chuỗi này.\n\nBảng dưới đây liệt kê và miêu tả chi tiết một số phương thức quan trọng của lớp StringBuffer trong Java:\n\n| Phương thức | Mô tả |\n|---|---|\n| StringBuilder(int capacity) | Tạo một builder trống với dung lượng capacity đã cho. |\n| StringBuilder(String str) | Tạo một builder với chuỗi đã xác định. |\n| StringBuilder() | Tạo một builder trống với dung lượng capacity ban đầu là 16. |\n\nLớp StringBuilder trong Java được sử dụng để tạo chuỗi có thể thay đổi (chuỗi dạng mutable). Lớp StringBuilder giống như lớp StringBuffer, ngoại trừ rằng nó là không đồng bộ. Lớp này có sẵn từ JDK 1.5.- **append**: Thêm một đối tượng `String` hoặc `StringBuilder` với `StringBuilder` gọi hàm `append()`, tạo ra một đối tượng `StringBuilder` thay đổi.\n\n- **insert**: Chén một đối tượng `String` hoặc `StringBuilder` với `StringBuilder` gọi hàm `insert()`, tạo ra một đối tượng `StringBuilder` thay đổi.\n\n- **replace**: Thay đổi một đoạn `StringBuilder` gọi hàm `replace()`, tạo ra một đối tượng `StringBuilder` thay đổi.\n\n- **delete**: Xó một đoạn `StringBuilder` gọi hàm `delete()`, tạo ra một đối tượng `StringBuilder` thay đổi.\n\n- **reserve**: Đảo ngược `StringBuilder` gọi hàm `reserve()`, tạo ra một đối tượng `StringBuilder` thay đổi.\n\n- **capacity**: Trả vè dung lương `StringBuilder` gọi hàm `capacity()`, trả vè một đối tượng `int` không thay đổi.\n\n- **ensurCapacity**: Đảo bảo dung lương của `StringBuilder` gọi hàm `ensurCapacity()`, tạo ra một đối tượng `StringBuilder` thay đổi.\n\n- **charAT**: Trả vè ký tứ thứ `index` trong `StringBuilder` gọi hàm `charAT()`, trả vè một đối tượng `char` không thay đổi.\n\n- **length**: Trả vè độ dài `StringBuilder` gọi hàm `length()`, trả vè một đối tượng `int` không thay đổi.\n\n- **subString**: Trả vè một đối tượng `String` không thay đổi, tạo ra một đối tượng `StringBuilder` gọi hàm `subString()`, bắt dầu từ `beginIndex` và chạy tới hết.\n\n- **subString**: Trả vè một đối tượng `String` không thay đổi, tạo ra một đối tượng `StringBuilder` gọi hàm `subString()`, bắt dầu từ `beginIndex` và chạy tới `endIndex` không thay đổi.class VIETJACK{ public static void main(String args[]){ StringBuilder sb=new\nStringBuilder(\"Hello \"); sb.append(\"Java\");//bay gio chuoi ban dau bi thay doi\nSystem.out.println(sb);//in ra ket qua la Hello Java } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuilder sb=new\nStringBuilder(\"Hello \"); sb.insert(1,\"Java\");//bay gio chuoi ban dau bi thay\ndoi System.out.println(sb);//in ra ket qua la HJavaello } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuilder sb=new\nStringBuilder(\"Hello\"); sb.replace(1,3,\"Java\"); System.out.println(sb);//in ra\nket qua la HJavalo } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuilder sb=new\nStringBuilder(\"Hello\"); sb.delete(1,3); System.out.println(sb);//in ra ket qua\nla Hlo } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuilder sb=new\nStringBuilder(\"Hello\"); sb.reverse(); System.out.println(sb);//in ra ket qua\nla olleH } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuilder sb=new\nStringBuilder(); System.out.println(sb.capacity());//mac dinh la 16\nsb.append(\"Hello\"); System.out.println(sb.capacity());//bay gio la 16\nsb.append(\"Java la mot ngon ngu lap trinh manh me\");\nSystem.out.println(sb.capacity());//bay gio la (16*2)+2=34 vi du cua cong thuc\n(oldcapacity*2)+2 } }\n\n, class VIETJACK{ public static void main(String args[]){ StringBuilder sb=new\nStringBuilder(); System.out.println(sb.capacity());//mac dinh la 16\nsb.append(\"Hello\"); System.out.println(sb.capacity());//bay gio la 16\nsb.append(\"Java la mot ngon ngu lap trinh manh me\");\nSystem.out.println(sb.capacity());//bay gio la (16*2)+2=34 vi du cua cong thuc\n(oldcapacity*2)+2 sb.ensureCapacity(10);//bay gio khong phai thay doi\nSystem.out.println(sb.capacity());//bay gio la 34 sb.ensureCapacity(50);//now\n(34*2)+2 System.out.println(sb.capacity());//bay gio la 70 } }\n\n"
    }
  },
  {
    "id": "95",
    "name": "String vs StringBuffer",
    "href": "https://www.vietjack.com/java/so_sanh_lop_string_va_stringbuffer_trong_java.jsp",
    "lesson": {
      "title": "So sánh lớp String và StringBuffer trong Java",
      "content": "Có nhiều điểm khác biệt giữa lớp String và StringBuffer trong Java. Bảng sau liệt kê các điểm khác biệt chính:\n\n| Đặc điểm | String | StringBuffer |\n|---|---|---|\n| Khả năng thay đổi | Không | Có |\n| Hiệu suất | Nhanh hơn | Chậm hơn |\n| Độ an toàn luồng | An toàn luồng | Không an toàn luồng |\n| Dung lượng | Không thay đổi được | Có thể thay đổi được |\n| Phương thức | Có nhiều phương thức hơn | Ít phương thức hơn |\n| Sử dụng | Thích hợp cho các chuỗi không thay đổi | Thích hợp cho các chuỗi thay đổi thường xuyên |Lớp String và StringBuffer là hai lớp đại diện cho chuỗi ký tự trong Java.\n\nLớp String là lớp không thể thay đổi, nghĩa là nội dung của chuỗi không thể được thay đổi sau khi đã được tạo. Lớp StringBuffer là lớp có thể thay đổi, nghĩa là nội dung của chuỗi có thể được thay đổi sau khi đã được tạo.\n\nLớp String chậm hơn và tiêu tốn nhiều bộ nhớ hơn khi nối nhiều chuỗi, vì mỗi lần nối chuỗi, nó sẽ tạo một đối tượng String mới. Lớp StringBuffer nhanh hơn và tiêu tốn ít bộ nhớ hơn khi nối các chuỗi, vì nó không tạo đối tượng String mới mỗi lần nối chuỗi.\n\nLớp String ghi đè phương thức equals() của lớp Object, vì vậy bạn có thể so sánh nội dung của hai chuỗi bằng phương thức equals(). Lớp StringBuffer không ghi đè phương thức equals() của lớp Object, vì vậy bạn không thể so sánh nội dung của hai chuỗi bằng phương thức equals().public class Test1{ public static String concatWithString() { String t =\n\"Java\"; for (int i=0; i<10000; i++){ t = t + \"Vietjack\"; } return t; } public\nstatic String concatWithStringBuffer(){ StringBuffer sb = new\nStringBuffer(\"Java\"); for (int i=0; i<10000; i++){ sb.append(\"Vietjack\"); }\nreturn sb.toString(); } public static void main(String[] args){ long startTime\n= System.currentTimeMillis(); concatWithString(); System.out.println(\"Thoi\ngian tieu ton boi noi chuoi voi String:\n\"+(System.currentTimeMillis()-startTime)+\"ms\"); startTime =\nSystem.currentTimeMillis(); concatWithStringBuffer(); System.out.println(\"Thoi\ngian tieu ton boi noi chuoi voi StringBuffer:\n\"+(System.currentTimeMillis()-startTime)+\"ms\"); } }\n\n, Thoi gian tieu ton boi noi chuoi voi String: 578ms Thoi gian tieu ton boi noi\nchuoi voi StringBuffer: 0ms\n\n, public class Test2{ public static void main(String args[]){\nSystem.out.println(\"Kiem tra Hashcode cua String:\"); String str=\"java\";\nSystem.out.println(str.hashCode()); str=str+\"tpoint\";\nSystem.out.println(str.hashCode()); System.out.println(\"Kiem tra Hashcode cua\nStringBuffer:\"); StringBuffer sb=new StringBuffer(\"java\");\nSystem.out.println(sb.hashCode()); sb.append(\"tpoint\");\nSystem.out.println(sb.hashCode()); } }\n\n, Kiem tra Hashcode cua String: 3254818 229541438 Kiem tra Hashcode cua\nStringBuffer: 118352462 118352462\n\n"
    }
  },
  {
    "id": "105",
    "name": "StringBuilder vs StringBuffer",
    "href": "https://www.vietjack.com/java/so_sanh_lop_stringbuffer_va_stringbuilder_trong_java.jsp",
    "lesson": {
      "title": "So sánh lớp StringBuffer và StringBuilder trong Java",
      "content": "Để so sánh hiệu suất của lớp StringBuilder và lớp StringBuffer trong Java, bạn có thể thực hiện một ví dụ đơn giản như sau:\n\nTạo một chuỗi ký tự rỗng ban đầu bằng cả hai lớp StringBuilder và StringBuffer.\n\nSử dụng phương thức append() của cả hai lớp để thêm các ký tự vào chuỗi ký tự.\n\nLặp lại bước 2 nhiều lần để thêm một số lượng lớn ký tự vào chuỗi ký tự.\n\nSử dụng phương thức toString() của cả hai lớp để chuyển đổi chuỗi ký tự thành chuỗi thông thường.\n\nSo sánh thời gian thực hiện của cả hai lớp bằng cách sử dụng phương thức System.currentTimeMillis().\n\nKết quả của ví dụ này sẽ cho bạn biết lớp nào có hiệu suất tốt hơn trong việc thao tác với chuỗi ký tự lớn.\n\nNgoài ra, bạn cũng có thể tham khảo bảng dưới đây để biết thêm về sự khác biệt giữa lớp String và lớp StringBuffer trong Java:\n\n| Tính chất | String | StringBuffer | StringBuilder |\n|---|---|---|---|\n| Khả năng thay đổi | Không | Có | Có |\n| Hiệu suất | Chậm | Nhanh | Nhanh nhất |\n| Đồng bộ | Có | Có | Không |\n| Dung lượng | Không cố định | Có thể thay đổi | Có thể thay đổi |\n| Sử dụng | Sử dụng khi chuỗi không thay đổi | Sử dụng khi chuỗi thay đổi ít | Sử dụng khi chuỗi thay đổi nhiều |- Lớp StringBuffer được thiết kế để an toàn với luồng, trong khi StringBuilder thì không. Điều này có nghĩa là StringBuffer có thể được sử dụng trong các ứng dụng đa luồng mà không cần lo lắng về việc truy cập đồng thời vào dữ liệu. Tuy nhiên, điều này cũng khiến StringBuffer kém hiệu quả hơn StringBuilder.\n- StringBuilder là lớp thay thế cho StringBuffer. Nó không được đồng bộ, do đó, nó không an toàn với luồng. Tuy nhiên, điều này cũng khiến StringBuilder hiệu quả hơn StringBuffer.public class BufferTest{ public static void main(String[] args){ StringBuffer\nbuffer=new StringBuffer(\"hello\"); buffer.append(\"java\");\nSystem.out.println(buffer); } }\n\n, hellojava\n\n, public class BuilderTest{ public static void main(String[] args){\nStringBuilder builder=new StringBuilder(\"hello\"); builder.append(\"java\");\nSystem.out.println(builder); } }\n\n, hellojava\n\n, public class ConcatTest{ public static void main(String[] args){ long\nstartTime = System.currentTimeMillis(); StringBuffer sb = new\nStringBuffer(\"Java\"); for (int i=0; i<10000; i++){ sb.append(\"Vietjack\"); }\nSystem.out.println(\"Thoi gian tieu ton boi StringBuffer: \" +\n(System.currentTimeMillis() - startTime) + \"ms\"); startTime =\nSystem.currentTimeMillis(); StringBuilder sb2 = new StringBuilder(\"Java\"); for\n(int i=0; i<10000; i++){ sb2.append(\"Vietjack\"); } System.out.println(\"Thoi\ngian tieu ton boi StringBuilder: \" + (System.currentTimeMillis() - startTime)\n+ \"ms\"); } }\n\n, Time taken by StringBuffer: 16ms Time taken by StringBuilder: 0ms\n\n"
    }
  },
  {
    "id": "115",
    "name": "Tạo Immutable String",
    "href": "https://www.vietjack.com/java/tao_immutable_string_trong_java.jsp",
    "lesson": {
      "title": "Tạo lớp Immutable trong Java",
      "content": "* Lớp `Employee` là lớp immutable vì nó có các đặc điểm sau:\n    * Lớp được khai báo là `final`, do đó không thể tạo lớp con.\n    * Các biến instance của lớp được khai báo là `final`, do đó không thể thay đổi giá trị của chúng sau khi đối tượng được tạo.\n    * Lớp không có phương thức setter, do đó không có cách nào để thay đổi giá trị của các biến instance.\n* Các lớp immutable có nhiều lợi thế, chẳng hạn như:\n    * Chúng an toàn hơn vì không thể thay đổi trạng thái của chúng sau khi được tạo.\n    * Chúng dễ dàng hơn để lý luận về tính đúng đắn của chúng vì hành vi của chúng được xác định rõ ràng.\n    * Chúng dễ dàng hơn để kiểm thử vì không có tác dụng phụ nào có thể ảnh hưởng đến kết quả của các bài kiểm tra.\n* Một số lớp immutable trong Java bao gồm:\n    * `String`\n    * `Boolean`\n    * `Byte`\n    * `Short`\n    * `Integer`\n    * `Long`\n    * `Float`\n    * `Double`\n* Bạn cũng có thể tạo các lớp immutable của riêng mình bằng cách tạo một lớp `final` có các biến instance `final` và không có phương thức setter.public final class Employee{ final String IDno; public Employee(String IDno){\nthis.IDno=IDno; } public String getIDno(){ return IDno; } }\n\n"
    }
  },
  {
    "id": "125",
    "name": "Phương thức toString()",
    "href": "https://www.vietjack.com/java/string_tostring_trong_java.jsp",
    "lesson": {
      "title": "String toString() trong Java",
      "content": "Phương thức `toString()` trả về biểu diễn chuỗi của đối tượng. Trong Java, khi bạn cố gắng in một đối tượng, trình biên dịch sẽ tự động gọi phương thức `toString()` của đối tượng đó. Nếu bạn không ghi đè phương thức `toString()`, trình biên dịch sẽ sử dụng phương thức `toString()` mặc định của lớp `Object`, trả về tên lớp và mã băm của đối tượng.\n\nĐể ghi đè phương thức `toString()`, bạn chỉ cần tạo một phương thức `toString()` trong lớp của mình và ghi đè phương thức `toString()` của lớp `Object`. Trong phương thức `toString()` đã ghi đè, bạn có thể trả về bất kỳ chuỗi nào bạn muốn để đại diện cho đối tượng của mình.\n\nGhi đè phương thức `toString()` rất hữu ích khi bạn muốn in các đối tượng của mình theo một cách cụ thể. Ví dụ, bạn có thể ghi đè phương thức `toString()` để trả về trạng thái hiện tại của đối tượng hoặc để trả về một chuỗi đại diện cho đối tượng theo một định dạng cụ thể.\n\nĐây là một ví dụ về cách ghi đè phương thức `toString()` trong Java:\n\n```java\npublic class Person {\n\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person [name=\" + name + \", age=\" + age + \"]\";\n    }\n\n}\n```\n\nTrong ví dụ này, lớp `Person` có hai trường là `name` và `age`. Phương thức `toString()` đã ghi đè trả về một chuỗi đại diện cho đối tượng `Person`, bao gồm tên và tuổi của người đó.\n\nKhi bạn in một đối tượng `Person`, trình biên dịch sẽ tự động gọi phương thức `toString()` của đối tượng đó. Điều này sẽ trả về chuỗi đại diện cho đối tượng `Person`, bao gồm tên và tuổi của người đó.public class Test { public static void main(String args[]) { String Str = new\nString(\"Chao mung ban den voi Vietjack.com\"); System.out.print(\"Gia tri tra ve\nla :\"); System.out.println(Str.toString()); } }\n\n, Gia tri tra ve la :Chao mung ban den voi Vietjack.com\n\n, class Student{ int masv; String ten; String tinh; Student(int masv, String\nten, String tinh){ this.masv=masv; this.ten=ten; this.tinh=tinh; } public\nString toString(){//ghi de phuong thuc toString() return masv+\" \"+ten+\"\n\"+tinh; } public static void main(String args[]){ Student s1=new\nStudent(101,\"Hoang\",\"HaNoi\"); Student s2=new Student(102,\"Thanh\",\"HaiPhong\");\nSystem.out.println(s1);//compiler se viet o day la s1.toString()\nSystem.out.println(s2);//compiler se viet o day la s2.toString() } }\n\n, 101 Hoang HaNoi 102 Thanh HaiPhong\n\n"
    }
  },
  {
    "id": "135",
    "name": "Lớp StringTokenizer",
    "href": "https://www.vietjack.com/java/lop_stringtokenizer_trong_java.jsp",
    "lesson": {
      "title": "Lớp StringTokenizer trong Java",
      "content": "Lớp String Tokenizer là một lớp cũ trong Java dùng để chia một chuỗi thành các token nhỏ. Tuy nhiên, hiện tại, bạn nên sử dụng phương thức split của lớp String hoặc biểu thức chính quy (regex) để thực hiện tác vụ này.\n\nLớp String Tokenizer có 6 phương thức hữu ích và 3 constructor. Bạn có thể sử dụng lớp này để chia một chuỗi thành các token dựa trên các khoảng trắng hoặc các ký tự phân tách khác.\n\nVí dụ:\n\n```java\nString str = \"Tôi làm việc tại Hà Nội\";\nString[] tokens = str.split(\" \");\n\nfor (String token : tokens) {\n  System.out.println(token);\n}\n```\n\nKết quả:\n\n```\nTôi\nlàm\nviệc\ntại\nHà\nNội\n```**Tạo đối tượng StringTokenizer:**\n\n- `StringTokenizer(String str)`: Tạo một đối tượng `StringTokenizer` mới với chuỗi `str` và sử dụng dấu phân tách mặc định là khoảng trắng.\n\n- `StringTokenizer(String str, String delim)`: Tạo một đối tượng `StringTokenizer` mới với chuỗi `str` và sử dụng chuỗi `delim` làm dấu phân tách.\n\n- `StringTokenizer(String str, String delim, boolean returnValue)`: Tạo một đối tượng `StringTokenizer` mới với chuỗi `str`, sử dụng chuỗi `delim` làm dấu phân tách và tùy chọn `returnValue` để chỉ định cách xử lý các dấu phân tách.\n\n**Các phương thức công khai:**\n\n- `boolean hasMoreTokens()`: Kiểm tra xem còn token nào nữa không.\n\n- `String nextToken()`: Trả về token tiếp theo.\n\n- `String nextToken(String delim)`: Trả về token tiếp theo dựa trên dấu phân tách `delim`.\n\n- `boolean hasMoreElements()`: Giống như `hasMoreTokens()`.\n\n- `Object nextElement()`: Giống như `nextToken()` nhưng trả về một đối tượng `Object`.\n\n- `int countTokens()`: Trả về tổng số token.import java.util.StringTokenizer; public class Simple{ public static void\nmain(String args[]){ StringTokenizer st = new StringTokenizer(\"Toi lam viec o\nHaNoi\",\" \"); while (st.hasMoreTokens()) { System.out.println(st.nextToken());\n} } }\n\n, Toi lam viec o HaNoi\n\n, import java.util.*; public class Test { public static void main(String[] args)\n{ StringTokenizer st = new StringTokenizer(\"Toi,lam,viec,o,HaNoi\"); // in ra\ntoken tiep theo System.out.println(\"Token tiep theo la : \" +\nst.nextToken(\",\")); } }\n\n, Token tiep theo la : Toi\n\n"
    }
  },
  {
    "id": "16",
    "name": "Exception là gì",
    "href": "https://www.vietjack.com/java/exception_trong_java.jsp",
    "lesson": {
      "title": "Exception trong Java",
      "content": " dự dự với dữ liệu về cho ra ý gì đó do quá nhiều kết quả quá lý về dữ1. Phương thức `getMessage()` trả về một thông báo cụ thể về ngoại lệ đã xảy ra. Thông báo này được khởi tạo bởi phương thức khởi tạo của `Throwable`.\n\n\n2. Phương thức `getCause()` trả về nguyên nhân gây ra ngoại lệ được biểu diễn bởi đối tượng `Throwable`.\n\n\n3. Phương thức `toString()` trả về tên của lớp và kết hợp với kết quả từ phương thức `getMessage()`.\n\n\n4. Phương thức `printStackTrace()` in ra kết quả của phương thức `toString()` cùng với dấu vết ngăn xếp đến `System.err`.\n\n\n5. Phương thức `getStackTrace()` trả về một mảng chứa từng phần tử trên dấu vết ngăn xếp. Phần tử tại chỉ mục 0 biểu diễn phần trên cùng của ngăn xếp gọi, và phần tử cuối cùng trong mảng biểu diễn phương thức tại dưới cùng của ngăn xếp gọi.\n\n\n6. Phương thức `fillInStackTrace()` điền dấu vết ngăn xếp của đối tượng `Throwable` này bằng dấu vết ngăn xếp hiện tại, thêm vào bất kỳ thông tin nào trước đó trong dấu vết ngăn xếp.statement 1; statement 2; statement 3; statement 4; statement 5;//exception\nxuat hien statement 6; statement 7; statement 8; statement 9; statement 10;\n\n, int a=50/0;//ArithmeticException\n\n, String s=null; System.out.println(s.length());//NullPointerException\n\n, String s=\"abc\"; int i=Integer.parseInt(s);//NumberFormatException\n\n, int a[]=new int[5]; a[10]=50; //ArrayIndexOutOfBoundsException\n\n"
    }
  },
  {
    "id": "26",
    "name": "Khối try-catch",
    "href": "https://www.vietjack.com/java/khoi_try_catch_trong_java.jsp",
    "lesson": {
      "title": "Khối try-catch trong Java",
      "content": "Trong lập trình Java, xử lý exception là một phần thiết yếu để đảm bảo tính ổn định và an toàn của ứng dụng. Exception là những tình huống bất thường xảy ra trong quá trình chạy chương trình, có thể gây ra lỗi và làm dừng chương trình. Để xử lý các exception, Java cung cấp cơ chế try-catch-finally.\n\nKhối try được sử dụng để bao quanh code có khả năng gây ra exception. Khi exception xảy ra trong khối try, nó sẽ được chuyển đến khối catch tương ứng để xử lý. Khối catch phải được đặt ngay sau khối try. Có thể có nhiều khối catch khác nhau để xử lý các loại exception khác nhau.\n\nKhối finally được sử dụng để thực hiện các tác vụ dọn dẹp, chẳng hạn như đóng các kết nối tài nguyên hoặc giải phóng bộ nhớ. Khối finally luôn được thực hiện, bất kể có exception xảy ra hay không.\n\nKhi exception xảy ra, JVM sẽ kiểm tra xem có khối catch nào phù hợp với loại exception đó không. Nếu có, khối catch đó sẽ được thực hiện và chương trình sẽ tiếp tục chạy. Nếu không có khối catch nào phù hợp, JVM sẽ cung cấp một trình xử lý exception mặc định để thực hiện các tác vụ dọn dẹp và dừng chương trình.\n\nĐể sử dụng try-catch-finally, bạn có thể làm như sau:\n\n```java\ntry {\n  // Code có thể gây ra exception\n} catch (Exception1 e) {\n  // Xử lý exception loại Exception1\n} catch (Exception2 e) {\n  // Xử lý exception loại Exception2\n} finally {\n  // Thực hiện các tác vụ dọn dẹp\n}\n```\n\nNgoài ra, bạn cũng có thể sử dụng khối try lồng nhau để xử lý các exception khác nhau trong các phần khác nhau của code.try{ //code ma co the nem exception }catch(Exception_class_Name ref){}\n\n, try{ //code ma co the nem exception }finally{}\n\n, public class Testtrycatch1{ public static void main(String args[]){ int\ndata=50/0;//co the nem exception System.out.println(\"Phan code con lai...\"); }\n}\n\n, Exception in thread \"main\" java.lang.ArithmeticException: / by zero\n\n, public class Testtrycatch2{ public static void main(String args[]){ try{ int\ndata=50/0; }catch(ArithmeticException e){System.out.println(e);}\nSystem.out.println(\"Phan code con lai...\"); } }\n\n, java.lang.ArithmeticException: / by zero Phan code con lai...\n\n, public class TestMultiCatchBlock{ public static void main(String args[]){ try{\nint a[]=new int[5]; a[5]=30/0; } catch(ArithmeticException\ne){System.out.println(\"Task1 duoc hoan thanh\");}\ncatch(ArrayIndexOutOfBoundsException e){System.out.println(\"Task2 duoc hoan\nthanh\");} catch(Exception e){System.out.println(\"Task chung duoc hoan\nthanh\");} System.out.println(\"Phan code con lai...\"); } }\n\n, Task1 duoc hoan thanh Phan code con lai...\n\n, class TestMultipleCatchBlock1{ public static void main(String args[]){ try{\nint a[]=new int[5]; a[5]=30/0; } catch(Exception e){System.out.println(\"Task\nchung duoc hoan thanh\");} catch(ArithmeticException\ne){System.out.println(\"Task1 duoc hoan thanh\");}\ncatch(ArrayIndexOutOfBoundsException e){System.out.println(\"Task2 duoc hoan\nthanh\");} System.out.println(\"Phan code con lai...\"); } }\n\n, .... try { lenh 1; lenh 2; try { lenh 1; lenh 2; } catch(Exception e) { } }\ncatch(Exception e) { } ....\n\n, class Excep6{ public static void main(String args[]){ try{ try{\nSystem.out.println(\"Thuc hien phep chia\"); int b =39/0;\n}catch(ArithmeticException e){System.out.println(e);} try{ int a[]=new int[5];\na[5]=4; }catch(ArrayIndexOutOfBoundsException e){System.out.println(e);}\nSystem.out.println(\"Lenh khac\"); }catch(Exception e){System.out.println(\"Da xu\nly\");} System.out.println(\"Luong chuan..\"); } }\n\n, Thuc hien phep chia java.lang.ArithmeticException: / by zero\njava.lang.ArrayIndexOutOfBoundsException: 5 Lenh khac Luong chuan..\n\n"
    }
  }
]
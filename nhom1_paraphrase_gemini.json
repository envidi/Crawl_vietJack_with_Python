[
  {
    "id": "11",
    "name": "Khóa học Offline tại Hà Nội",
    "href": "https://www.vietjack.com/java/khoa-hoc-java-offline.jsp",
    "lesson": {
      "title": "khóa học java chất lượng cao tại imta",
      "content": "- Khóa học Java offline do imtateam tổ chức tại Hà Nội.\n\n- Khóa học dành cho những người muốn trở thành lập trình viên chuyên nghiệp, những người muốn tìm hiểu Java để học tiếp Android hoặc Java web, những người chuẩn bị tham gia các kỳ phỏng vấn xin việc.\n\n- Yêu cầu đầu vào: biết trước ít nhất một ngôn ngữ lập trình bất kỳ (C, C++, Java, Python, C#).\n\n- Khóa học có 15 buổi, học vào thứ 6 hàng tuần.\n\n- Học phí: 2.500.000 đồng.\n\n- Giảng viên: anh Nguyễn Thanh Tuyền, cựu sinh viên kỹ sư tài năng Đại học Bách khoa Hà Nội, hiện đang làm Senior Java Developer tại công ty phần mềm Citigo.\n\n- Khóa học sẽ khai giảng vào cuối tháng 10/2018.\n\n- Đăng ký giữ chỗ: gọi 01689933602 hoặc gửi yêu cầu đến email imtateam@gmail.com.\n\n- Khóa học sẽ hỗ trợ kiến thức về Java đến khi đi làm việc.\n\n- Học viên sẽ được miễn phí khóa học Java online của imtateam trên Udemy và hơn 10 khóa học trả phí khác.\n\n- Khóa học sẽ tập trung vào các dự án thực hành và phỏng vấn hướng tới đi làm.",
      "id": "111"
    }
  },
  {
    "id": "21",
    "name": "Khóa học Java Online tại Udemy",
    "href": "https://www.vietjack.com/java/khoa-hoc-java-online.jsp",
    "lesson": {
      "title": "khóa học java online trên udemy",
      "content": "Khóa học này dành cho những bạn sinh viên và những bạn đi làm có ít hơn nửa năm kinh nghiệm về Java. Khóa học sẽ giúp các bạn dễ dàng hoàn thành dự án ở trường và tự tin khi đi phỏng vấn vào các vị trí lập trình viên Java tại các công ty tập đoàn. Khóa học được đánh giá 475 bởi các bạn học viên, mặc dù còn một số thiếu sót về phần âm thanh. Khóa học bao gồm gần 100 video, các bạn có thể xem đi xem lại nhiều lần vào thời gian rảnh. Các bạn có thể mua khóa học với giá 250.000đ hoặc 300.000đ qua thẻ Viettel. Trong 30 ngày mua khóa học, nếu các bạn không hài lòng có thể yêu cầu lấy lại tiền.",
      "id": "211"
    }
  },
  {
    "id": "12",
    "name": "Giới thiệu Java",
    "href": "https://www.vietjack.com/java/index.jsp",
    "lesson": {
      "title": "học java cơ bản và nâng cao",
      "content": "Bài giảng này sẽ giúp bạn hiểu sâu hơn về các khái niệm được trình bày trong loạt bài hướng dẫn về Java của chúng tôi. Chúng tôi cung cấp hơn 250 ví dụ Java phổ biến để bạn tham khảo và dễ dàng hơn khi học. Loạt bài hướng dẫn của chúng tôi dựa trên nguồn tài liệu của Tutorialspoint.\n\nChúng tôi sẽ giới thiệu cho bạn các bài hướng dẫn học Java cơ bản và nâng cao miễn phí trên website của chúng tôi, bao gồm các chủ đề như:\n- Collection trong Java: Thực hành bài tập quản lý việc đặt ghế trong rạp phim\n- Collection Set trong Java: Ý nghĩa hàm hashCode và equals trong Java\n- Xử lý Blob Data: Cách ghi dữ liệu file vào database trong JDBC\n- Package: Cách tạo file JAR, import file JAR trong Java\n- Constructor 2: Thực hành quản lý tài khoản ngân hàng\n- Vòng lặp trong Java với các bài toán hình đặc biệt\n- Regular Expression trong Java: Cách validate email và cách dùng trường đặc biệt\n\nChúng tôi cũng cung cấp 8 video miễn phí để bạn xem thử và quyết định xem có nên tham gia khóa học trực tuyến hoặc ngoại tuyến tại Hà Nội của chúng tôi hay không. Bạn có thể xem video demo tại địa chỉ video demo.\n\nNếu bạn ở xa hoặc không có điều kiện thời gian, bạn có thể tham dự khóa học Java trực tuyến để chủ động cho việc học tập trong năm 2018. Giá khóa học chỉ còn 200k. Hãy liên hệ với chúng tôi qua Facebook admin fb.com/tuyenimta để thanh toán chuyển khoản hoặc thẻ điện thoại.\n\nKhóa học bằng tiếng Việt với gần 100 video, bạn có thể chủ động học bất cứ lúc nào và xem mãi mãi. Thông tin khóa học tại khóa học Java trực tuyến trên Udemy.\n\nNếu bạn ở Hà Nội, bạn có thể xem các bạn khóa 6 được học gì, các bạn khóa 7 đang tuyển sinh đến ngày 20/06. Chúng tôi sẽ làm lớn hơn các dự án nhé. Xem video một phần các dự án khóa 6.\n\nJava là một trong những ngôn ngữ được dùng phổ biến nhất trên thế giới vào năm 2018, đặc biệt là cho các ứng dụng web client-server. Theo thống kê, trên thế giới có khoảng 9 triệu lập trình viên Java. Java là ngôn ngữ lập trình máy tính có tính chất hướng đối tượng dựa trên các lớp, thường được sử dụng cho các hệ thống có tính độc lập cao. Nó được sử dụng để hướng tới các lập trình viên viết ứng dụng \"write one run everywhere\" (viết một lần chạy mọi nơi), nghĩa là đoạn code Java sau khi được biên dịch có thể chạy được trên tất cả các nền tảng hỗ trợ Java mà không cần phải được biên dịch lại. Các ứng dụng Java sau khi đã được biên dịch thành bytecode có thể chạy trên bất kỳ máy ảo Java nào (Java Virtual Machine).",
      "id": "121"
    }
  },
  {
    "id": "22",
    "name": "Java là gì?",
    "href": "https://www.vietjack.com/java/java_la_gi.jsp",
    "lesson": {
      "title": "java là gì",
      "content": "Java có thể được sử dụng để tạo ra nhiều loại ứng dụng khác nhau, bao gồm:\n\n* Ứng dụng dành cho thiết bị di động: Các ứng dụng này được tạo bằng Android hoặc Java và thường có tính bảo mật cao và khả năng cân bằng tải.\n* Ứng dụng doanh nghiệp: Các ứng dụng này được tạo bằng Java EE và thường chạy trên máy chủ để tạo ra các trang web động.\n* Ứng dụng web: Các ứng dụng này được tạo bằng các công nghệ như Servlet, JSP, Struts và JSF và thường chạy trên máy chủ để tạo ra các trang web động.\n* Ứng dụng độc lập: Các ứng dụng này cần được cài đặt trên từng thiết bị và thường được tạo bằng AWT và Swing.\n\nJava cũng có thể được sử dụng để tạo ra các nền tảng, là môi trường phần cứng hoặc phần mềm mà chương trình chạy. Java Runtime Environment (JRE) và Java API là những nền tảng như vậy.\n\nJava là một ngôn ngữ lập trình bảo mật cao, hướng đối tượng, cấp cao và mạnh mẽ. Nó là một ngôn ngữ lập trình và một nền tảng.class Simple{ public static void main(String args[]){\nSystem.out.println(\"Hello World\"); } }\n\n",
      "id": "221"
    }
  },
  {
    "id": "32",
    "name": "Lịch sử Java",
    "href": "https://www.vietjack.com/java/lich_su_java.jsp",
    "lesson": {
      "title": "lịch sử java",
      "content": "Java là một ngôn ngữ lập trình phổ biến được phát triển bởi James Gosling và nhóm của ông tại Sun Microsystems vào năm 1995. Tên \"Java\" được lấy cảm hứng từ một loại cà phê được sản xuất tại đảo Java của Indonesia. Ban đầu, Java được gọi là Oak, nhưng sau đó được đổi tên để tránh nhầm lẫn với một ngôn ngữ lập trình khác có tên tương tự.\n\nJava được thiết kế để chạy trên nhiều nền tảng khác nhau, bao gồm Windows, macOS, Linux và Android. Điều này làm cho Java trở thành một ngôn ngữ lý tưởng cho các ứng dụng di động, ứng dụng web và các hệ thống nhúng.\n\nJava là một ngôn ngữ lập trình hướng đối tượng, có nghĩa là nó tập trung vào các đối tượng và các tương tác giữa chúng. Java cũng là một ngôn ngữ lập trình biên dịch, có nghĩa là mã nguồn Java được biên dịch thành mã máy trước khi được thực thi. Điều này làm cho Java chạy nhanh hơn so với các ngôn ngữ lập trình thông dịch, chẳng hạn như Python và Ruby.\n\nJava là một ngôn ngữ lập trình mạnh mẽ và linh hoạt, có thể được sử dụng để phát triển nhiều loại ứng dụng khác nhau. Một số ứng dụng phổ biến được viết bằng Java bao gồm:\n\n* Các ứng dụng web, chẳng hạn như Google Chrome, Firefox và Internet Explorer\n* Các ứng dụng di động, chẳng hạn như Android và iOS\n* Các hệ thống nhúng, chẳng hạn như máy ATM và máy bán hàng tự động\n* Các ứng dụng máy tính để bàn, chẳng hạn như Microsoft Office và Adobe Photoshop\n\nJava là một ngôn ngữ lập trình phổ biến và được sử dụng rộng rãi trên toàn thế giới. Nó là một ngôn ngữ mạnh mẽ và linh hoạt, có thể được sử dụng để phát triển nhiều loại ứng dụng khác nhau.",
      "id": "321"
    }
  },
  {
    "id": "42",
    "name": "Tổng quan",
    "href": "https://www.vietjack.com/java/tong_quan_ve_java.jsp",
    "lesson": {
      "title": "tổng quan về java",
      "content": "- Một thread là một chương trình riêng rẽ chạy song song với các chương trình khác.\n- Java hỗ trợ đa luồng, cho phép xử lý nhiều tác vụ cùng lúc.\n- Java sử dụng bộ nhớ chia sẻ giữa các thread.\n- Java phù hợp cho các ứng dụng đa phương tiện, ứng dụng web và các ứng dụng phân tán.\n- Java sử dụng trình biên dịch JIT (Just-In-Time) để cải thiện hiệu suất.\n- Java có tính năng debug dễ dàng và phát hiện lỗi nhanh chóng.\n- Java là ngôn ngữ độc lập nền tảng, có thể chạy trên nhiều hệ điều hành khác nhau.\n- Java có tính mạnh mẽ (robust) nhờ hệ quản lý bộ nhớ mạnh mẽ, trình dọn rác tự động, xử lý ngoại lệ và kiểm tra kiểu.\n- Java cung cấp nhiều tính năng bảo mật như SSL, JAAS và Security Manager.\n- Java là ngôn ngữ hướng đối tượng, đơn giản và dễ học.\n- Java có nhiều đặc điểm nổi bật như phân tán, đa luồng, hiệu suất cao, thông dịch, động, di động, độc lập cấu trúc, mạnh mẽ, bảo mật, độc lập nền tảng và hướng đối tượng.",
      "id": "421"
    }
  },
  {
    "id": "52",
    "name": "Cài đặt Java",
    "href": "https://www.vietjack.com/java/cai_dat_java.jsp",
    "lesson": {
      "title": "cài đặt môi trường java",
      "content": "1. **Tải và cài đặt Java:**\n    - Truy cập trang web chính thức của Java và tải xuống phiên bản Java phù hợp với hệ điều hành của bạn.\n    - Chạy trình cài đặt Java và làm theo hướng dẫn trên màn hình.\n\n2. **Thiết lập biến môi trường:**\n    - Trên Windows:\n        - Nhấp chuột phải vào \"My Computer\" và chọn \"Properties\".\n        - Chọn tab \"Advanced\" và nhấp vào nút \"Environment Variables\".\n        - Trong mục \"User Variables\", tạo biến mới có tên \"JAVA_HOME\" và đặt giá trị là đường dẫn đến thư mục cài đặt Java.\n        - Trong mục \"System Variables\", tạo biến mới có tên \"Path\" và thêm đường dẫn đến thư mục \"%JAVA_HOME%\\bin\" vào cuối giá trị hiện tại.\n    - Trên macOS:\n        - Mở Terminal và nhập lệnh sau:\n            ```\n            export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-17.0.2.jdk/Contents/Home\n            ```\n            (Thay thế \"jdk-17.0.2.jdk\" bằng phiên bản Java mà bạn đã cài đặt.)\n        - Thêm dòng sau vào cuối tệp \"~/.bash_profile\":\n            ```\n            export PATH=$JAVA_HOME/bin:$PATH\n            ```\n\n3. **Kiểm tra cài đặt Java:**\n    - Mở Terminal hoặc Command Prompt và nhập lệnh sau:\n        ```\n        java -version\n        ```\n    - Nếu bạn thấy thông tin về phiên bản Java đã cài đặt, thì quá trình cài đặt đã thành công.\n\n4. **Chọn trình soạn thảo văn bản:**\n    - Có nhiều trình soạn thảo văn bản khác nhau mà bạn có thể sử dụng để viết chương trình Java. Một số trình soạn thảo phổ biến bao gồm:\n        - Eclipse\n        - NetBeans\n        - IntelliJ IDEA\n        - Visual Studio Code\n        - Notepad++\n    - Bạn có thể chọn trình soạn thảo phù hợp với nhu cầu và sở thích của mình.\n\n5. **Viết và chạy chương trình Java đầu tiên:**\n    - Mở trình soạn thảo văn bản và tạo tệp mới có phần mở rộng \".java\".\n    - Viết mã chương trình Java vào tệp này.\n    - Lưu tệp.\n    - Mở Terminal hoặc Command Prompt và điều hướng đến thư mục chứa tệp Java.\n    - Nhập lệnh sau để biên dịch chương trình:\n        ```\n        javac FileName.java\n        ```\n    - Nhập lệnh sau để chạy chương trình:\n        ```\n        java FileName\n        ```",
      "id": "521"
    }
  },
  {
    "id": "62",
    "name": "Cách thiết lập Path",
    "href": "https://www.vietjack.com/java/cach_thiet_lap_path_trong_java.jsp",
    "lesson": {
      "title": "cách thiết lập path trong java",
      "content": "Để thiết lập classpath trong Java, bạn có thể làm theo các bước sau:\n\n1. Tạo một biến môi trường mới tên là \"CLASSPATH\" trong \"User Variables\" của \"Advanced\" tab trong \"Properties\" của \"My Computer\".\n2. Đặt giá trị của biến \"CLASSPATH\" là đường dẫn đến thư mục \"bin\" của cài đặt Java. Ví dụ: \"C:\\Program Files\\Java\\jdk1.8.0_201\\bin\".\n3. Khởi động lại máy tính để các thay đổi có hiệu lực.\n\nSau khi thiết lập classpath, bạn có thể sử dụng các công cụ liên quan đến Java, chẳng hạn như javac hoặc java, từ terminal.",
      "id": "621"
    }
  },
  {
    "id": "72",
    "name": "Chương trình Hello World",
    "href": "https://www.vietjack.com/java/chuong_trinh_java_dau_tien_hello_world.jsp",
    "lesson": {
      "title": "chương trình java đầu tiên hello world",
      "content": "Nếu gặp lỗi như hình ảnh hiển thị, bạn cần thiết lập đường dẫn vì hệ điều hành không nhận biết javac hoặc java. Đường dẫn không cần thiết nếu bạn lưu chương trình bên trong thư mục jdk\\bin, nhưng đôi khi bạn cần biết cách thiết lập đường dẫn để xử lý các trường hợp có thể xảy ra. Bạn có thể theo dõi phần \"Cách thiết lập đường dẫn trong Java\" để biết thêm chi tiết.\n\nCó nhiều cách để viết một chương trình Java. Bạn có thể thay đổi thứ tự sắp xếp của các từ khóa mà không làm thay đổi nguyên mẫu phương thức. Ví dụ:\n\n```\npublic static void main(String[] args) {\n    // Code here\n}\n```\n\nBạn cũng có thể cung cấp hỗ trợ varargs cho phương thức main bằng cách truyền ba dấu chấm (…). Ví dụ:\n\n```\npublic static void main(String... args) {\n    // Code here\n}\n```\n\nKý hiệu chỉ số dưới trong mảng Java có thể được sử dụng sau kiểu ở trước biến hoặc đằng sau biến. Ví dụ:\n\n```\nint[] array1 = new int[10];\nint array2[] = new int[10];\n```\n\nBạn có thể viết phương thức main theo nhiều cách khác nhau. Ví dụ:\n\n```\npublic static void main(String[] args) {\n    // Code here\n}\n\npublic static void main(String... args) {\n    // Code here\n}\n\npublic void main(String[] args) {\n    // Code here\n}\n```\n\nTừ khóa public là một từ khóa truy cập biểu thị tính nhìn thấy, nghĩa là nó có thể nhìn thấy được từ mọi nơi. Từ khóa class được sử dụng để khai báo một lớp trong Java.\n\nĐể tạo một chương trình Java đơn giản, bạn cần tạo một lớp chứa phương thức main. Để thực thi bất kỳ chương trình Java nào, bạn cần phương thức main. Trong chương này, chúng ta sẽ học cách viết một chương trình Java đơn giản. Trước khi viết chương trình Hello World, bạn nên cài đặt JDK trước.class Simple{ public static void main(String args[]){\nSystem.out.println(\"Hello World\"); } }\n\n, static public void main(String args[])\n\n, public static void main(String[] args) public static void main(String []args)\npublic static void main(String args[])\n\n, public static void main(String... args)\n\n, class A{ static public void main(String... args){ System.out.println(\"Hello\nWorld\"); } };\n\n, public static void main(String[] args) public static void main(String []args)\npublic static void main(String args[]) public static void main(String... args)\nstatic public void main(String[] args) public static final void main(String[]\nargs) final public static void main(String[] args) final strictfp public\nstatic void main(String[] args)\n\n, public void main(String[] args) static void main(String[] args) public void\nstatic main(String[] args) abstract public static void main(String[] args)\n\n",
      "id": "721"
    }
  },
  {
    "id": "82",
    "name": "Phân tích chương trình Hello World",
    "href": "https://www.vietjack.com/java/phan_tich_chuong_trinh_java_hello_world.jsp",
    "lesson": {
      "title": "phân tích nội tại chương trình hello world trong java",
      "content": "- Khi bạn gõ java simple để thực thi, JVM sẽ đọc bytecode stream và thực hiện các chỉ thị.\n- Bytecode vertifier sẽ kiểm tra các đoạn code để xem có hay không các phần code không hợp lệ hoặc có truy cập không hợp lệ tới các đối tượng.\n- Classloader là hệ thống con của JVM được sử dụng để tải class file.\n- Tại runtime (thời gian chạy), các bước sau được thực hiện:\n  - Java file được biên dịch bởi Java compiler.\n  - Java compiler chuyển đổi Java code thành bytecode.\n  - Bytecode được thực thi bởi JVM.\n\nNgoài ra, bạn có thể thấy một số câu hỏi liên quan đến chương trình Java đầu tiên này.",
      "id": "821"
    }
  },
  {
    "id": "92",
    "name": "Cú pháp Java cơ bản",
    "href": "https://www.vietjack.com/java/cu_phap_java_co_ban.jsp",
    "lesson": {
      "title": "cú pháp java cơ bản",
      "content": "Khi chạy chương trình java, bạn có thể sử dụng lệnh println và print để thông tin trên màn hình chuẩn. Tuy nhiên, có một điểm khác nhau nhỏ về con trỏ trong hai lệnh này. Trong khi lệnh print giữ nguyên vị trí con trỏ trên cùng một dòng thì lệnh println di chuyển con trỏ xuống dòng tiếp theo.\n\nInterface định nghĩa các phương thức mà các subclass nên sử dụng, nhưng sự thực thi của các phương thức lại hoàn toàn là các subclass. Trong java, một interface có thể được định nghĩa như là một contract giữa các đối tượng về cách giao tiếp với nhau. Các interface đóng vai trò thiết yếu khi nó đi với khái niệm về tính kế thừa.\n\nKhái niệm tính kế thừa cho bạn khả năng tái sử dụng các trường và các phương thức của class đang tồn tại mà không cần phải viết lại code trong class mới. Trong tình huống này, class đang tồn tại được gọi là superclass và class được suy ra được gọi là subclass.\n\nTrong java, các class có thể được suy ra từ các class khác. Về cơ bản, nếu bạn cần tạo một class mới và ở đây đã là một class mà có một số đoạn code bạn cần thì khi đó nó là có thể để suy ra một class mới từ code đã tồn tại.\n\nJava hỗ trợ việc comment trên 1 dòng lệnh hoặc nhiều dòng lệnh tương tự như C và C++. Tất cả các ký tự trong các dòng comment đều được bỏ qua bởi java compiler.\n\nDanh sách dưới đây ra những từ khóa được dành riêng trong java. Những từ khóa dành riêng này không được sử dụng như một tên biến hoặc tên identifier.\n\nGhi chú các enums có thể được khai báo như là của riêng chính nó hoặc bên trong một lớp. Các phương thức, biến, constructor cũng có thể được định nghĩa bên trong các enum.\n\nMảng là đối tượng lưu trữ nhiều biến với chung một kiểu dữ liệu. Mặc dù vậy, một mảng bản thân nó cũng là một đối tượng trong bộ nhớ. Chúng ta cũng sẽ tìm hiểu các khởi tạo khai báo đối tượng này trong các chương sắp tới.\n\nTrong java, có hai loại modifier: access modifier và nonaccess modifier. Access modifier bao gồm default, public, protected, private. Nonaccess modifier bao gồm final, abstract, strictfp.\n\nCác identifier phân biệt chữ hoa thường. Những key word trong java không thể được sử dụng như một identifier. Sau kí tự đầu tiên có thể là bất kỳ ký tự nào. Tất cả các idenfier nên bắt đầu với một chữ cái từ a tới z hoặc từ A tới Z hoặc ký tự gạch dưới _.\n\nJava theo cú pháp camelcase để đặt tên cho lớp, interface, phương thức và biến. Nếu tên là tổ hợp của hai từ thì từ thứ hai sẽ luôn bắt đầu với chữ hoa. Ví dụ: actionPerformed, firstName, actionEvent.\n\nTên file chương trình tên file nên giống hệt tên class. Khi bạn lưu file, bạn nên sử dụng tên class và thêm hậu tố .java. Ví dụ: với tên class MyFirstJavaProgram, bạn nên lưu file dưới tên MyFirstJavaProgram.java.\n\nTên hằng nên bắt đầu với chữ hoa. Ví dụ: RED, YELLOW, MAX_PRIORITY.\n\nTên package nên bắt đầu với chữ thường. Ví dụ: java.lang, sql.util.\n\nTên biến nên bắt đầu với chữ thường. Ví dụ: firstName, orderNumber.\n\nTên phương thức tất cả các tên phương thức nên bắt đầu với chữ thường và là một động từ. Ví dụ: public void actionPerformed().\n\nTên interface nên bắt đầu với chữ hoa và là một tính từ. Ví dụ: Runnable, ActionListener.\n\nTên class tất cả các tên class trong java nên viết hoa chữ cái đầu tiên và là một danh từ. Nếu không viết hoa, các trình IDE sẽ cảnh báo bạn. Tất nhiên là java vẫn chấp nhận nếu cố tình viết thường chữ cái đầu tiên. Ví dụ: class System.\n\nJava là chương trình phân biệt chữ hoa chữ thường. Điều đó có nghĩa là imta và IMTA mang những ý nghĩa khác nhau trong java.\n\nVề chương trình java, khi bạn đặt tên cho bất cứ thành phần nào, bạn cần tuân theo qui ước đặt tên của chúng. Qui ước đặt tên trong java là một qui tắc bạn cần theo khi quyết định đặt tên nào cho định danh identifier của mình. Chẳng hạn như đặt tên cho lớp, package, biến, hằng, phương thức. Nhưng nó không bắt buộc để bạn phải theo, vì thế nó được gọi là qui ước chứ không phải là qui tắc.\n\nBiến mỗi đối tượng có một tập các biến duy nhất. Mỗi trạng thái của đối tượng được khởi tạo bởi các giá trị và gán với những biến.\n\nPhương thức một phương thức đơn giản là một hành vi. Một lớp có thể bao gồm nhiều phương thức. Trong mỗi phương thức có những phép toán, logic, dữ liệu được xử lý và tất cả các hành động được thực thi.\n\nLớp một lớp có thể được định nghĩa như một bản thiết kế mẫu mà có thể mô tả các trạng thái, hành vi của một đối tượng mà nó hỗ trợ.\n\nĐối tượng đối tượng có các trạng thái và hành vi. Ví dụ: một con chó có các trạng thái của màu da, tên, tuổi, thức ăn cũng như các hành vi như sủa, ăn, vẫy đuôi.\n\nChúng ta có thể coi chương trình java như một tập hợp các đối tượng mà có thể trao đổi lẫn nhau. Dùng các phương thức dưới đây, chúng ta sẽ nêu ra một số định nghĩa cơ bản của lớp, đối tượng, phương thức cũng như biến trong java.abstract: Dùng để khai báo lớp trừu tượng, có thể chứa phương thức trừu tượng.\nassert: Dùng để xác nhận một điều kiện nào đó.\nboolean: Kiểu dữ liệu Boolean.\nbreak: Dùng để thoát khỏi vòng lặp hoặc câu lệnh switch.\nbyte: Kiểu dữ liệu Byte, có thể lưu trữ các giá trị nguyên từ -128 đến 127.\ncase: Dùng trong câu lệnh switch để xác định trường hợp cụ thể.\ncatch: Dùng để bắt các ngoại lệ trong khối try.\nchar: Kiểu dữ liệu Char, có thể lưu trữ một ký tự Unicode.\nclass: Dùng để khai báo lớp.\nconst: Dùng để khai báo hằng số.\ncontinue: Dùng để bỏ qua phần còn lại của vòng lặp và tiếp tục với lần lặp tiếp theo.\ndefault: Dùng trong câu lệnh switch để xác định trường hợp mặc định.\ndo: Dùng để khai báo vòng lặp do-while.\ndouble: Kiểu dữ liệu Double, có thể lưu trữ các giá trị số thực có độ chính xác cao.\nelse: Dùng để xác định nhánh else trong câu lệnh if-else.\nenum: Dùng để khai báo kiểu liệt kê.\nextends: Dùng để chỉ ra lớp con kế thừa từ lớp cha.\nfinal: Dùng để khai báo hằng số hoặc phương thức không thể thay đổi.\nfinally: Dùng để xác định khối finally trong khối try-catch-finally.\nfloat: Kiểu dữ liệu Float, có thể lưu trữ các giá trị số thực có độ chính xác thấp hơn double.\nfor: Dùng để khai báo vòng lặp for.\ngoto: Dùng để chuyển đến một nhãn đã khai báo trước đó.\nif: Dùng để khai báo câu lệnh điều kiện if-else.\nimplements: Dùng để chỉ ra lớp con triển khai giao diện nào đó.\nimport: Dùng để nhập các lớp hoặc gói từ các thư viện khác.\ninstanceof: Dùng để kiểm tra xem một đối tượng có phải là một thể hiện của một lớp hoặc giao diện nào đó không.\nint: Kiểu dữ liệu Int, có thể lưu trữ các giá trị nguyên từ -2^31 đến 2^31-1.\ninterface: Dùng để khai báo giao diện.\nlong: Kiểu dữ liệu Long, có thể lưu trữ các giá trị nguyên từ -2^63 đến 2^63-1.\nnative: Dùng để khai báo phương thức gốc, được triển khai bằng ngôn ngữ khác.\nnew: Dùng để tạo một đối tượng mới.\npackage: Dùng để khai báo gói.\nprivate: Dùng để khai báo thành viên chỉ có thể truy cập trong lớp.\nprotected: Dùng để khai báo thành viên có thể truy cập trong lớp và các lớp con.\npublic: Dùng để khai báo thành viên có thể truy cập từ bất kỳ nơi nào.\nreturn: Dùng để trả về giá trị từ một phương thức.\nshort: Kiểu dữ liệu Short, có thể lưu trữ các giá trị nguyên từ -2^15 đến 2^15-1.\nstatic: Dùng để khai báo thành viên lớp, có thể truy cập mà không cần tạo đối tượng.\nstrictfp: Dùng để đảm bảo rằng các phép toán số học được thực hiện với độ chính xác cao.\nsuper: Dùng để truy cập đến lớp cha.\nswitch: Dùng để khai báo câu lệnh switch.\nsynchronized: Dùng để đồng bộ hóa các luồng.\nthis: Dùng để tham chiếu đến đối tượng hiện tại.\nthrow: Dùng để ném một ngoại lệ.\nthrows: Dùng để chỉ ra các ngoại lệ có thể được ném bởi một phương thức.\ntransient: Dùng để chỉ ra rằng một trường không được lưu trữ khi đối tượng được tuần tự hóa.\ntry: Dùng để khai báo khối try trong khối try-catch-finally.\nvoid: Kiểu dữ liệu Void, không có giá trị.\nvolatile: Dùng để chỉ ra rằng một trường có thể được thay đổi bởi nhiều luồng đồng thời.\nwhile: Dùng để khai báo vòng lặp while.class FreshJuice { enum FreshJuiceSize{ SMALL, MEDIUM, LARGE } FreshJuiceSize\nsize; } public class FreshJuiceTest { public static void main(String args[]){\nFreshJuice juice = new FreshJuice(); juice.size = FreshJuice.\nFreshJuiceSize.MEDIUM ; System.out.println(\"Size: \" + juice.size); } }\n\n, Size: MEDIUM\n\n, public class MyFirstJavaProgram{ /* Chuong trinh in Hello World. * Day la vi\ndu ve comment gom nhieu dong. */ public static void main(String []args){ // Vi\ndu thu nhat ve comment co mot dong. /* Vi du thu hai ve comment co mot dong.\n*/ System.out.println(\"Hello World\"); } }\n\n, package edu.doannhg.basic; // vi du phan biet hai lenh print va println class\nTest { public static void main(String args[]) { // lenh print\nSystem.out.print(\"VietJack \"); System.out.print(\"chuc cac ban \");\nSystem.out.print(\"hoc tot!!!\"); System.out.print(\"\\n---------------\\n\"); //\nlenh println System.out.println(\"VietJack \"); System.out.println(\"chuc cac ban\n\"); System.out.println(\"hoc tot!!!\"); } }\n\n, VietJack chuc cac ban hoc tot!!! \\--------------- VietJack chuc cac ban hoc\ntot!!!\n\n",
      "id": "921"
    }
  },
  {
    "id": "102",
    "name": "JDK, JRE và JVM",
    "href": "https://www.vietjack.com/java/gioi_thieu_jdk_jre_jvm_trong_java.jsp",
    "lesson": {
      "title": "giới thiệu jdk, jre và jvm trong java",
      "content": "JVM (Java Virtual Machine) là một thiết bị ảo giúp máy tính chạy các chương trình Java. Nó cung cấp môi trường runtime để thực thi bytecode Java.\nJRE (Java Runtime Environment) là một phần của JDK, cung cấp môi trường runtime để chạy các chương trình Java. Nó bao gồm JVM, các thư viện và các tệp khác cần thiết để chạy chương trình Java.\nJDK (Java Development Kit) là một bộ công cụ phát triển Java, bao gồm JRE và các công cụ phát triển khác như trình biên dịch Java, trình gỡ lỗi Java, v.v.\nJDK, JRE và JVM đều phụ thuộc vào nền tảng, có nghĩa là cấu hình của mỗi hệ điều hành là khác nhau. Tuy nhiên, Java là ngôn ngữ độc lập với nền tảng, có nghĩa là chương trình Java có thể chạy trên bất kỳ nền tảng nào có JVM.\nJVM thực hiện các tác vụ chính sau:\n- Cung cấp môi trường runtime cho các chương trình Java.\n- Thực thi bytecode Java.\n- Kiểm tra code Java.\n- Tải code Java.\nJVM có sẵn cho nhiều nền tảng như Windows, Linux, v.v.",
      "id": "1021"
    }
  },
  {
    "id": "112",
    "name": "Biến trong Java",
    "href": "https://www.vietjack.com/java/bien_trong_java.jsp",
    "lesson": {
      "title": "các kiểu biến trong java",
      "content": "- Biến static là biến được khai báo bằng từ khóa `static` bên trong một lớp.\n- Biến static được tạo khi chương trình bắt đầu và bị hủy khi chương trình kết thúc.\n- Biến static được lưu giữ trong bộ nhớ static.\n- Biến static được truy cập bởi việc gọi tên lớp `classname.variablename`.\n- Biến static có thể được truy cập từ lớp bên ngoài bằng cách sử dụng cú pháp `classname.variablename`.\n- Biến static được khởi tạo khi chương trình bắt đầu và giá trị mặc định của biến static là 0 đối với số, `false` đối với `boolean` và `null` đối với đối tượng.\n- Biến static có thể được gán giá trị trong khi khai báo hoặc trong constructor.\n- Biến static có thể được gán giá trị trong các khối khởi tạo static đặc biệt.\n- Tính nhìn thấy của biến static là tương tự như các thuộc tính.\n- Biến static thường được khai báo chung khi chúng phải là có sẵn cho việc sử dụng của lớp.\n- Biến static hiếm khi được sử dụng ngoài việc được khai báo như là các hằng số.\n- Hằng số là các biến mà được khai báo như là các biến `static`, `final` và `public`.\n- Hằng số không bao giờ thay đổi từ giá trị khởi tạo của chúng.\n- Chỉ có một bản sao của mỗi biến class cho mỗi lớp bất chấp việc bao nhiêu đối tượng được tạo từ nó.\n- Biến class cũng được biết như là các biến static được khai báo với từ khóa `static` trong một lớp nhưng ở bên ngoài một phương thức, constructor hoặc một khối.\n- Thuộc tính có thể được truy cập một cách trực tiếp bởi việc gọi tên biến bên trong lớp đó.\n- Thuộc tính được cung cấp khả năng truy cập nó nên được gọi bởi sử dụng tên đầy đủ hợp lệ như sau `objectreference.variablename`.\n- Thuộc tính có các giá trị mặc định với các số giá trị mặc định là 0 với `boolean` là `false` và với đối tượng là `null`.\n- Thuộc tính có thể được gán giá trị trong khi khai báo hoặc trong constructor.\n- Thuộc tính là nhìn thấy với tất cả các phương thức, constructor và khối trong lớp.\n- Tính nhìn thấy cho các lớp phụ có thể được cung cấp cho những biến này với sự sử dụng của chỉ định truy cập.\n- Chỉ định truy cập `access modifier` có thể được cung cấp cho các thuộc tính.\n- Thuộc tính có thể được khai báo trong mức độ lớp trước hoặc sau khi sử dụng.\n- Thuộc tính giữ các giá trị mà phải được tham chiếu bởi nhiều hơn một phương thức, constructor hoặc khối hoặc các phần chủ yếu của trạng thái đối tượng mà phải có mặt xuyên suốt lớp đó.\n- Thuộc tính được tạo khi một đối tượng được tạo bởi sử dụng từ khóa `new` và bị hủy khi đối tượng bị hủy.\n- Khi một không gian nhớ được cấp phát cho một đối tượng trong một `heap` một dạng cấu trúc hàng đợi có thứ tự ưu tiên một slot cho mỗi giá trị thuộc tính được tạo ra.\n- Thuộc tính được khai báo trong một lớp nhưng ở bên ngoài một phương thức, constructor hoặc bất kỳ khối nào.\n- Biến local là biến được khai báo bên trong một phương thức hoặc khối.\n- Biến local được tạo khi phương thức hoặc khối được nhập và biến bị hủy khi phương thức hoặc khối kết thúc.\n- Biến local chỉ nhìn thấy trong phương thức hoặc khối được khai báo.\n- Chỉ định truy cập `access modifier` có thể không được sử dụng cho các biến local.\n- Biến local được thực thi nội bộ.\n- Biến local có thể được khai báo và khởi tạo trong cùng một dòng.\n- Biến local có thể được khai báo trước khi sử dụng.\n- Form cơ bản của một khai báo biến như sau: `kiểu_dữ_lieu bien;`.kieu_du_lieu bien [ = giatri][, bien [= giatri] ...] ;\n\n, int a, b, c; // Khai bao ba bien kieu int la a, b, và c. int a = 5, b = 7; //\nVi du ve khoi tao bien byte A = 11; // Khoi tao mot bien kieu byte ten la A.\ndouble pi = 3.14159; // Khai bao va gan mot gia tri cua PI. char nam = 'b'; //\nBien nam duoc khoi tao voi gia tri 'a'.\n\n, public class Test{ public void tuoiCon(){ int tuoi = 0; tuoi = tuoi + 10;\nSystem.out.println(\"Tuoi con la : \" + tuoi); } public static void main(String\nargs[]){ Test test = new Test(); test.tuoiCon(); } }\n\n, public class Test{ public void tuoiCon(){ int tuoi; tuoi = tuoi + 10;\nSystem.out.println(\"Tuoi con la : \" + tuoi); } public static void main(String\nargs[]){ Test test = new Test(); test.tuoiCon(); } }\n\n, Test.java:4:variable number might not have been initialized tuoi = tuoi + 10;\n^ 1 error\n\n, import java.io.*; public class Student{ // Bien instance nay la nhin thay cho\nbat ky lop con nao. public String ten; // Bien hocphi la chi nhin thay cho lop\nStudent. private double hocphi; // Bien ten duoc gan trong constructor. public\nStudent (String tenSV){ ten = tenSV; } // Bien hocphi duoc gan mot gia tri.\npublic void setHocPhi(double hp){ hocphi = hp; } // Phuong thuc nay in chi\ntiet ve Student. public void inThongTin(){ System.out.println(\"Ho va ten: \" +\nten ); System.out.println(\"Hoc phi: \" + hocphi); } public static void\nmain(String args[]){ Student sv1 = new Student(\"Nguyen Van Doan\");\nsv1.setHocPhi(4000); sv1.inThongTin(); } }\n\n, Ho va ten: Nguyen Van Doan Hoc phi: 4000.0\n\n, import java.io.*; public class Student{ // Bien hocphi la mot bien private\nstatic private static double hocphi; // FACULTY la mot constant public static\nfinal String FACULTY = \"KhoaIT \"; public static void main(String args[]){\nhocphi = 4000; System.out.println(FACULTY+\"hocphi trung binh:\"+hocphi); } }\n\n, KhoaIT hocphi trung binh:4000\n\n",
      "id": "1121"
    }
  },
  {
    "id": "122",
    "name": "Kiểu dữ liệu",
    "href": "https://www.vietjack.com/java/kieu_du_lieu_trong_java.jsp",
    "lesson": {
      "title": "kiểu dữ liệu trong java",
      "content": "Java hỗ trợ một số dãy thoát đặc biệt cho chuỗi và ký tự như sau:\n\n- Chuỗi và ký tự có thể chứa bất kỳ ký tự unicode nào.\n- Chuỗi ký tự trong Java được xác định giống như trong hầu hết các ngôn ngữ khác bằng cách bao quanh một chuỗi ký tự liên tục trong trích dẫn kép.\n- Tiền tố 0 được sử dụng để chỉ hệ bát phân và tiền tố 0x chỉ dẫn hệ cơ số 16 khi sử dụng những hệ cơ số này cho các literal.\n- Byte, int, long và short có thể được biểu diễn trong hệ thập phân cơ số 10, hệ thập lục phân cơ số 16 hoặc hệ bát phân cơ số 8.\n- Các literal có thể được gán tới bất kỳ kiểu biến gốc nào.\n- Một literal hay một hằng là một code nguồn biểu diễn một giá trị cố định.\n- Một biến đối tượng có thể được sử dụng để tham chiếu tới bất kỳ đối tượng nào trong kiểu được khai báo hoặc bất kỳ kiểu tương thích nào.\n- Giá trị mặc định của bất kỳ biến đối tượng nào là null.\n- Các biến đối tượng được tạo bởi sử dụng các constructor đã được định nghĩa của các lớp.\n- Giá trị mặc định là false, dùng để lưu dữ liệu chỉ có hai trạng thái true hoặc false, độ lớn chỉ có 1 bit.\n- Kiểu double không bao giờ được sử dụng cho các giá trị chính xác như currency.\n- Kiểu dữ liệu double được sử dụng để lưu dữ liệu có kiểu số thực có kích thước lên đến 8 byte.\n- Kiểu float không bao giờ được sử dụng cho các giá trị chính xác như currency.\n- Kiểu float được sử dụng chủ yếu để lưu bộ nhớ trong các mảng rộng hơn các số thực dấu chấm động.\n- Kiểu này được sử dụng khi cần một dải giá trị rộng hơn int.\n- Nói chung int được sử dụng như là kiểu dữ liệu mặc định cho các giá trị nguyên.\n- Kiểu dữ liệu short cũng có thể được sử dụng để lưu bộ nhớ như kiểu dữ liệu byte.\n- Kiểu dữ liệu byte được sử dụng để lưu giữ khoảng trống trong các mảng lớn chủ yếu là các số nguyên.\n- Java sử dụng unicode chứ không phải ascii.\n- Có 8 kiểu dữ liệu gốc được hỗ trợ bởi Java.\n- Các kiểu dữ liệu gốc này được tiền định nghĩa bởi ngôn ngữ và được định danh bởi một từ khóa.\n- Có hai kiểu dữ liệu có sẵn trong Java: kiểu dữ liệu gốc và kiểu dữ liệu tham chiếu.\n- Dựa trên kiểu dữ liệu của một biến, hệ điều hành cấp phát bộ nhớ và quyết định cái gì có thể được lưu giữ trong bộ nhớ dành riêng.\n- Các biến là không gì khác ngoài các vị trí bộ nhớ dành riêng để lưu các giá trị.- Kiểu dữ liệu Boolean lưu trữ giá trị true hoặc false. Giá trị mặc định là false và kích thước mặc định là 1 bit.\n\n- Kiểu dữ liệu char lưu trữ ký tự. Giá trị mặc định là '\\u0000' và kích thước mặc định là 2 byte.\n\n- Kiểu dữ liệu byte lưu trữ số nguyên có dấu trong phạm vi từ -128 đến 127. Giá trị mặc định là 0 và kích thước mặc định là 1 byte.\n\n- Kiểu dữ liệu short lưu trữ số nguyên có dấu trong phạm vi từ -32,768 đến 32,767. Giá trị mặc định là 0 và kích thước mặc định là 2 byte.\n\n- Kiểu dữ liệu int lưu trữ số nguyên có dấu trong phạm vi từ -2,147,483,648 đến 2,147,483,647. Giá trị mặc định là 0 và kích thước mặc định là 4 byte.\n\n- Kiểu dữ liệu long lưu trữ số nguyên có dấu trong phạm vi từ -9,223,372,036,854,775,808 đến 9,223,372,036,854,775,807. Giá trị mặc định là 0L và kích thước mặc định là 8 byte.\n\n- Kiểu dữ liệu float lưu trữ số thực có dấu trong phạm vi từ -3.4028235E38 đến 3.4028235E38. Giá trị mặc định là 0.0f và kích thước mặc định là 4 byte.\n\n- Kiểu dữ liệu double lưu trữ số thực có dấu trong phạm vi từ -1.7976931348623157E308 đến 1.7976931348623157E308. Giá trị mặc định là 0.0d và kích thước mặc định là 8 byte.\n\n- Các ký hiệu đặc biệt trong Java:\n  - \\n: Newline (0x0a)\n  - \\r: Carriage return (0x0d)\n  - \\f: Formfeed (0x0c)\n  - \\b: Backspace (0x08)\n  - \\s: Space (0x20)\n  - \\t: Tab\n  - \\\": Trích dẫn kép\n  - \\': Trích dẫn đơn\n  - \\\\: Backslash\n  - \\ddd: Ký tự Octal (ddd)\n  - \\uxxxx: Ký tự Hexadecimal UNICODE (xxxx)byte a = 12; char a = 'CAT'\n\n, int decimal = 100; int octal = 0144; int hexa = 0x64;\n\n, \"Hello World\" \"Hai\\ndong\" \"\\\"Day la trong trich dan\\\"\"\n\n, char x = '\\u0001'; String y = \"\\u0001\";\n\n",
      "id": "1221"
    }
  },
  {
    "id": "132",
    "name": "Toán tử",
    "href": "https://www.vietjack.com/java/toan_tu_trong_java.jsp",
    "lesson": {
      "title": "toán tử trong java",
      "content": "| Loại toán tử | Thứ tự ưu tiên | Ví dụ |\n|---|---|---|\n| Toán tử đóng ngoặc | Cao nhất | (x + y) * z |\n| Toán tử lũy thừa | Thứ hai | x ^ y |\n| Toán tử đơn | Thứ ba | -x, !x |\n| Toán tử nhân và chia | Thứ tư | x * y, x / y |\n| Toán tử cộng và trừ | Thứ năm | x + y, x - y |\n| Toán tử so sánh | Thứ sáu | x == y, x != y, x > y, x < y, x >= y, x <= y |\n| Toán tử logic | Thứ bảy | x && y, x || y, !x |\n| Toán tử gán | Thứ tám | x = y |\n| Toán tử hỗn hợp | Thứ chín | x += y, x -= y, x *= y, x /= y |\n| Toán tử thao tác bit | Thứ mười | x & y, x | y, x ^ y, ~x |\n| Toán tử quan hệ | Thứ mười một | x instanceof y |\n| Toán tử số học | Thứ mười hai | +, -, *, /, % |**Toán tử số học**\n\n- Phép cộng (+): Trả về tổng của hai toán hạng.\n- Phép trừ (-): Trả về hiệu của toán hạng trái và toán hạng phải.\n- Phép nhân (*): Trả về tích của hai toán hạng.\n- Phép chia (/): Trả về thương của toán hạng trái và toán hạng phải.\n- Phép chia lấy phần dư (%): Trả về phần dư của phép chia toán hạng trái cho toán hạng phải.\n\n**Toán tử so sánh**\n\n- Bằng (=): Trả về true nếu hai toán hạng bằng nhau, ngược lại trả về false.\n- Không bằng (!=): Trả về true nếu hai toán hạng không bằng nhau, ngược lại trả về false.\n- Lớn hơn (>): Trả về true nếu toán hạng trái lớn hơn toán hạng phải, ngược lại trả về false.\n- Lớn hơn hoặc bằng (>=): Trả về true nếu toán hạng trái lớn hơn hoặc bằng toán hạng phải, ngược lại trả về false.\n- Nhỏ hơn (<): Trả về true nếu toán hạng trái nhỏ hơn toán hạng phải, ngược lại trả về false.\n- Nhỏ hơn hoặc bằng (<=): Trả về true nếu toán hạng trái nhỏ hơn hoặc bằng toán hạng phải, ngược lại trả về false.\n\n**Toán tử logic**\n\n- Và (&): Trả về true nếu cả hai toán hạng đều bằng true, ngược lại trả về false.\n- Hoặc (|): Trả về true nếu một trong hai toán hạng bằng true, ngược lại trả về false.\n- Không (!): Đảo ngược trạng thái logic của toán hạng.\n\n**Toán tử gán**\n\n- Gán (=): Gán giá trị của toán hạng phải cho toán hạng trái.\n- Cộng và gán (+=): Cộng giá trị của toán hạng phải vào toán hạng trái và gán giá trị đó cho toán hạng trái.\n- Trừ và gán (-=): Trừ giá trị của toán hạng phải khỏi toán hạng trái và gán giá trị đó cho toán hạng trái.\n- Nhân và gán (*=): Nhân giá trị của toán hạng phải với toán hạng trái và gán giá trị đó cho toán hạng trái.\n- Chia và gán (/=): Chia giá trị của toán hạng trái cho toán hạng phải và gán giá trị đó cho toán hạng trái.\n- Chia lấy phần dư và gán (%=): Chia giá trị của toán hạng trái cho toán hạng phải và gán phần dư cho toán hạng trái.\n\n**Toán tử tăng giảm**\n\n- Tăng (++): Tăng giá trị của toán hạng lên 1.\n- Giảm (--): Giảm giá trị của toán hạng đi 1.\n\n**Toán tử dịch chuyển**\n\n- Dịch trái (<<): Dịch giá trị của toán hạng trái sang trái theo số bit được chỉ định bởi toán hạng phải.\n- Dịch phải (>>): Dịch giá trị của toán hạng trái sang phải theo số bit được chỉ định bởi toán hạng phải.\n\n**Toán tử bit**\n\n- Phép AND bit (&): Trả về một giá trị bit bằng 1 nếu cả hai bit tương ứng của hai toán hạng đều bằng 1, ngược lại trả về 0.\n- Phép OR bit (|): Trả về một giá trị bit bằng 1 nếu một trong hai bit tương ứng của hai toán hạng bằng 1, ngược lại trả về 0.\n- Phép XOR bit (^): Trả về một giá trị bit bằng 1 nếu hai bit tương ứng của hai toán hạng khác nhau, ngược lại trả về 0.\n- Phép đảo bit (~): Đảo ngược tất cả các bit của toán hạng.\n\n**Toán tử điều kiện**\n\n- Điều kiện (?:): Trả về giá trị của toán hạng thứ hai nếu toán hạng thứ nhất bằng true, ngược lại trả về giá trị của toán hạng thứ ba.bien x = (bieu_thuc) ? (giatri1 neu true) : (giatri1 neu true); //hoac ban\ncung co the su dung trong cac lenh RETURN return (bieu_thuc) ? (giatri1 neu\ntrue) : (giatri2 neu false);\n\n, public class Test { public static void main(String args[]){ int a , b; a = 10;\nb = (a == 1) ? 20: 30; //Day la vi du ve toan tu dieu kien.\nSystem.out.println( \"Gia tri cua b la : \" + b ); b = (a == 10) ? 20: 30; //Day\nla vi du ve toan tu dieu kien. System.out.println( \"Gia tri cua b la : \" + b\n); } }\n\n, Gia tri cua b la : 30 Gia tri cua b la : 20\n\n, ( Object reference variable ) instanceof (class/interface type)\n\n, public class Test { public static void main(String args[]){ String name =\n\"Doan\"; // Duoi day se tra ve true neu name la mot kieu String boolean result\n= name instanceof String; System.out.println( result ); } }\n\n, true\n\n, class Animal {} public class Dog extends Animal { public static void\nmain(String args[]){ Animal a = new Dog(); boolean result = a instanceof Dog;\nSystem.out.println( result ); } }\n\n, true\n\n",
      "id": "1321"
    }
  },
  {
    "id": "142",
    "name": "Các kiểu vòng lặp",
    "href": "https://www.vietjack.com/java/vong_lap_trong_java.jsp",
    "lesson": {
      "title": "vòng lặp trong java",
      "content": "Trong chương tiếp theo, chúng ta sẽ khám phá các lệnh điều khiển luồng trong ngôn ngữ lập trình Java, bao gồm lệnh continue và lệnh break. Các lệnh này được sử dụng để điều khiển vòng lặp và cho phép bạn dừng hoặc tiếp tục thực thi vòng lặp tại một điểm cụ thể.\n\nJava hỗ trợ nhiều loại vòng lặp khác nhau, bao gồm vòng lặp for, vòng lặp while, vòng lặp do-while và vòng lặp foreach. Mỗi loại vòng lặp có cách sử dụng riêng và phù hợp với các tình huống khác nhau.\n\nTrong Java 5, vòng lặp foreach hoặc vòng lặp enhanced đã được giới thiệu. Vòng lặp này được sử dụng chủ yếu để lặp qua các phần tử của mảng.\n\nNgoài các vòng lặp tiêu chuẩn, Java còn có 3 kỹ thuật lặp linh hoạt khác, bao gồm vòng lặp for-each, vòng lặp while-do và vòng lặp do-while. Mỗi kỹ thuật lặp này có những đặc điểm và cách sử dụng riêng.\n\nTrong một số tình huống, bạn có thể cần thực hiện một khối mã một vài lần. Điều này có thể được thực hiện bằng cách sử dụng vòng lặp. Vòng lặp là một cấu trúc điều khiển cho phép bạn lặp lại một khối mã nhiều lần cho đến khi một điều kiện nào đó được đáp ứng.- Vòng lặp while kiểm tra điều kiện trước khi thực hiện một hành động.\n\n- Vòng lặp for thực hiện một hành động một số lần nhất định.\n\n- Vòng lặp do...while thực hiện một hành động ít nhất một lần, sau đó kiểm tra điều kiện.\n\n- Vòng lặp foreach được sử dụng để lặp qua các phần tử của một mảng hoặc danh sách.\n\n- Lệnh break được sử dụng để thoát khỏi một vòng lặp.\n\n- Lệnh continue được sử dụng để bỏ qua phần còn lại của một vòng lặp và tiếp tục với lần lặp tiếp theo.",
      "id": "1421"
    }
  },
  {
    "id": "152",
    "name": "Lệnh if, switch",
    "href": "https://www.vietjack.com/java/dieu_khien_luong_trong_java.jsp",
    "lesson": {
      "title": "lệnh if/else, lệnh switch/case trong java",
      "content": "Trong Java, các lệnh điều khiển luồng cho phép chương trình kiểm tra một hoặc nhiều điều kiện và thực hiện các lệnh tương ứng tùy thuộc vào kết quả của các điều kiện đó. Một số lệnh điều khiển luồng phổ biến bao gồm:\n\n- Lệnh if: Lệnh này kiểm tra một điều kiện và thực hiện các lệnh tương ứng nếu điều kiện đó là true.\n- Lệnh if-else: Lệnh này kiểm tra một điều kiện và thực hiện các lệnh tương ứng nếu điều kiện đó là true, nếu không thì thực hiện các lệnh tương ứng với điều kiện false.\n- Lệnh switch: Lệnh này kiểm tra giá trị của một biến và thực hiện các lệnh tương ứng với giá trị đó.\n- Lệnh for: Lệnh này lặp lại một khối lệnh một số lần nhất định.\n- Lệnh while: Lệnh này lặp lại một khối lệnh chừng nào điều kiện còn đúng.\n- Lệnh do-while: Lệnh này lặp lại một khối lệnh ít nhất một lần, sau đó lặp lại chừng nào điều kiện còn đúng.\n- Lệnh break: Lệnh này thoát khỏi một vòng lặp hoặc switch.\n- Lệnh continue: Lệnh này bỏ qua phần còn lại của vòng lặp hiện tại và tiếp tục với lần lặp tiếp theo.* Lệnh if:\n\n  - Lệnh if bao gồm một biểu thức boolean được theo sau bởi một hoặc nhiều lệnh.\n  - Nếu biểu thức boolean được đánh giá là đúng, các lệnh trong thân lệnh if sẽ được thực thi.\n\n\n* Lệnh if...else:\n\n  - Lệnh if có thể được theo sau bởi một lệnh else tùy ý, được thực thi khi biểu thức boolean là sai.\n\n\n* Lệnh if lồng nhau:\n\n  - Có thể lồng các lệnh if-else, tức là có thể sử dụng lệnh if hoặc else if bên trong lệnh if hoặc else if khác.\n\n\n* Lệnh switch:\n\n  - Lệnh switch cho phép kiểm tra xem một biến có bằng với một danh sách các giá trị không.\n  - Mỗi giá trị được gọi là một trường hợp.\n  - Nếu giá trị bằng với bất kỳ trường hợp nào, các lệnh tương ứng với trường hợp đó sẽ được thực thi.bien x = (bieu_thuc) ? (giatri1 neu true) : (giatri2 neu true); //hoac ban\ncung co the su dung trong cac lenh RETURN return (bieu_thuc) ? (giatri1 neu\ntrue) : (giatri2 neu false);\n\n, public class Test { public static void main(String args[]){ int a , b; a = 10;\nb = (a == 1) ? 20: 30; //Day la vi du ve toan tu dieu kien.\nSystem.out.println( \"Gia tri cua b la : \" + b ); b = (a == 10) ? 20: 30; //Day\nla vi du ve toan tu dieu kien. System.out.println( \"Gia tri cua b la : \" + b\n); } }\n\n, Gia tri cua b la : 30 Gia tri cua b la : 20\n\n",
      "id": "1521"
    }
  },
  {
    "id": "162",
    "name": "Đối tượng Number",
    "href": "https://www.vietjack.com/java/number_trong_java.jsp",
    "lesson": {
      "title": "number trong java",
      "content": "trả về một số ngẫu nhiên, random trong java, biến đổi tham số thành radian, toradians trong java, biến đổi tham số thành giá trị độ đo góc, todegrees trong java, biến đổi tọa độ x thành tọa độ cực r theta và trả về theta, atan2 trong java, trả về arctan của giá trị double đã cho, atan trong java, trả về arccos của giá trị double đã cho, acos trong java, trả về arcsin của giá trị double đã cho, asin trong java, trả về tan của giá trị double đã cho, tan trong java, trả về cos của giá trị double đã cho, cos trong java, trả về sin của giá trị double đã cho, sin trong java, trả về căn bậc hai của tham số, sqrt trong java, trả về giá trị hàm mũ với cơ số là tham số đầu tiên và mũ là tham số thứ hai, pow trong java, hàm logarit cơ số e, log trong java, hàm mũ cơ số e, exp trong java, trả về số lớn nhất trong hai tham số, max trong java, trả về số nhỏ nhất trong hai tham số, min trong java, trả về long hoặc int gần nhất như kiểu dữ liệu được chỉ dẫn bởi phương thức với tham số, round trong java, làm tròn số trả về giá trị integer gần nhất với giá trị tham số giá trị trả về ở dạng double, rint trong java, trả về số integer lớn nhất mà nhỏ hơn hoặc bằng tham số giá trị trả về ở dạng double, floor trong java, trả về số integer nhỏ nhất mà lớn hơn hoặc bằng tham số giá trị trả về ở dạng double, ceil trong java, trả về giá trị tuyệt đối của tham số, abs trong java, phương thức này được sử dụng để nhận kiểu dữ liệu gốc của một string cụ thể, parseint trong java, trả về đối tượng string biểu diễn giá trị integer đã xác định, tostring trong java, trả về một đối tượng integer giữ giá trị gốc đã xác định, valueof trong java, kiểm tra có hay không đối tượng number này là bằng với tham số, equals trong java, sánh đối tượng number này với tham số, compareto trong java, biến đổi giá trị của đối tượng number này thành kiểu dữ liệu xxx mà được trả về từ phương thức, xxxvalue trong java, bảng dưới liệt kê các phương thức mà tất cả các lớp phụ của lớp number thực thi, khi x được gán các giá trị integer bộ biên dịch đóng hộp giá trị integer này bởi vì x là đối tượng integer sau đó x được mở hộp để mà chúng có thể được cộng thêm các integer, nó sẽ cho kết quả sau, dưới đây là ví dụ của box và unbox, sự bao bọc này được chăm sóc bởi bộ biên dịch tiến trình này được gọi là boxing vì thế khi một kiểu dữ liệu gốc được sử dụng khi một đối tượng được yêu cầu bộ biên dịch đóng hộp kiểu dữ liệu gốc trong lớp wrapper của nó tương tự bộ biên dịch cũng mở hộp đối tượng thành một kiểu dữ liệu gốc number là một phần của javalang package, , tất cả các lớp wrapper integer long byte double float short là lớp phụ của lớp trừu tượng number, tuy nhiên khi mở rộng chúng ta cũng gặp các tình huống mà chúng ta cần sử dụng các đối tượng thay cho các kiểu dữ liệu gốc để thực hiện điều này java cung cấp các lớp wrapper lớp bọc cho mỗi kiểu dữ liệu gốc, thường thì khi làm việc với number chúng ta sử dụng các kiểu dữ liệu gốc như byte int long double1. Phương thức xxxValue() trong Java chuyển đổi giá trị của đối tượng Number này thành kiểu dữ liệu xxx và trả về giá trị đã chuyển đổi.\n2. Phương thức compareTo() trong Java so sánh đối tượng Number này với tham số và trả về giá trị âm nếu đối tượng này nhỏ hơn tham số, giá trị dương nếu đối tượng này lớn hơn tham số hoặc 0 nếu đối tượng này bằng tham số.\n3. Phương thức equals() trong Java kiểm tra xem đối tượng Number này có bằng với tham số hay không và trả về giá trị true nếu chúng bằng nhau, false nếu chúng không bằng nhau.\n4. Phương thức valueOf() trong Java trả về một đối tượng integer giữ giá trị gốc đã xác định.\n5. Phương thức toString() trong Java trả về đối tượng String biểu diễn giá trị Integer đã xác định.\n6. Phương thức parseInt() trong Java được sử dụng để nhận kiểu dữ liệu gốc của một String cụ thể.\n7. Phương thức abs() trong Java trả về giá trị tuyệt đối của tham số.\n8. Phương thức ceil() trong Java trả về số integer nhỏ nhất mà lớn hơn hoặc bằng tham số. Giá trị trả về ở dạng double.\n9. Phương thức floor() trong Java trả về số integer lớn nhất mà nhỏ hơn hoặc bằng tham số. Giá trị trả về ở dạng double.\n10. Phương thức rint() trong Java làm tròn số, trả về giá trị integer gần nhất với giá trị tham số. Giá trị trả về ở dạng double.\n11. Phương thức round() trong Java trả về long hoặc int gần nhất, như kiểu dữ liệu được chỉ dẫn bởi phương thức, với tham số.\n12. Phương thức min() trong Java trả về số nhỏ nhất trong hai tham số.\n13. Phương thức max() trong Java trả về số lớn nhất trong hai tham số.\n14. Phương thức exp() trong Java tính hàm mũ cơ số e.\n15. Phương thức log() trong Java tính hàm logarit cơ số e.\n16. Phương thức pow() trong Java trả về giá trị hàm mũ với cơ số là tham số đầu tiên và mũ là tham số thứ hai.\n17. Phương thức sqrt() trong Java trả về căn bậc hai của tham số.\n18. Phương thức sin() trong Java trả về sin của giá trị double đã cho.\n19. Phương thức cos() trong Java trả về cos của giá trị double đã cho.\n20. Phương thức tan() trong Java trả về tan của giá trị double đã cho.\n21. Phương thức asin() trong Java trả về arcsin của giá trị double đã cho.\n22. Phương thức acos() trong Java trả về arccos của giá trị double đã cho.\n23. Phương thức atan() trong Java trả về arctan của giá trị double đã cho.\n24. Phương thức atan2() trong Java biến đổi tọa độ (x, y) thành tọa độ cực (r, theta) và trả về theta.\n25. Phương thức toDegrees() trong Java biến đổi tham số thành giá trị độ đo góc.\n26. Phương thức toRadians() trong Java biến đổi tham số thành radian.\n27. Phương thức random() trong Java trả về một số ngẫu nhiên.int i = 5000; float gpa = 13.65; byte mask = 0xaf;\n\n, public class Test{ public static void main(String args[]){ Integer x = 5; //\ndong hop int thanh doi tuong Integer x = x + 10; // mo hop Integer thanh int\nSystem.out.println(x); } }\n\n, 15\n\n",
      "id": "1621"
    }
  },
  {
    "id": "172",
    "name": "Đối tượng Character",
    "href": "https://www.vietjack.com/java/character_trong_java.jsp",
    "lesson": {
      "title": "character trong java",
      "content": "* `toString()`: Trả về một chuỗi biểu diễn giá trị ký tự đã cho.\n* `toLowerCase()`: Trả về giá trị ký tự đã cho ở dạng chữ thường.\n* `toUpperCase()`: Trả về giá trị ký tự đã cho ở dạng chữ hoa.\n* `isLowerCase()`: Kiểm tra xem giá trị ký tự đã cho có phải là chữ thường hay không.\n* `isUpperCase()`: Kiểm tra xem giá trị ký tự đã cho có phải là chữ hoa hay không.\n* `isWhitespace()`: Kiểm tra xem giá trị ký tự đã cho có phải là khoảng trắng hay không.\n* `isDigit()`: Kiểm tra xem giá trị ký tự đã cho có phải là chữ số hay không.\n* `isLetter()`: Kiểm tra xem giá trị ký tự đã cho có phải là chữ cái hay không.**Ký tự ngắt:**\n\n- \\t: Thêm một tab vào văn bản.\n- \\b: Thêm một backspace vào văn bản.\n- \\n: Thêm một dòng mới vào văn bản.\n- \\r: Thêm một carriage return vào văn bản.\n- \\f: Thêm một form feed vào văn bản.\n- \\' : Thêm một dấu trích dẫn đơn vào văn bản.\n- \\\" : Thêm một dấu trích dẫn kép vào văn bản.\n- \\\\ : Thêm một ký tự dấu chéo ngược vào văn bản.\n\n**Phương thức và Miêu tả:**\n\n- isLetter(): Kiểm tra xem giá trị char đã cho có phải là một chữ cái hay không.\n- isDigit(): Kiểm tra xem giá trị char đã cho có phải là một chữ số hay không.\n- isWhitespace(): Kiểm tra xem giá trị char đã cho có phải là một khoảng trắng hay không.\n- isUpperCase(): Kiểm tra xem giá trị char đã cho có phải là chữ hoa hay không.\n- isLowerCase(): Kiểm tra xem giá trị char đã cho có phải là chữ thường hay không.\n- toUpperCase(): Trả về dạng chữ hoa của giá trị char đã cho.\n- toLowerCase(): Trả về dạng chữ thường của giá trị char đã cho.\n- toString(): Trả về một đối tượng String biểu diễn giá trị ký tự đã cho.char ch = 'a'; // Ma Unicode cho ky tu Greek omega dang chu hoa char uniChar =\n'\\u039A'; // Mot mang ky tu char[] charArray ={ 'a', 'b', 'c', 'd', 'e' };\n\n, Character ch = new Character('a');\n\n, // O day la kieu char goc 'a' // duoc dong hop thanh doi tuong Character la ch\nCharacter ch = 'a'; // Tai day kieu goc 'x' duoc dong hop cho phuong thuc\ntest, // gia tri tra ve duoc mo hop cho ky tu 'c' char c = test('x');\n\n, public class Test { public static void main(String args[]) {\nSystem.out.println(\"Co ta noi \\\"Hello!\\\" voi toi.\"); } }\n\n, Co ta noi \"Hello!\" voi toi.\n\n",
      "id": "1721"
    }
  },
  {
    "id": "13",
    "name": "Khái niệm OOP",
    "href": "https://www.vietjack.com/java/khai_niem_huong_doi_tuong_trong_java.jsp",
    "lesson": {
      "title": "khái niệm hướng đối tượng (oop) trong java",
      "content": "Lập trình hướng đối tượng (OOP) là một phương pháp thiết kế chương trình sử dụng các lớp và đối tượng. OOP giúp đơn giản hóa việc duy trì và phát triển phần mềm bằng cách cung cấp một số khái niệm.\n\nOOP có các đặc điểm sau:\n\n* **Tính kế thừa:** Một đối tượng có thể đạt được các thuộc tính và các hành vi của đối tượng cha. Điều này làm tăng tính tái sử dụng cho code và được sử dụng để đạt được tính đa hình tại runtime.\n* **Gắn kết dữ liệu:** Dữ liệu và các phương thức thao tác dữ liệu được đóng gói lại thành các đối tượng. Điều này giúp bảo vệ dữ liệu khỏi sự truy cập trái phép và tăng tính bảo mật cho chương trình.\n* **Tính đa hình:** Khi một tác vụ được thực hiện theo nhiều cách khác nhau, được gọi là tính đa hình. Trong Java, tính đa hình được đạt được thông qua nạp chồng phương thức (method overloading) và ghi đè phương thức (method overriding).\n* **Tính trừu tượng:** Ẩn các chi tiết nội tại và hiển thị tính năng. Trong Java, tính trừu tượng được đạt được thông qua lớp trừu tượng (abstract class) và giao diện trừu tượng (abstract interface).\n* **Tính bao đóng:** Gắn kết code và dữ liệu cùng với nhau vào trong một đơn vị (unit). Trong Java, lớp (class) là một ví dụ về tính bao đóng. Java bean là lớp bao đóng thực sự vì tất cả thành viên dữ liệu là private.\n\nOOP có nhiều ưu điểm như:\n\n* Dễ dàng thiết kế, phát triển và bảo trì.\n* Tăng tính tái sử dụng cho code.\n* Cải thiện hiệu quả của quá trình phát triển phần mềm.\n* Làm cho chương trình dễ hiểu và dễ đọc hơn.\n\nOOP được sử dụng rộng rãi trong phát triển phần mềm. Một số ngôn ngữ lập trình hướng đối tượng phổ biến bao gồm Java, C++, Python, C# và JavaScript.",
      "id": "131"
    }
  },
  {
    "id": "23",
    "name": "Lớp và Đối tượng",
    "href": "https://www.vietjack.com/java/lop_va_doi_tuong_trong_java.jsp",
    "lesson": {
      "title": "đối tượng và lớp (class) trong java",
      "content": "Trong Java, có nhiều cách để tạo đối tượng, bao gồm:\n\n- Từ khóa new: Được sử dụng để tạo một đối tượng mới.\n- Phương thức factory: Tạo đối tượng bằng cách gọi một phương thức factory.\n- Phương thức clone: Tạo đối tượng bằng cách sao chép một đối tượng hiện có.\n- Phương thức newInstance: Tạo đối tượng bằng cách sử dụng phương thức newInstance của lớp Class.\n\nMột đối tượng có ba đặc trưng: nhận diện, trạng thái và hành vi.\n\n- Nhận diện: Mỗi đối tượng có một id duy nhất để phân biệt với các đối tượng khác.\n- Trạng thái: Biểu diễn dữ liệu hoặc giá trị của một đối tượng.\n- Hành vi: Biểu diễn các tính năng hoặc chức năng của một đối tượng.\n\nLớp là một nhóm các đối tượng có các thuộc tính chung. Lớp là một template hoặc bản thiết kế từ đó đối tượng được tạo. Một lớp trong Java có thể bao gồm:\n\n- Biến class: Được khai báo với một lớp bên ngoài bất kỳ phương thức nào với từ khóa static.\n- Biến instance: Được khai báo trong một lớp nhưng bên ngoài bất kỳ phương thức nào.\n- Biến local: Được định nghĩa bên trong các phương thức constructor hoặc block code.\n\nĐối tượng là instance của một lớp. Lớp là một template hoặc bản thiết kế từ đó đối tượng được tạo. Vì thế, đối tượng là instance kết quả của một lớp.class ten_lop{ thanh_vien_du_lieu; phuong_thuc; }\n\n, class Student1{ int id; //thanh vien du lieu (cung la bien instance) String\nname; //thanh vien du lieu (cung la bien instance) public static void\nmain(String args[]){ Student1 s1=new Student1(); //tao mot doi tuong Student\nSystem.out.println(s1.id); System.out.println(s1.name); } }\n\n, public class Xecon{ public Xecon(){ } public Xecon(String ten){ // Contructor\nnay co mot tham so la ten. } }\n\n, public class Xecon{ public Xecon(String ten){ // Contructor nay co mot tham so\nla ten. System.out.println(\"Ten xe la :\" + ten ); } public static void\nmain(String []args){ // Lenh sau se tao mot doi tuong la Xecuatoi Xecon\nXecuatoi = new Xecon( \"Toyota\" ); } }\n\n, Ten xe la :Toyota\n\n, /* Dau tien, ban tao mot doi tuong */ Doituongthamchieu = new Constructor();\n/* Sau do ban goi mot bien nhu sau */ Doituongthamchieu.TenBien; /* Bay gio\nban co the goi mot phuong thuc lop nhu sau */\nDoituongthamchieu.TenPhuongThuc();\n\n, public class Xecon{ int Giaxe; public Xecon(String ten){ // Contructor nay co\nmot tham so la ten. System.out.println(\"Ten xe la :\" + ten ); } public void\nsetGia( int gia ){ Giaxe = gia; } public int getGia( ){\nSystem.out.println(\"Gia mua xe la :\" + Giaxe ); return Giaxe; } public static\nvoid main(String []args){ /* Tao doi tuong */ Xecon Xecuatoi = new Xecon(\n\"Toyota\" ); /* Goi mot phuong thuc lop de thiet lap gia xe */ Xecuatoi.setGia(\n1000000000 ); /* Goi mot phuong thuc lop khac de lay gia xe */\nXecuatoi.getGia( ); /* Ban cung co the truy cap bien instance nhu sau */\nSystem.out.println(\"Gia tri bien :\" + Xecuatoi.Giaxe ); } }\n\n, Ten xe la :Toyota Gia mua xe la :1000000000 Gia tri bien :1000000000\n\n, class Student2{ int rollno; String name; void insertRecord(int r, String n){\n//phuong thuc rollno=r; name=n; } void\ndisplayInformation(){System.out.println(rollno+\" \"+name);} //phuong thuc\npublic static void main(String args[]){ Student2 s1=new Student2(); Student2\ns2=new Student2(); s1.insertRecord(111,\"HoangThanh\");\ns2.insertRecord(222,\"ThanhHuong\"); s1.displayInformation();\ns2.displayInformation(); } }\n\n, class Rectangle{ int length; int width; void insert(int l,int w){ length=l;\nwidth=w; } void calculateArea(){System.out.println(length*width);} public\nstatic void main(String args[]){ Rectangle r1=new Rectangle(); Rectangle\nr2=new Rectangle(); r1.insert(11,5); r2.insert(3,15); r1.calculateArea();\nr2.calculateArea(); } }\n\n, class Calculation{ void fact(int n){ int fact=1; for(int i=1;i<=n;i++){\nfact=fact*i; } System.out.println(\"factorial is \"+fact); } public static void\nmain(String args[]){ new Calculation().fact(5); //Goi phuong thuc voi doi\ntuong vo danh (annonymous) } }\n\n, Rectangle r1=new Rectangle(),r2=new Rectangle(); //Tao hai doi tuong\n\n, class Rectangle{ int length; int width; void insert(int l,int w){ length=l;\nwidth=w; } void calculateArea(){System.out.println(length*width);} public\nstatic void main(String args[]){ Rectangle r1=new Rectangle(),r2=new\nRectangle(); //Tao hai doi tuong r1.insert(11,5); r2.insert(3,15);\nr1.calculateArea(); r2.calculateArea(); } }\n\n, Output:55 45\n\n",
      "id": "231"
    }
  },
  {
    "id": "33",
    "name": "Phương thức",
    "href": "https://www.vietjack.com/java/phuong_thuc_trong_java.jsp",
    "lesson": {
      "title": "phương thức trong java",
      "content": "* **Phương thức:** Là một tập hợp các lệnh được nhóm lại với nhau để thực hiện một hành động cụ thể.\n* **Phương thức không trả về giá trị:** Là phương thức không có kiểu trả về, sau khi thực thi xong sẽ trả về một giá trị rỗng.\n* **Phương thức trả về giá trị:** Là phương thức có kiểu trả về, sau khi thực thi xong sẽ trả về một giá trị cụ thể.\n* **Tham số:** Là biến được truyền vào phương thức để sử dụng trong phương thức đó.\n* **Danh sách tham số:** Là danh sách các tham số được truyền vào phương thức, được đặt trong dấu ngoặc đơn sau tên phương thức.\n* **Tên phương thức:** Là tên của phương thức, được đặt trước danh sách tham số.\n* **Kiểu trả về:** Là kiểu dữ liệu của giá trị trả về của phương thức, được đặt trước tên phương thức.\n* **Modifier:** Là từ khóa chỉ định phạm vi truy cập của phương thức, có thể là public, protected, private hoặc default.\n* **Phần thân phương thức:** Là phần chứa các lệnh của phương thức, được đặt trong dấu ngoặc nhọn sau tên phương thức.\n* **Gọi phương thức:** Là sử dụng tên phương thức để thực thi các lệnh trong phương thức đó.\n* **Tải phương thức:** Là quá trình nạp phương thức vào bộ nhớ khi phương thức được gọi.\n* **Phương thức trừu tượng:** Là phương thức không có phần thân phương thức, được khai báo bằng từ khóa abstract.\n* **Thiết kế chương trình:** Là quá trình tạo ra một chương trình máy tính bằng cách sử dụng các phương thức và các thành phần khác của ngôn ngữ lập trình.public static int tenPhuongThuc(int a, int b) { // phan than phuong thuc }\n\n, modifier kieuTraVe tenPhuongThuc (Danh sach tham so) { // Than phuong thuc }\n\n, /** Vi du code tra ve so nho nhat cua hai so */ public static int\nminFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else min = n1;\nreturn min; }\n\n, System.out.println(\"Day la Vietjack.com!\");\n\n, int result = sum(6, 9);\n\n, public class ExampleMinNumber{ public static void main(String[] args) { int a\n= 11; int b = 6; int c = minFunction(a, b); System.out.println(\"Gia tri nho\nnhat = \" + c); } /** Tra ve gia tri nho nhat cua hai so */ public static int\nminFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else min = n1;\nreturn min; } }\n\n, Gia tri nho nhat = 6\n\n, public class ExampleVoid { public static void main(String[] args) {\nmethodRankPoints(255.7); } public static void methodRankPoints(double points)\n{ if (points >= 202.5) { System.out.println(\"Rank:A1\"); } else if (points >=\n122.4) { System.out.println(\"Rank:A2\"); } else {\nSystem.out.println(\"Rank:A3\"); } } }\n\n, Rank:A1\n\n, package edu.doannhg.basic; // vi du de trao doi gia tri cua hai so public\nclass Test { public static void main(String[] args) { int a = 30; int b = 45;\nSystem.out.println(\"Truoc khi trao doi, gia tri cua a = \" + a + \" va b = \" +\nb); // Trieu hoi phuong thuc hamTraoDoi hamTraoDoi(a, b);\nSystem.out.println(\"\\n**Bay gio, Truoc va Sau khi trao doi, cac gia tri se\ngiong nhu nhau o day**:\"); System.out.println(\"Sau khi trao doi, a = \" + a + \"\nva b = \" + b); } public static void hamTraoDoi(int a, int b) {\nSystem.out.println(\"Truoc khi trao doi (ben trong phuong thuc) , a = \" + a \\+\n\" va b = \" + b); // trao doi gia tri cua hai so int c = a; a = b; b = c;\nSystem.out.println(\"Sau khi trao doi (ben trong phuong thuc), a = \" + a \\+ \"\nva b = \" + b); } }\n\n, Truoc khi trao doi, gia tri cua a = 30 va b = 45 Truoc khi trao doi (ben trong\nphuong thuc) , a = 30 va b = 45 Sau khi trao doi (ben trong phuong thuc), a =\n45 va b = 30 **Bay gio, Truoc va Sau khi trao doi, cac gia tri se giong nhu\nnhau o day**: Sau khi trao doi, a = 30 va b = 45\n\n, public class ExampleOverloading{ public static void main(String[] args) { int\na = 11; int b = 6; double c = 7.3; double d = 9.4; int result1 =\nminFunction(a, b); // cung ten ham voi tham so khac nhau double result2 =\nminFunction(c, d); System.out.println(\"Gia tri nho nhat = \" + result1);\nSystem.out.println(\"Gia tri nho nhat = \" + result2); } // cho integer public\nstatic int minFunction(int n1, int n2) { int min; if (n1 > n2) min = n2; else\nmin = n1; return min; } // cho double public static double minFunction(double\nn1, double n2) { double min; if (n1 > n2) min = n2; else min = n1; return min;\n} }\n\n, Gia tri nho nhat = 6 Gia tri nho nhat = 7.3\n\n, public class CommandLine { public static void main(String args[]){ for(int\ni=0; i<args.length; i++){ System.out.println(\"args[\" + i + \"]: \" + args[i]); }\n} }\n\n, java CommandLine this is a command line 200 -100\n\n, args[0]: this args[1]: is args[2]: a args[3]: command args[4]: line args[5]:\n200 args[6]: -100\n\n, // Mot constructor. class MyClass { int x; // Sau day la constructor MyClass()\n{ x = 10; } }\n\n, public class ConsDemo { public static void main(String args[]) { MyClass t1 =\nnew MyClass(); MyClass t2 = new MyClass(); System.out.println(t1.x + \" \" +\nt2.x); } }\n\n, // Mot constructor. class MyClass { int x; // Sau day la constructor\nMyClass(int i ) { x = i; } }\n\n, public class ConsDemo { public static void main(String args[]) { MyClass t1 =\nnew MyClass( 10 ); MyClass t2 = new MyClass( 20 ); System.out.println(t1.x + \"\n\" + t2.x); } }\n\n, 10 20\n\n, tenKieu... tenThamSo\n\n, public class VarargsDemo { public static void main(String args[]) { // Goi\nphuong thuc voi bien args printMax(34, 3, 3, 2, 56.5); printMax(new\ndouble[]{1, 2, 3}); } public static void printMax( double... numbers) { if\n(numbers.length == 0) { System.out.println(\"Khong co tham so nao duoc\ntruyen\"); return; } double result = numbers[0]; for (int i = 1; i <\nnumbers.length; i++) if (numbers[i] > result) result = numbers[i];\nSystem.out.println(\"Gia tri max la \" + result); } }\n\n, Gia tri max la 56.5 Gia tri max la 3.0\n\n, protected void finalize( ) { // tai day la phan code ket thuc }\n\n",
      "id": "331"
    }
  },
  {
    "id": "43",
    "name": "Nạp chồng phương thức (Overloading)",
    "href": "https://www.vietjack.com/java/overloading_trong_java.jsp",
    "lesson": {
      "title": "nạp chồng phương thức trong java",
      "content": "- Nạp chồng phương thức xảy ra khi hai hoặc nhiều phương thức có cùng tên nhưng khác nhau về số lượng tham số hoặc kiểu tham số.\n- Nếu không có kiểu tham số nào được cung cấp trong phương thức và mỗi phương thức có cùng số lượng tham số, thì đó là trường hợp mơ hồ.\n- Nếu có kiểu tham số trong phương thức, thì không thực hiện typepromotion.\n- Một kiểu có thể được promote thành một kiểu khác nếu không tìm thấy kiểu dữ liệu nào được kết nối.\n- Bạn có thể có bất kỳ số lượng phương thức main nào trong một lớp bằng cách nạp chồng phương thức.\n- Nạp chồng phương thức không thể thực hiện bằng cách thay đổi kiểu trả về của phương thức.\n- Nạp chồng phương thức có thể thực hiện bằng cách thay đổi kiểu dữ liệu hoặc số lượng tham số.class Calculation{ void sum(int a,int b){System.out.println(a+b);} void\nsum(int a,int b,int c){System.out.println(a+b+c);} public static void\nmain(String args[]){ Calculation obj=new Calculation(); obj.sum(10,10,10);\nobj.sum(20,20); } }\n\n, Output:30 40\n\n, class Calculation2{ void sum(int a,int b){System.out.println(a+b);} void\nsum(double a,double b){System.out.println(a+b);} public static void\nmain(String args[]){ Calculation2 obj=new Calculation2(); obj.sum(10.5,10.5);\nobj.sum(20,20); } }\n\n, Output:21.0 40\n\n, class Calculation3{ int sum(int a,int b){System.out.println(a+b);} double\nsum(int a,int b){System.out.println(a+b);} public static void main(String\nargs[]){ Calculation3 obj=new Calculation3(); int result=obj.sum(20,20); //Gay\nra Compile Time Error } }\n\n, class Overloading1{ public static void main(int a){ System.out.println(a); }\npublic static void main(String args[]){ System.out.println(\"Phuong thuc main()\nduoc trieu hoi\"); main(10); } }\n\n, class OverloadingCalculation1{ void sum(int a,long\nb){System.out.println(a+b);} void sum(int a,int b,int\nc){System.out.println(a+b+c);} public static void main(String args[]){\nOverloadingCalculation1 obj=new OverloadingCalculation1(); obj.sum(20,20);\n//Bay gio int literal thu hai se duoc promote thanh long obj.sum(20,20,20); }\n}\n\n, class OverloadingCalculation2{ void sum(int a,int\nb){System.out.println(\"phuong thuc int arg duoc trieu hoi\");} void sum(long\na,long b){System.out.println(\"phuong thuc long arg duoc trieu hoi\");} public\nstatic void main(String args[]){ OverloadingCalculation2 obj=new\nOverloadingCalculation2(); obj.sum(20,20); //Bay gio phuong thuc int arg sum()\nduoc trieu hoi } }\n\n, class OverloadingCalculation3{ void sum(int a,long\nb){System.out.println(\"Phuong thuc a duoc trieu hoi\");} void sum(long a,int\nb){System.out.println(\"Phuong thuc b duoc trieu hoi\");} public static void\nmain(String args[]){ OverloadingCalculation3 obj=new\nOverloadingCalculation3(); obj.sum(20,20); //Khong co tinh luong nghia o day }\n}\n\n, Output:Compile Time Error\n\n",
      "id": "431"
    }
  },
  {
    "id": "53",
    "name": "Constructor",
    "href": "https://www.vietjack.com/java/constructor_trong_java.jsp",
    "lesson": {
      "title": "constructor trong java",
      "content": "- Constructor trong Java là một phương thức đặc biệt được sử dụng để khởi tạo đối tượng. Nó được gọi khi một đối tượng mới được tạo ra.\n- Constructor có cùng tên với lớp và không có kiểu trả về.\n- Constructor có thể được nạp chồng, nghĩa là một lớp có thể có nhiều constructor khác nhau.\n- Có hai loại constructor: constructor mặc định và constructor được tham số hóa.\n- Constructor mặc định không có tham số và được compiler tạo ra nếu không có constructor nào được định nghĩa trong lớp.\n- Constructor được tham số hóa có các tham số và được sử dụng để cung cấp các giá trị khác nhau cho các đối tượng riêng biệt.\n- Constructor được gọi khi một đối tượng mới được tạo ra. Nó xây dựng giá trị cung cấp dữ liệu cho đối tượng đó là lý nó được gọi là constructor.* Constructor được dùng để khởi tạo trạng thái của đối tượng trong khi phương thức dùng để thể hiện hành vi của đối tượng.\n* Constructor không có kiểu trả về trong khi phương thức phải có kiểu trả về.\n* Constructor được gọi ngầm định trong khi phương thức được gọi tường minh.\n* Nếu bạn không có constructor nào thì compiler sẽ cung cấp một constructor mặc định, nhưng phương thức không được cung cấp bởi compiler trong bất kỳ trường hợp nào.\n* Tên constructor phải giống với tên lớp trong khi tên phương thức có thể giống hoặc không giống với tên lớp.public class Xecon{ public Xecon(){ } public Xecon(String ten){ // Contructor\nnay co mot tham so la ten. } }\n\n, ten_lop(){}\n\n, class Bike1{ Bike1(){System.out.println(\"Bike duoc tao\");} public static void\nmain(String args[]){ Bike1 b=new Bike1(); } }\n\n, class Student3{ int id; String name; void display(){System.out.println(id+\"\n\"+name);} public static void main(String args[]){ Student3 s1=new Student3();\nStudent3 s2=new Student3(); s1.display(); s2.display(); } }\n\n, class Student4{ int id; String name; Student4(int i,String n){ id = i; name =\nn; } void display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student4 s1 = new Student4(111,\"Karan\"); Student4 s2 =\nnew Student4(222,\"Aryan\"); s1.display(); s2.display(); } }\n\n, class Student5{ int id; String name; int age; Student5(int i,String n){ id =\ni; name = n; } Student5(int i,String n,int a){ id = i; name = n; age=a; } void\ndisplay(){System.out.println(id+\" \"+name+\" \"+age);} public static void\nmain(String args[]){ Student5 s1 = new Student5(111,\"Hoang\"); Student5 s2 =\nnew Student5(222,\"Thanh\",25); s1.display(); s2.display(); } }\n\n, class Student6{ int id; String name; Student6(int i,String n){ id = i; name =\nn; } Student6(Student6 s){ id = s.id; name =s.name; } void\ndisplay(){System.out.println(id+\" \"+name);} public static void main(String\nargs[]){ Student6 s1 = new Student6(111,\"Hoang\"); Student6 s2 = new\nStudent6(s1); s1.display(); s2.display(); } }\n\n, class Student7{ int id; String name; Student7(int i,String n){ id = i; name =\nn; } Student7(){} void display(){System.out.println(id+\" \"+name);} public\nstatic void main(String args[]){ Student7 s1 = new Student7(111,\"Hoang\");\nStudent7 s2 = new Student7(); s2.id=s1.id; s2.name=s1.name; s1.display();\ns2.display(); } }\n\n",
      "id": "531"
    }
  },
  {
    "id": "63",
    "name": "Từ khóa static",
    "href": "https://www.vietjack.com/java/tu_khoa_static_trong_java.jsp",
    "lesson": {
      "title": "từ khóa static trong java",
      "content": "- Khối static trong phiên bản trước của jdk không còn trong jdk 17, chúng ta có thể thực thi một chương trình mà không có phương thức main.\n- Khối static được sử dụng để khởi tạo thành viên dữ liệu static, nó được thực thi trước phương thức main tại thời gian tải lớp.\n- Phương thức static không thể sử dụng thành viên dữ liệu nonstatic hoặc gọi trực tiếp phương thức nonstatic.\n- Biến static sẽ lấy bộ nhớ chỉ một lần, nếu bất cứ đối tượng nào thay đổi giá trị của biến static, nó sẽ vẫn ghi nhớ giá trị của nó.\n- Thuộc tính static trong java được chia sẻ tới tất cả đối tượng.\n- Biến static giúp bộ nhớ chương trình của bạn được sử dụng hiệu quả hơn, tiết kiệm bộ nhớ.\n- Biến static lấy bộ nhớ chỉ một lần trong class area tại thời gian tải lớp đó.\n- Biến static có thể được sử dụng để tham chiếu thuộc tính chung của tất cả đối tượng mà không là duy nhất cho mỗi đối tượng.\n- Từ khóa static trong java được sử dụng chính để quản trị bộ nhớ, chúng ta có thể áp dụng từ khóa static với biến (còn gọi là biến lớp, biến class), phương thức (còn gọi là phương thức lớp, method class) và khối.\n- Các lớp được lặp từ khóa static thuộc về lớp chứ không thuộc về instance, sự thể hiện của lớp.class Student{ int rollno; String name; String college=\"BachKhoa\"; }\n\n, //Chuong trinh vi du ve bien static trong Java class Student8{ int rollno;\nString name; static String college =\"BachKhoa\"; Student8(int r,String n){\nrollno = r; name = n; } void display (){System.out.println(rollno+\" \"+name+\"\n\"+college);} public static void main(String args[]){ Student8 s1 = new\nStudent8(111,\"Hoang\"); Student8 s2 = new Student8(222,\"Thanh\"); s1.display();\ns2.display(); } }\n\n, class Counter{ int count=0; //se lay bo nho (memory) khi bien instance duoc\ntao //Ket qua thuc hien chuong trinh hien ra 3 so 1 o 3 dong Counter(){\ncount++; System.out.println(count); } public static void main(String args[]){\nCounter c1=new Counter(); Counter c2=new Counter(); Counter c3=new Counter();\n} }\n\n, class Counter2{ static int count=0; //se lay bo nho chi mot lan và giu lai gia\ntri cua no //ket qua thuc hien in ra 3 dong cac gia tri : 1,2,3 Counter2(){\ncount++; System.out.println(count); } public static void main(String args[]){\nCounter2 c1=new Counter2(); Counter2 c2=new Counter2(); Counter2 c3=new\nCounter2(); } }\n\n, //Chuong trinh thay doi thuoc tinh chung cua tat ca doi tuong (truong static).\nclass Student9{ int rollno; String name; static String college = \"BachKhoa\";\nstatic void change(){ college = \"QuocGia\"; } Student9(int r, String n){ rollno\n= r; name = n; } void display (){System.out.println(rollno+\" \"+name+\"\n\"+college);} public static void main(String args[]){ Student9.change();\nStudent9 s1 = new Student9 (111,\"Hoang\"); Student9 s2 = new Student9\n(222,\"Thanh\"); Student9 s3 = new Student9 (333,\"Nam\"); s1.display();\ns2.display(); s3.display(); } }\n\n, //Chuong trinh lay cube (gia tri lap phuong) cua so da cho boi phuong thuc\nstatic class Calculate{ static int cube(int x){ return x*x*x; } public static\nvoid main(String args[]){ int result=Calculate.cube(5);\nSystem.out.println(result); } }\n\n, class A{ int a=40;//non static public static void main(String args[]){\nSystem.out.println(a); } }\n\n, class A2{ static{System.out.println(\"Khoi static duoc trieu hoi\");} public\nstatic void main(String args[]){ System.out.println(\"Hello main\"); } }\n\n, class A3{ static{ System.out.println(\"Khoi static duoc trieu hoi\");\nSystem.exit(0); } }\n\n",
      "id": "631"
    }
  },
  {
    "id": "73",
    "name": "Từ khóa this",
    "href": "https://www.vietjack.com/java/tu_khoa_this_trong_java.jsp",
    "lesson": {
      "title": "từ khóa this trong java",
      "content": "Trong Java, từ khóa `this` có nhiều cách sử dụng khác nhau.\n\n* Tham chiếu đến biến thể hiện của lớp hiện tại.\n* Có thể được truyền như một tham số trong lời gọi hàm tạo.\n* Có thể được truyền như một tham số trong lời gọi phương thức.\n* Có thể được sử dụng để gọi ngầm định phương thức của lớp hiện tại.\n* Có thể được sử dụng để gọi hàm tạo của lớp hiện tại.\n* Có thể được sử dụng để trả về thể hiện của lớp hiện tại.\n\nTrong Java, có sáu cách sử dụng từ khóa `this`.\n\n* Để tham chiếu đến biến thể hiện của lớp hiện tại.\n* Để truyền như một tham số trong lời gọi hàm tạo.\n* Để truyền như một tham số trong lời gọi phương thức.\n* Để gọi ngầm định phương thức của lớp hiện tại.\n* Để gọi hàm tạo của lớp hiện tại.\n* Để trả về thể hiện của lớp hiện tại.class Student10{ int id; String name; Student10(int id,String name){ id = id;\nname = name; } void display(){System.out.println(id+\" \"+name);} public static\nvoid main(String args[]){ Student10 s1 = new Student10(111,\"Hoang\"); Student10\ns2 = new Student10(321,\"Thanh\"); s1.display(); s2.display(); } }\n\n, //Vi du ve tu khoa this trong Java class Student11{ int id; String name;\nStudent11(int id,String name){ this.id = id; this.name = name; } void\ndisplay(){System.out.println(id+\" \"+name);} public static void main(String\nargs[]){ Student11 s1 = new Student11(111,\"Hoang\"); Student11 s2 = new\nStudent11(222,\"Thanh\"); s1.display(); s2.display(); } }\n\n, class Student12{ int id; String name; Student12(int i,String n){ id = i; name\n= n; } void display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student12 e1 = new Student12(111,\"Hoang\"); Student12 e2 =\nnew Student12(222,\"Thanh\"); e1.display(); e2.display(); } }\n\n, //Chuong trinh vi du loi goi this() constructor (constructor chaining) class\nStudent13{ int id; String name; Student13(){System.out.println(\"Constructor\nmac dinh duoc goi\");} Student13(int id,String name){ this (); //no duoc su\ndung de goi constructor cua lop hien tai. this.id = id; this.name = name; }\nvoid display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student13 e1 = new Student13(111,\"Hoang\"); Student13 e2 =\nnew Student13(222,\"Thanh\"); e1.display(); e2.display(); } }\n\n, class Student14{ int id; String name; String city; Student14(int id,String\nname){ this.id = id; this.name = name; } Student14(int id,String name,String\ncity){ this(id,name); //Bay gio khong can khoi tao id va name this.city=city;\n} void display(){System.out.println(id+\" \"+name+\" \"+city);} public static void\nmain(String args[]){ Student14 e1 = new Student14(111,\"Hoang\"); Student14 e2 =\nnew Student14(222,\"Thanh\",\"NamDinh\"); e1.display(); e2.display(); } }\n\n, class Student15{ int id; String name;\nStudent15(){System.out.println(\"Constructor mac dinh duoc trieu hoi\");}\nStudent15(int id,String name){ id = id; name = name; this (); //phai la lenh\ndau tien } void display(){System.out.println(id+\" \"+name);} public static void\nmain(String args[]){ Student15 e1 = new Student15(111,\"Hoang\"); Student15 e2 =\nnew Student15(222,\"Thanh\"); e1.display(); e2.display(); } }\n\n, class S{ void m(){ System.out.println(\"Phuong thuc duoc trieu hoi\"); } void\nn(){ this.m(); //khong can boi vi compiler thuc hien no cho ban. } void p(){\nn(); //complier se them this de trieu hoi phuong thuc n() duoi dang this.n() }\npublic static void main(String args[]){ S s1 = new S(); s1.p(); } }\n\n, class S2{ void m(S2 obj){ System.out.println(\"Phuong thuc duoc trieu hoi\"); }\nvoid p(){ m(this); } public static void main(String args[]){ S2 s1 = new S2();\ns1.p(); } }\n\n, class B{ A4 obj; B(A4 obj){ this.obj=obj; } void display(){\nSystem.out.println(obj.data); //su dung thanh vien du lieu cua lop A4 } }\nclass A4{ int data=10; A4(){ B b=new B(this); b.display(); } public static\nvoid main(String args[]){ A4 a=new A4(); } }\n\n, kieu_tra_ve ten_phuong_thuc(){ return this; }\n\n, class A{ A getA(){ return this; } void msg(){System.out.println(\"Hello\nWorld\");} } class Test1{ public static void main(String args[]){ new\nA().getA().msg(); } }\n\n, class A5{ void m(){ System.out.println(this);//in ra cung tham chieu ID }\npublic static void main(String args[]){ A5 obj=new A5();\nSystem.out.println(obj);//in tham chieu ID obj.m(); } }\n\n",
      "id": "731"
    }
  },
  {
    "id": "83",
    "name": "Tính kế thừa (IS-A)",
    "href": "https://www.vietjack.com/java/tinh_ke_thua_trong_java.jsp",
    "lesson": {
      "title": "tính kế thừa trong java - từ khóa extends và implements trong java",
      "content": "Trong lập trình Java, kế thừa là một kỹ thuật cho phép tạo ra các lớp mới từ các lớp hiện có. Điều này giúp bạn có thể tái sử dụng mã code và mở rộng các lớp hiện có để tạo ra các lớp mới với các chức năng bổ sung.\n\nTrong Java, có hai loại kế thừa chính: kế thừa đơn và kế thừa đa cấp. Kế thừa đơn là khi một lớp chỉ kế thừa từ một lớp khác. Kế thừa đa cấp là khi một lớp kế thừa từ nhiều lớp khác.\n\nJava không hỗ trợ kế thừa đa cấp, vì điều này có thể dẫn đến các vấn đề về độ phức tạp và tính mơ hồ của mã code. Ví dụ, nếu một lớp kế thừa từ hai lớp khác có cùng một phương thức, thì khi bạn gọi phương thức đó từ đối tượng của lớp con, Java sẽ không biết nên gọi phương thức của lớp nào.\n\nĐể giải quyết vấn đề này, Java hỗ trợ kế thừa đa cấp thông qua giao diện (interface). Giao diện là một tập hợp các phương thức mà các lớp có thể triển khai (implement). Khi một lớp triển khai một giao diện, thì lớp đó phải cung cấp các triển khai cho tất cả các phương thức của giao diện đó.\n\nKế thừa đa cấp thông qua giao diện cho phép bạn tạo ra các lớp có thể có nhiều chức năng khác nhau. Ví dụ, bạn có thể tạo một lớp triển khai nhiều giao diện khác nhau, mỗi giao diện đại diện cho một chức năng khác nhau.\n\nKế thừa là một tính năng mạnh mẽ trong Java cho phép bạn tạo ra các lớp mới từ các lớp hiện có. Điều này giúp bạn có thể tái sử dụng mã code và mở rộng các lớp hiện có để tạo ra các lớp mới với các chức năng bổ sung.class ten_lop_con extends ten_lop_cha { //cac phuong thuc va cac truong }\n\n, class Employee{ float salary=40000; } class Programmer extends Employee{ int\nbonus=10000; public static void main(String args[]){ Programmer p=new\nProgrammer(); System.out.println(\"Luong Lap trinh vien la:\"+p.salary);\nSystem.out.println(\"Bonus cua Lap trinh vien la:\"+p.bonus); } }\n\n, class A{ void msg(){System.out.println(\"Hello\");} } class B{ void\nmsg(){System.out.println(\"Welcome\");} } class C extends A,B { //gia su neu no\nda co Public Static void main(String args[]){ C obj=new C(); obj.msg();//Bay\ngio phuong thuc msg() nao se duoc goi? } }\n\n, public interface A {} public class B implements A{ } public class C extends B{\n}\n\n, interface A{} class B implements A{} public class C extends B{ public static\nvoid main(String args[]){ B m = new B(); C d = new C(); System.out.println(m\ninstanceof A); System.out.println(d instanceof B); System.out.println(d\ninstanceof A); } }\n\n, true true true\n\n, public class Vehicle{} public class Speed{} public class Van extends Vehicle{\nprivate Speed sp; }\n\n, public class C extends A, B{}\n\n",
      "id": "831"
    }
  },
  {
    "id": "93",
    "name": "Quan hệ (HAS-A)",
    "href": "https://www.vietjack.com/java/quan_he_has_a_trong_java.jsp",
    "lesson": {
      "title": "quan hệ has-a trong java",
      "content": "chạy chương trình trên sẽ cho kết quả, tệp empjava có nội dung sau, tệp addressjava có nội dung, như trong ví dụ trên đã đề cập employee có một đối tượng là address đối tượng này chứa thông tin riêng như city state country trong tình huống này mối quan hệ là employee hasa address, trong ví dụ chúng ta tạo tham chiếu của lớp operation trong lớp circle, tính kế thừa nên chỉ được sử dụng nếu mối quan hệ isa được duy trì thông qua suốt vòng đời của đối tượng có liên quan nếu không thì quan hệ hasa là lựa chọn tốt nhất, sử dụng quan hệ hasa giúp làm tăng tính tái sử dụng của code và khi không có mối quan hệ isa thì quan hệ hasa là lựa chọn tốt nhất, trong tình huống như vậy emloyee có một address là tham chiếu thực thể vì thế mối quan hệ là employee hasa address, nếu một lớp có một tham chiếu thực thể thì nó được biết đến như là một lớp có quan hệ hasa giả sử một tình huống đối tượng employee chứa nhiều thông tin như id name eamailid nó gồm một hoặc nhiều đối tượng address mà có thông tin riêng như city state country zipcode như sauclass Employee{ int id; String name; Address address; //Address la mot lop ...\n}\n\n, class Operation{ int square(int n){ return n*n; } } class Circle{ Operation\nop; //quan hệ HAS-A double pi=3.14; double area(int radius){ op=new\nOperation(); int rsquare=op.square(radius); //tai su dung code (vi du: uy\nquyen cho loi goi phuong thuc). return pi*rsquare; } public static void\nmain(String args[]){ Circle c=new Circle(); double result=c.area(5);\nSystem.out.println(result); } }\n\n, public class Address { String city,state,country; public Address(String city,\nString state, String country) { this.city = city; this.state = state;\nthis.country = country; } }\n\n, public class Emp { int id; String name; Address address; public Emp(int id,\nString name,Address address) { this.id = id; this.name = name;\nthis.address=address; } void display(){ System.out.println(id+\" \"+name);\nSystem.out.println(address.city+\" \"+address.state+\" \"+address.country); }\npublic static void main(String[] args) { Address address1=new\nAddress(\"hanoi\",\"HN\",\"vietnam\"); Address address2=new\nAddress(\"hadong\",\"HN\",\"vietnam\"); Emp e=new Emp(111,\"hoang\",address1); Emp\ne2=new Emp(112,\"thanh\",address2); e.display(); e2.display(); } }\n\n, Output:111 hoang hanoi HN vietnam 112 thanh hadong HN vietnam\n\n",
      "id": "931"
    }
  },
  {
    "id": "103",
    "name": "Ghi đè phương thức (Overriding)",
    "href": "https://www.vietjack.com/java/overriding_trong_java.jsp",
    "lesson": {
      "title": "ghi đè phương thức trong java",
      "content": "Ghi đè phương thức và nạp chồng phương thức là hai khái niệm khác nhau trong lập trình Java. Bảng dưới đây liệt kê các điểm khác biệt chính giữa hai khái niệm này:\n\n| Tính chất | Ghi đè phương thức | Nạp chồng phương thức |\n|---|---|---|\n| Tính chất tĩnh | Không thể ghi đè | Có thể nạp chồng |\n| Vị trí liên kết | Liên kết động | Liên kết tĩnh |\n| Mối quan hệ lớp | Yêu cầu mối quan hệ kế thừa | Không yêu cầu mối quan hệ kế thừa |\n| Tham số | Phải có cùng tham số | Có thể có các tham số khác nhau |\n| Trả về | Phải có cùng kiểu trả về | Có thể có các kiểu trả về khác nhau |\n\nGhi đè phương thức được sử dụng để cung cấp một triển khai cụ thể của một phương thức đã được cung cấp bởi lớp cha của nó. Điều này cho phép các lớp con tùy chỉnh hành vi của các phương thức được kế thừa từ các lớp cha.\n\nNạp chồng phương thức được sử dụng để cung cấp nhiều triển khai khác nhau của cùng một phương thức trong cùng một lớp. Điều này cho phép các phương thức khác nhau được gọi với các tham số khác nhau và thực hiện các hành động khác nhau.\n\nVí dụ:\n\n```java\nclass Animal {\n    public void eat() {\n        System.out.println(\"Animal is eating\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void eat() {\n        System.out.println(\"Dog is eating\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    public void eat() {\n        System.out.println(\"Cat is eating\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal animal = new Animal();\n        animal.eat(); // prints \"Animal is eating\"\n\n        Dog dog = new Dog();\n        dog.eat(); // prints \"Dog is eating\"\n\n        Cat cat = new Cat();\n        cat.eat(); // prints \"Cat is eating\"\n    }\n}\n```\n\nTrong ví dụ này, lớp `Animal` có một phương thức `eat()` được ghi đè bởi các lớp `Dog` và `Cat`. Điều này cho phép các lớp `Dog` và `Cat` tùy chỉnh hành vi của phương thức `eat()` để phù hợp với hành vi cụ thể của chúng.1. Nạp chồng phương thức làm cho chương trình dễ đọc hơn. Ghi đè phương thức cung cấp cách triển khai cụ thể của phương thức do lớp cha cung cấp.\n\n\n2. Nạp chồng phương thức được thực hiện trong một lớp. Ghi đè phương thức xuất hiện trong hai lớp có mối quan hệ kế thừa.\n\n\n3. Trong nạp chồng phương thức, các tham số phải khác nhau. Trong ghi đè phương thức, các tham số phải giống nhau.\n\n\n4. Nạp chồng phương thức là ví dụ của đa hình thời gian biên dịch. Ghi đè phương thức là ví dụ của đa hình thời gian chạy.\n\n\n5. Trong Java, không thể nạp chồng phương thức bằng cách thay đổi kiểu trả về. Kiểu trả về có thể giống hoặc khác trong nạp chồng phương thức, nhưng các tham số phải khác nhau. Trong ghi đè phương thức, kiểu trả về phải giống nhau hoặc là covariant.class Vehicle{ void run(){System.out.println(\"Vehicle dang chay\");} } class\nBike extends Vehicle{ public static void main(String args[]){ Bike obj = new\nBike(); obj.run(); } }\n\n, class Vehicle{ void run(){System.out.println(\"Vehicle dang chay\");} } class\nBike2 extends Vehicle{ void run(){System.out.println(\"Bike dang chay an\ntoan\");} public static void main(String args[]){ Bike2 obj = new Bike2();\nobj.run(); }\n\n, class Bank{ int getRateOfInterest(){return 0;} } class VCB extends Bank{ int\ngetRateOfInterest(){return 8;} } class AGR extends Bank{ int\ngetRateOfInterest(){return 7;} } class CTG extends Bank{ int\ngetRateOfInterest(){return 9;} } class Test2{ public static void main(String\nargs[]){ VCB s=new VCB(); AGR i=new AGR(); CTG a=new CTG();\nSystem.out.println(\"VCB Rate of Interest: \"+s.getRateOfInterest());\nSystem.out.println(\"AGR Rate of Interest: \"+i.getRateOfInterest());\nSystem.out.println(\"CTG Rate of Interest: \"+a.getRateOfInterest()); } }\n\n",
      "id": "1031"
    }
  },
  {
    "id": "113",
    "name": "Kiểu trả về Covariant",
    "href": "https://www.vietjack.com/java/kieu_tra_ve_covariant_trong_java.jsp",
    "lesson": {
      "title": "kiểu trả về covariant trong java",
      "content": "Nếu bạn là người mới học, bạn có thể bỏ qua chương này và tiếp tục theo dõi chương tiếp theo.\n\nTrong ví dụ trên, phương thức get của lớp a có kiểu trả về là a, nhưng phương thức get của lớp b có kiểu trả về là b. Cả hai phương thức có kiểu trả về khác nhau và đây được gọi là ghi đè phương thức.\n\nGhi đè phương thức còn được biết đến như là kiểu trả về covariant. Kiểu trả về covariant xác định rằng kiểu trả về có thể thay đổi trong lớp con. Tức là một phương thức có thể trả về kiểu hẹp hơn khi phương thức đó được override ở lớp con.\n\nTrước Java 5, không thể ghi đè bất kỳ phương thức nào bằng cách thay đổi kiểu trả về. Nhưng từ Java 5 trở đi, bạn có thể ghi đè phương thức bằng cách thay đổi kiểu trả về.\n\nNếu lớp con ghi đè bất kỳ phương thức nào mà có kiểu trả về không phải là kiểu gốc, bạn có thể theo dõi ví dụ đơn giản sau:class A{ A get(){return this;} } class B1 extends A{ B1 get(){return this;}\nvoid message(){System.out.println(\"Chao mung den voi kieu tra ve covariant\");}\npublic static void main(String args[]){ new B1().get().message(); } }\n\n",
      "id": "1131"
    }
  },
  {
    "id": "123",
    "name": "Từ khóa super",
    "href": "https://www.vietjack.com/java/tu_khoa_super_trong_java.jsp",
    "lesson": {
      "title": "từ khóa super trong java",
      "content": "Trong Java, từ khóa `super` được sử dụng để tham chiếu đến đối tượng lớp cha gần nhất. Nó có thể được sử dụng để truy cập các phương thức, thuộc tính và constructor của lớp cha.\n\n* **Triệu hồi phương thức lớp cha:** Nếu một lớp con có cùng phương thức với lớp cha, thì bạn có thể sử dụng từ khóa `super` để gọi phương thức của lớp cha. Điều này có thể hữu ích khi bạn muốn ghi đè phương thức của lớp cha nhưng vẫn muốn giữ lại chức năng ban đầu của phương thức đó.\n* **Triệu hồi constructor lớp cha:** Khi bạn tạo một đối tượng của lớp con, một đối tượng của lớp cha cũng được tạo ngầm định. Bạn có thể sử dụng từ khóa `super` để gọi constructor của lớp cha. Điều này có thể hữu ích khi bạn muốn khởi tạo các thuộc tính của lớp cha trước khi khởi tạo các thuộc tính của lớp con.\n* **Tham chiếu biến instance của lớp cha:** Nếu một lớp con có cùng thuộc tính với lớp cha, thì bạn có thể sử dụng từ khóa `super` để tham chiếu đến thuộc tính của lớp cha. Điều này có thể hữu ích khi bạn muốn truy cập các thuộc tính của lớp cha mà không cần phải tạo đối tượng của lớp cha.\n\nTừ khóa `super` là một công cụ mạnh mẽ có thể được sử dụng để truy cập các thành viên của lớp cha từ lớp con. Nó có thể giúp bạn viết mã hiệu quả và dễ bảo trì hơn.class Vehicle{ int speed=50; } class Bike3 extends Vehicle{ int speed=100;\nvoid display(){ System.out.println(speed); //se in speed cua Bike } public\nstatic void main(String args[]){ Bike3 b=new Bike3(); b.display(); } }\n\n, //Chuong trinh vi du tu khoa super class Vehicle{ int speed=50; } class Bike4\nextends Vehicle{ int speed=100; void display(){\nSystem.out.println(super.speed); //bay gio se in speed cua Vehicle } public\nstatic void main(String args[]){ Bike4 b=new Bike4(); b.display(); } }\n\n, class Vehicle{ Vehicle(){System.out.println(\"Vehicle duoc tao\");} } class\nBike5 extends Vehicle{ Bike5(){ super();//se trieu hoi constructor cua lop cha\nSystem.out.println(\"Bike duoc tao\"); } public static void main(String args[]){\nBike5 b=new Bike5(); } }\n\n, class Vehicle{ Vehicle(){System.out.println(\"Vehicle duoc tao\");} } class\nBike6 extends Vehicle{ int speed; Bike6(int speed){ this.speed=speed;\nSystem.out.println(speed); } public static void main(String args[]){ Bike6\nb=new Bike6(10); } }\n\n, class Person{ void message(){System.out.println(\"Chao mung\");} } class\nStudent16 extends Person{ void message(){System.out.println(\"Chao mung ban den\nvoi java\");} void display(){ message();//se trieu hoi phuong thuc message()\ncua lop hien tai super.message();//se trieu hoi phuong thuc message() cua lop\ncha } public static void main(String args[]){ Student16 s=new Student16();\ns.display(); } }\n\n, class Person{ void message(){System.out.println(\"Chao mung\");} } class\nStudent17 extends Person{ void display(){ message();//se trieu hoi phuong thuc\nmessage() cua lop cha } public static void main(String args[]){ Student17\ns=new Student17(); s.display(); } }\n\n",
      "id": "1231"
    }
  },
  {
    "id": "133",
    "name": "Từ khóa final",
    "href": "https://www.vietjack.com/java/tu_khoa_final_trong_java.jsp",
    "lesson": {
      "title": "từ khóa final trong java",
      "content": "- Từ khóa `final` được sử dụng trong Java để hạn chế người dùng.\n- `final` có thể được sử dụng trong nhiều ngữ cảnh: với biến, với phương thức và với lớp.\n- Nếu bạn khai báo bất kỳ tham số nào là `final`, thì bạn không thể thay đổi giá trị của nó.\n- Một biến `final` mà không được khởi tạo tại thời điểm khai báo được gọi là biến `final` trống hoặc biến `final` không được khởi tạo.\n- Biến `final` trống chỉ có thể được khởi tạo trong constructor.\n- Nếu bạn tạo bất kỳ phương thức nào là `final`, thì bạn không thể ghi đè nó.\n- Nếu bạn tạo bất kỳ lớp nào là `final`, thì bạn không thể kế thừa nó.class Bike9{ final int speedlimit=90;//bien final void run(){ speedlimit=400;\n} public static void main(String args[]){ Bike9 obj=new Bike9(); obj.run(); }\n}//phan cuoi cua lop\n\n, class Bike{ final void run(){System.out.println(\"running\");} } class Honda\nextends Bike{ void run(){System.out.println(\"Chay an toan voi 100kmph\");}\npublic static void main(String args[]){ Honda honda= new Honda(); honda.run();\n} }\n\n, final class Bike{} class Honda1 extends Bike{ void\nrun(){System.out.println(\"Chay an toan voi 100kmph\");} public static void\nmain(String args[]){ Honda1 honda= new Honda(); honda.run(); } }\n\n, class Bike{ final void run(){System.out.println(\"dang chay...\");} } class\nHonda2 extends Bike{ public static void main(String args[]){ new\nHonda2().run(); } }\n\n, class Student{ int id; String name; final String PAN_CARD_NUMBER; ... }\n\n, class Bike10{ final int speedlimit;//bien final trong Bike10(){ speedlimit=70;\nSystem.out.println(speedlimit); } public static void main(String args[]){ new\nBike10(); } }\n\n, class A{ static final int data;//bien static final trong static{ data=50;}\npublic static void main(String args[]){ System.out.println(A.data); } }\n\n, class Bike11{ int cube(final int n){ n=n+2;//khong the duoc thay doi khi n la\nfinal n*n*n; } public static void main(String args[]){ Bike11 b=new Bike11();\nb.cube(5); } }\n\n",
      "id": "1331"
    }
  },
  {
    "id": "143",
    "name": "Tính đa hình",
    "href": "https://www.vietjack.com/java/da_hinh_trong_java.jsp",
    "lesson": {
      "title": "đa hình trong java",
      "content": "Đa hình tại runtime trong Java cho phép một lời gọi đến một phương thức được ghi đè được xử lý tại thời điểm chạy thay vì thời điểm biên dịch. Trong quá trình này, một phương thức được ghi đè được gọi thông qua biến tham chiếu của lớp cha. Quyết định phương thức nào được gọi dựa trên đối tượng đang được tham chiếu bởi biến tham chiếu. Một biến tham chiếu có thể được hướng đến bất kỳ đối tượng nào với kiểu khai báo hoặc bất kỳ kiểu con nào của kiểu khai báo.\n\nUpcasting là quá trình gán một đối tượng của lớp con cho một biến tham chiếu của lớp cha. Điều này cho phép bạn xử lý các đối tượng của các lớp con khác nhau theo cùng một cách. Ví dụ, bạn có thể có một lớp Animal với phương thức speak() được ghi đè trong các lớp con Dog, Cat và Bird. Bạn có thể tạo một biến tham chiếu Animal và gán cho nó một đối tượng Dog, Cat hoặc Bird. Sau đó, bạn có thể gọi phương thức speak() trên biến tham chiếu Animal và phương thức speak() thích hợp sẽ được gọi tùy thuộc vào đối tượng đang được tham chiếu.\n\nTính đa hình tại runtime trong Java là một tính năng mạnh mẽ cho phép bạn viết mã linh hoạt và dễ bảo trì hơn. Nó cho phép bạn xử lý các đối tượng của các lớp con khác nhau theo cùng một cách, giúp bạn dễ dàng thêm các lớp con mới vào chương trình của mình mà không cần thay đổi mã hiện có.class A{} class B extends A{}\n\n, A a=new B();//day la upcasting\n\n, class Bike{ void run(){System.out.println(\"dang chay\");} } class Splender\nextends Bike{ void run(){System.out.println(\"chay an toan voi 60km\");} public\nstatic void main(String args[]){ Bike b = new Splender();//day la upcasting\nb.run(); } }\n\n, class Bank{ int getRateOfInterest(){return 0;} } class VCB extends Bank{ int\ngetRateOfInterest(){return 8;} } class AGR extends Bank{ int\ngetRateOfInterest(){return 7;} } class CTG extends Bank{ int\ngetRateOfInterest(){return 9;} } class Test3{ public static void main(String\nargs[]){ Bank b1=new VCB(); Bank b2=new AGR(); Bank b3=new CTG();\nSystem.out.println(\"VCB lai suat la: \"+b1.getRateOfInterest());\nSystem.out.println(\"AGR lai suat la: \"+b2.getRateOfInterest());\nSystem.out.println(\"CTG lai suat la: \"+b3.getRateOfInterest()); } }\n\n, class Bike{ int speedlimit=90; } class Honda3 extends Bike{ int\nspeedlimit=150; public static void main(String args[]){ Bike obj=new Honda3();\nSystem.out.println(obj.speedlimit);//90 }\n\n, class Animal{ void eat(){System.out.println(\"an\");} } class Dog extends\nAnimal{ void eat(){System.out.println(\"an hoa qua\");} } class BabyDog extends\nDog{ void eat(){System.out.println(\"uong sua\");} public static void\nmain(String args[]){ Animal a1,a2,a3; a1=new Animal(); a2=new Dog(); a3=new\nBabyDog(); a1.eat(); a2.eat(); a3.eat(); } }\n\n, class Animal{ void eat(){System.out.println(\"animao dang an...\");} } class Dog\nextends Animal{ void eat(){System.out.println(\"dog dang an...\");} } class\nBabyDog1 extends Dog{ public static void main(String args[]){ Animal a=new\nBabyDog1(); a.eat(); }}\n\n",
      "id": "1431"
    }
  },
  {
    "id": "153",
    "name": "Dynamic Binding",
    "href": "https://www.vietjack.com/java/dynamic_binding_trong_java.jsp",
    "lesson": {
      "title": "gắn kết tĩnh và gắn kết động (dynamic binding) trong java",
      "content": "* Kiểu đối tượng không thể được quyết định bởi trình biên dịch vì sự thể hiện của đối tượng dog cũng là một sự thể hiện của đối tượng animal, do đó trình biên dịch không biết kiểu của đối tượng nào, nó chỉ biết đến kiểu cơ sở.\n* Khi kiểu của đối tượng được quyết định tại thời gian chạy, thì đó là gắn kết động.\n* Khi kiểu của đối tượng được quyết định tại thời gian biên dịch bởi trình biên dịch, thì đó là gắn kết tĩnh.\n* Nếu có bất kỳ phương thức private, final hoặc static nào trong một lớp, thì đó là gắn kết tĩnh và không thể có chuyện ghi đè phương thức.\n* Trong gắn kết tĩnh, d1 là một sự thể hiện của lớp dog nhưng nó cũng là một sự thể hiện của lớp animal.\n* Ba đối tượng có một kiểu đối tượng là một thể hiện của lớp Java cụ thể, nhưng chúng cũng là một thể hiện của lớp cha.\n* Hai tham chiếu có một kiểu, ở đây biến data là một kiểu int.\n* Một biến có một kiểu, nó có thể là kiểu gốc hoặc kiểu khác không phải là kiểu gốc.\n* Trước khi thảo luận về binding, chúng ta cần làm rõ type là gì.\n* Binding là kết nối một lời gọi phương thức tới thân phương thức.\n* Có hai kiểu binding là static binding (gắn kết tĩnh) và dynamic binding (gắn kết động).int data=30;\n\n, class Dog{ public static void main(String args[]){ Dog d1;//O day, d1 la kieu\ncua Dog } }\n\n, class Animal{} class Dog extends Animal{ public static void main(String\nargs[]){ Dog d1=new Dog(); } }\n\n, class Dog{ private void eat(){System.out.println(\"dog dang an...\");} public\nstatic void main(String args[]){ Dog d1=new Dog(); d1.eat(); } }\n\n, class Animal{ void eat(){System.out.println(\"animal dang an...\");} } class Dog\nextends Animal{ void eat(){System.out.println(\"dog dang an...\");} public\nstatic void main(String args[]){ Animal a=new Dog(); a.eat(); } }\n\n",
      "id": "1531"
    }
  },
  {
    "id": "163",
    "name": "Toán tử instanceof",
    "href": "https://www.vietjack.com/java/toan_tu_instanceof_trong_java.jsp",
    "lesson": {
      "title": "toán tử instanceof trong java",
      "content": "- instanceof trong Java được sử dụng để kiểm tra xem một đối tượng có phải là một instance của một lớp hoặc interface cụ thể hay không.\n\n- Nó trả về true nếu đối tượng là một instance của lớp hoặc interface được chỉ định, nếu không thì trả về false.\n\n- instanceof còn được gọi là toán tử so sánh kiểu, vì nó so sánh một đối tượng với một kiểu và trả về true hoặc false.\n\n- Nếu một đối tượng là null, instanceof sẽ trả về false.\n\n- Một đối tượng của một lớp con cũng là một đối tượng của lớp cha.\n\n- Nếu một lớp con kế thừa từ một lớp cha, thì các đối tượng của lớp con có thể được tham chiếu bằng cả lớp con và lớp cha.\n\n- instanceof có thể được sử dụng để kiểm tra xem một đối tượng có phải là instance của lớp hiện tại hay không.\n\n- Nếu một đối tượng là instance của lớp hiện tại, instanceof sẽ trả về true.class Simple1{ public static void main(String args[]){ Simple1 s=new\nSimple1(); System.out.println(s instanceof Simple);//true } }\n\n, class Animal{} class Dog1 extends Animal {//Dog ke thua Animal public static\nvoid main(String args[]){ Dog1 d=new Dog1(); System.out.println(d instanceof\nAnimal);//true } }\n\n, class Dog2{ public static void main(String args[]){ Dog2 d=null;\nSystem.out.println(d instanceof Dog2);//false } }\n\n, Dog d=new Animal();// gay ra loi tai thoi gian bien dich\n\n, Dog d=(Dog)new Animal(); //Bien dich thanh cong nhung ClassCastException bi\nnem tai runtime\n\n, class Animal { } class Dog3 extends Animal { static void method(Animal a) {\nif(a instanceof Dog3){ Dog3 d=(Dog3)a; //day la downcasting\nSystem.out.println(\"Bay gio downcasting duoc thuc hien\"); } } public static\nvoid main (String [] args) { Animal a=new Dog3(); Dog3.method(a); } }\n\n, class Animal { } class Dog4 extends Animal { static void method(Animal a) {\nDog4 d=(Dog4)a;//Day la downcasting System.out.println(\"downcasting duoc thuc\nhien\"); } public static void main (String [] args) { Animal a=new Dog4();\nDog4.method(a); } }\n\n, Animal a=new Animal(); Dog.method(a); //Bay gio la ClassCastException nhung\nkhong trong truong hop cua toan tu instanceof\n\n, interface Printable{} class A implements Printable{ public void\na(){System.out.println(\"Phuong thuc a\");} } class B implements Printable{\npublic void b(){System.out.println(\"Phuong thuc b\");} } class Call{ void\ninvoke(Printable p) { //Day la upcasting if(p instanceof A){ A a=(A)p;//Day la\nDowncasting a.a(); } if(p instanceof B){ B b=(B)p;//Day la Downcasting b.b();\n} } }//Phan cuoi cua lop Call class Test4{ public static void main(String\nargs[]){ Printable p=new B(); Call c=new Call(); c.invoke(p); } }\n\n, Output: b method\n\n",
      "id": "1631"
    }
  },
  {
    "id": "173",
    "name": "Tính trừu tượng",
    "href": "https://www.vietjack.com/java/truu_tuong_trong_java.jsp",
    "lesson": {
      "title": "tính trừu tượng trong java",
      "content": "- Nếu lớp salary kế thừa lớp employee, thì lớp salary cần triển khai phương thức computepay.\n- Một lớp con phải triển khai phương thức trừu tượng, nếu không thì sẽ có một cấu trúc phân cấp của các lớp trừu tượng mà không thể được khởi tạo.\n- Một lớp con mà kế thừa một phương thức trừu tượng phải ghi đè nó, nếu không thì lớp con đó phải là lớp trừu tượng và bất kỳ lớp con nào của lớp con đó phải ghi đè phương thức đó.\n- Bất kỳ lớp con nào phải hoặc ghi đè phương thức trừu tượng hoặc khai báo trừu tượng chính nó.\n- Lớp phải được khai báo trừu tượng nếu lớp đó chứa một phương thức trừu tượng.\n- Khai báo một phương thức dạng trừu tượng tạo ra hai kết quả sau:\n  - Phương thức trừu tượng sẽ không có định nghĩa và chữ số của nó được theo sau bởi dấu chấm phảy không có dấu ngoặc móc ôm theo sau.\n  - Từ khóa abstract được sử dụng để khai báo một phương thức dạng trừu tượng, một phương thức gồm một chữ số và không có thân phương thức.\n- Nếu bạn muốn một lớp chứa một phương thức cụ thể nhưng bạn muốn triển khai thực sự phương thức đó để được quyết định bởi các lớp con thì bạn có thể khai báo phương thức đó trong lớp cha ở dạng trừu tượng.\n- Ở đây, chúng ta không thể khởi tạo một employee mới nhưng nếu chúng ta khởi tạo một đối tượng salary mới, đối tượng salary này sẽ kế thừa 3 trường và 7 phương thức từ employee.\n- Chúng ta có thể kế thừa lớp employee theo cách thông thường như sau.\n- Khi bạn biên dịch lớp trên, bạn sẽ nhận được một lỗi.\n- Bây giờ, nếu chúng ta thử làm như sau, bạn chú ý rằng không có gì khác trong lớp employee này, lớp này bây giờ là lớp trừu tượng nhưng nó vẫn có 3 trường, 7 phương thức và một constructor.\n- Sử dụng từ khóa abstract để khai báo một lớp trừu tượng, từ khóa này xuất hiện trước từ khóa class trong khai báo lớp.\n- Nếu một lớp là lớp trừu tượng và nó không được khởi tạo, lớp này không được sử dụng trừ khi nó là lớp con.\n- Tính trừu tượng (abstraction) trong Java hướng đến khả năng tạo một đối tượng trừu tượng trong lập trình hướng đối tượng.\n- Một lớp trừu tượng là một lớp mà không được khởi tạo, tất cả các chức năng khác của lớp vẫn tồn tại và tất cả các trường, phương thức và hàm khởi tạo đều được truy cập với một cách giống nhau.\n- Bạn không thể tạo một đối tượng với một lớp trừu tượng./* Ten File : Employee.java */ public abstract class Employee { private String\nname; private String address; private int number; public Employee(String name,\nString address, int number) { System.out.println(\"Xay dung mot Employee\");\nthis.name = name; this.address = address; this.number = number; } public\ndouble computePay() { System.out.println(\"Ben trong Employee computePay\");\nreturn 0.0; } public void mailCheck() { System.out.println(\"Gui mail kiem tra\ntoi \" + this.name \\+ \" \" + this.address); } public String toString() { return\nname + \" \" + address + \" \" + number; } public String getName() { return name;\n} public String getAddress() { return address; } public void setAddress(String\nnewAddress) { address = newAddress; } public int getNumber() { return number;\n} }\n\n, /* Ten File : AbstractDemo.java */ public class AbstractDemo { public static\nvoid main(String [] args) { /* Phan sau la khong duoc phep va se tao mot error\n*/ Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\nSystem.out.println(\"\\n Goi mailCheck boi su dung tham chieu Employee --\");\ne.mailCheck(); } }\n\n, Employee.java:46: Employee is abstract; cannot be instantiated Employee e =\nnew Employee(\"George W.\", \"Houston, TX\", 43); ^ 1 error\n\n, /* Ten File : Salary.java */ public class Salary extends Employee { private\ndouble salary; //Annual salary public Salary(String name, String address, int\nnumber, double salary) { super(name, address, number); setSalary(salary); }\npublic void mailCheck() { System.out.println(\"Ben trong mailCheck cua Salary\nclass \"); System.out.println(\"Gui mail kiem tra toi \" + getName() \\+ \" voi\nsalary la \" + salary); } public double getSalary() { return salary; } public\nvoid setSalary(double newSalary) { if(newSalary >= 0.0) { salary = newSalary;\n} } public double computePay() { System.out.println(\"Tinh toan luong tra cho \"\n+ getName()); return salary/52; } }\n\n, /* Ten File : AbstractDemo.java */ public class AbstractDemo { public static\nvoid main(String [] args) { Salary s = new Salary(\"Mohd Mohtashim\", \"Ambehta,\nUP\", 3, 3600.00); Employee e = new Salary(\"John Adams\", \"Boston, MA\", 2,\n2400.00); System.out.println(\"Goi mailCheck boi su dung tham chieu Salary\n--\"); s.mailCheck(); System.out.println(\"\\n Goi mailCheck boi su dung tham\nchieu Employee --\"); e.mailCheck(); } }\n\n, Xay dung mot Employee Xay dung mot Employee Goi mailCheck boi su dung tham\nchieu Salary -- Ben trong mailCheck cua Salary class Gui mail kiem tra toi\nMohd Mohtashim voi salary la 3600.0 Call mailCheck using Employee reference--\nBen trong mailCheck cua Salary class Gui mail kiem tra toi John Adams voi\nsalary la 2400.\n\n, public abstract class Employee { private String name; private String address;\nprivate int number; public abstract double computePay(); //Phan con lai cua\ndinh nghia class }\n\n, /* Ten File : Salary.java */ public class Salary extends Employee { private\ndouble salary; // Annual salary public double computePay() {\nSystem.out.println(\"Tinh toan luong tra cho \" + getName()); return salary/52;\n} //Phan con lai cua dinh nghia class }\n\n",
      "id": "1731"
    }
  },
  {
    "id": "183",
    "name": "Lớp abstract",
    "href": "https://www.vietjack.com/java/lop_abstract_trong_java.jsp",
    "lesson": {
      "title": "lớp trừu tượng -  abstract class trong java",
      "content": "Tính trừu tượng là quá trình ẩn các chi tiết thực hiện và chỉ hiển thị các tính năng đến người dùng. Trong Java, có hai cách để đạt được tính trừu tượng: sử dụng từ khóa abstract để khai báo một lớp trừu tượng hoặc sử dụng từ khóa interface.\n\nLớp trừu tượng là lớp được khai báo với từ khóa abstract. Nó có thể chứa các phương thức trừu tượng (không có thân phương thức) và các phương thức không trừu tượng (có thân phương thức). Các lớp con của lớp trừu tượng phải cung cấp các triển khai cho tất cả các phương thức trừu tượng của lớp cha.\n\nInterface là một kiểu dữ liệu trừu tượng 100%. Nó chỉ chứa các phương thức trừu tượng và không có các phương thức không trừu tượng. Các lớp triển khai interface phải cung cấp các triển khai cho tất cả các phương thức trừu tượng của interface đó.\n\nLớp trừu tượng thường được sử dụng để thể hiện các lớp cha chung của các lớp con khác nhau. Ví dụ, lớp Động vật có thể là lớp trừu tượng, có các phương thức trừu tượng như ăn(), ngủ() và di chuyển(). Các lớp con của lớp Động vật, chẳng hạn như lớp Chó, lớp Mèo và lớp Cá, sẽ cung cấp các triển khai cụ thể cho các phương thức này.\n\nInterface thường được sử dụng để thể hiện các hành vi chung của các lớp khác nhau. Ví dụ, interface Có thể in có thể được sử dụng để thể hiện hành vi in. Các lớp triển khai interface Có thể in, chẳng hạn như lớp Văn bản và lớp Hình ảnh, sẽ cung cấp các triển khai cụ thể cho phương thức in().abstract class A{}\n\n, abstract void printStatus(); // Khai bao phuong thuc voi tu khoa abstract va\nkhong co than phuong thuct\n\n, // lop truu tuong Bike abstract class Bike{ abstract void run(); // phuong\nthuc truu tuong voi tu khoa abstract } // lop Honda4 ke thua lop truu tuong\nBike class Honda4 extends Bike{ void run(){ System.out.println(\"Dang chay mot\ncach an toan..\"); } // phuong thuc main() public static void main(String\nargs[]){ Bike obj = new Honda4(); obj.run(); } }\n\n, // lop truu tuong Shape abstract class Shape{ abstract void draw(); } //Trong\ntinh huong nay, trinh trien khai duoc cung cap boi ai do, vi du: nguoi su dung\ncuoi cung nao do class Rectangle extends Shape{ void draw(){\nSystem.out.println(\"Ve hinh chu nhat\"); } } class Circle1 extends Shape{ void\ndraw(){ System.out.println(\"Ve hinh tron\"); } } //Trong tinh huong nay, phuong\nthuc duoc goi boi lap trinh vien hoac nguoi dung class TestAbstraction1{\npublic static void main(String args[]){ Shape s=new Circle1(); //Trong tinh\nhuong nay, doi tuong duoc cung cap thong qua phuong thuc, chang han nhu\ngetShape() s.draw(); } }\n\n, abstract class Bank{ abstract int getRateOfInterest(); }\n\n, class SBI extends Bank{ int getRateOfInterest(){return 7;} // bat buoc phai\ncung cap trinh trien khai cua getRateOfInterest }\n\n, class PNB extends Bank{ int getRateOfInterest(){return 8;} // bat buoc phai\ncung cap trinh trien khai cua getRateOfInterest }\n\n, class TestBank{ public static void main(String args[]){ // Tao mot doi tuong\nSBI moi Bank b=new SBI(); //Neu doi tuong la PNB, phuong thuc cua PNB se duoc\ntrieu hoi int interest=b.getRateOfInterest(); //Trieu hoi phuong thuc cua SBI\nSystem.out.println(\"Ti le lai suat la: \"+interest+\" %\"); }}\n\n, //vi du ve lop abstract ma co than phuong thuc abstract class Bike{ Bike(){\nSystem.out.println(\"bike duoc tao\"); } abstract void run(); void changeGear(){\nSystem.out.println(\"gear duoc thay doi\"); } } class Honda extends Bike{ void\nrun(){ System.out.println(\"dang chay mot cach an toan..\"); } } class\nTestAbstraction2{ public static void main(String args[]){ Bike obj = new\nHonda(); obj.run(); obj.changeGear(); } }\n\n, // mot interface A interface A{ void a(); void b(); void c(); void d(); } //\nlop truu tuong B ke thua interface A abstract class B implements A{ //trong vi\ndu nay, lop truu tuong B co the chi cung cap trinh trien khai phuong thuc c()\npublic void c(){ System.out.println(\"Toi la C\"); } } // lop M ke thua lop truu\ntuong B class M extends B{ // bat buoc phai trien khai cac phuong thuc a(),\nb(), c() public void a(){ System.out.println(\"Toi la a\"); } public void b(){\nSystem.out.println(\"Toi la b\"); } public void d(){ System.out.println(\"Toi la\nd\"); } } // lop Test5 chua phuong thuc main() class Test5{ public static void\nmain(String args[]){ A a=new M(); a.a(); a.b(); a.c(); a.d(); }}\n\n",
      "id": "1831"
    }
  },
  {
    "id": "193",
    "name": "Interface",
    "href": "https://www.vietjack.com/java/interface_trong_java.jsp",
    "lesson": {
      "title": "interface trong java",
      "content": "- Khi triển khai interface, có một số quy tắc cần tuân theo. Một lớp triển khai có thể là abstract, do đó các phương thức interface không cần được triển khai. Signature ký số của phương thức interface và kiểu trả về nên được duy trì khi ghi đè phương thức overriding method. Các checked exception không nên được khai báo trong phương thức implements thay vào đó nó nên được khai báo trong phương thức interface hoặc các lớp phụ được khai báo bởi phương thức interface.\n\n\n- Khi ghi đè các phương thức được định nghĩa trong interface, có một số quy tắc sau:\n   - Trong ví dụ này, printable interface chỉ có một phương thức trình triển khai của nó được cung cấp bởi lớp.\n   - Một interface có thể kế thừa từ nhiều interface khác.\n   - Một interface không thể kế thừa từ lớp nó được triển khai bởi một lớp.\n   - Một interface không thể chứa một trường nào trừ các trường vừa static và final.\n   - Tất cả các phương thức của interface đều là abstract.\n   - Một interface không chứa bất cứ hàm contructor nào, bạn không thể khởi tạo một interface.\n\n\n- Mặc dù vậy, một interface khác với một class ở một số điểm sau đây:\n   - Interface xuất hiện trong package những bytecode file tương ứng phải ở trong cấu trúc thư mục có cùng tên package.\n   - Bytecode của interface xuất hiện trong một class file.\n   - Một interface được viết trong một file với định dạng java với tên của interface cùng với tên của file.\n   - Một interface có thể bao gồm bất cứ lượng phương thức nào.\n\n\n- Một interface tương tự với một class bởi những điểm sau đây:\n   - Trừ khi một lớp triển khai interface là lớp trừu tượng abstract còn lại tất cả các phương thức của interface cần được định nghĩa trong class.\n   - Một interface không phải là một lớp viết một interface giống như viết một lớp nhưng chúng có 2 định nghĩa khác nhau: một lớp mô tả các thuộc tính và hành vi của một đối tượng, một interface chứa các hành vi mà một class triển khai.\n\n\n- Một interface trong java là một tập hợp các phương thức trừu tượng abstract, một class triển khai một interface đó kế thừa các phương thức abstract của interface. Nói cách khác, các trường của interface là public static và final theo mặc định và các phương thức là public và abstract. Ghi chú java compiler thêm từ khóa public và abstract trước phương thức của interface và các từ khóa public static và final trước các thành viên dữ liệu.\n\n\n- Một interface trong java là một bản thiết kế của một lớp, nó chỉ có các phương thức trừu tượng. Interface là một kỹ thuật để thu được tình trừu tượng hoàn toàn và đa kế thừa trong java. Interface trong java cũng biểu diễn mối quan hệ isa, nó không thể được khởi tạo giống như lớp trừu tượng.interface printable{ void print(); } class A6 implements printable{ public\nvoid print(){System.out.println(\"Hello\");} public static void main(String\nargs[]){ A6 obj = new A6(); obj.print(); } }\n\n, interface Printable{ void print(); } interface Showable{ void show(); } class\nA7 implements Printable,Showable{ public void\nprint(){System.out.println(\"Hello\");} public void\nshow(){System.out.println(\"Welcome\");} public static void main(String args[]){\nA7 obj = new A7(); obj.print(); obj.show(); } }\n\n, interface Printable{ void print(); } interface Showable{ void print(); } class\nTestTnterface1 implements Printable,Showable{ public void\nprint(){System.out.println(\"Hello\");} public static void main(String args[]){\nTestTnterface1 obj = new TestTnterface1(); obj.print(); } }\n\n, interface Printable{ void print(); } interface Showable extends Printable{\nvoid show(); } class Testinterface2 implements Showable{ public void\nprint(){System.out.println(\"Hello\");} public void\nshow(){System.out.println(\"Welcome\");} public static void main(String args[]){\nTestinterface2 obj = new Testinterface2(); obj.print(); obj.show(); } }\n\n, //Cach Serializable interface duoc viet? public interface Serializable{ }\n\n, interface printable{ void print(); interface MessagePrintable{ void msg(); } }\n\n",
      "id": "1931"
    }
  },
  {
    "id": "203",
    "name": "Lớp abstract vs Interface",
    "href": "https://www.vietjack.com/java/lop_abstract_va_interface_trong_java.jsp",
    "lesson": {
      "title": "phân biệt lớp abstract và interface trong java",
      "content": "Trong phỏng vấn xin việc, bạn có thể được hỏi về sự khác nhau giữa lớp trừu tượng (abstract class) và giao diện (interface). Phương thức của giao diện luôn luôn là phương thức trừu tượng 100%. Trong khi đó, lớp trừu tượng có thể có phương thức không phải trừu tượng. Trong thiết kế phần mềm, giao diện thường được dùng để chỉ hai hay nhiều lớp cùng làm một việc gì đó. Ví dụ, cùng có thể in (printable). Trong khi đó, lớp trừu tượng thường hướng đến quan hệ cha con trong lập trình hướng đối tượng.\n\nVề cơ bản, lớp trừu tượng đạt được trừu tượng hóa một phần từ 0 đến 100. Trong khi đó, giao diện có thể đạt được trừu tượng hóa hoàn toàn 100%. Cả lớp trừu tượng và giao diện được sử dụng để thu được tính trừu tượng. Từ đó, chúng ta có thể khai báo các phương thức trừu tượng. Cả lớp trừu tượng và giao diện không thể được khởi tạo. Tuy nhiên, cũng có các điểm khác nhau giữa lớp trừu tượng và giao diện như sau:\n\n- Lớp trừu tượng có thể có các phương thức không trừu tượng, trong khi giao diện thì không.\n- Lớp trừu tượng có thể có các biến thành viên, trong khi giao diện thì không.\n- Một lớp có thể kế thừa từ nhiều lớp trừu tượng, nhưng chỉ có thể kế thừa từ một giao diện.\n- Một lớp có thể triển khai nhiều giao diện, nhưng chỉ có thể kế thừa từ một lớp trừu tượng.1. Lớp trừu tượng có thể chứa cả phương thức trừu tượng và phương thức cụ thể, trong khi interface chỉ có thể chứa phương thức trừu tượng.\n2. Lớp trừu tượng không hỗ trợ đa kế thừa, trong khi interface hỗ trợ.\n3. Lớp trừu tượng có thể chứa các biến cuối cùng, không cuối cùng, tĩnh và không tĩnh, trong khi interface chỉ có thể chứa các biến tĩnh và cuối cùng.\n4. Lớp trừu tượng có thể chứa phương thức tĩnh, phương thức main và hàm tạo, trong khi interface không thể chứa phương thức tĩnh, phương thức main hoặc hàm tạo.\n5. Từ khóa abstract được sử dụng để khai báo một lớp trừu tượng, trong khi từ khóa interface được sử dụng để khai báo một interface.\n6. Lớp trừu tượng có thể cung cấp triển khai của interface, trong khi interface không cung cấp triển khai cụ thể của lớp trừu tượng.//Tao interface ma co 4 phuong thuc interface A{ void a();//theo mac dinh,\npublic va abstract void b(); void c(); void d(); } //Tao lop abstract ma cung\ncap trinh trien khai cua mot phuong thuc cua A interface abstract class B\nimplements A{ public void c(){System.out.println(\"Toi la C\");} } //Tao lop con\ncua lop abstract, bay gio chung ta can cung cap trinh trien khai cho cac\nphuong thuc con lai class M extends B{ public void a(){System.out.println(\"Toi\nla a\");} public void b(){System.out.println(\"Toi la b\");} public void\nd(){System.out.println(\"Toi la d\");} } //Tao mot lop Test ma goi cac phuong\nthuc cua A interface class Test5{ public static void main(String args[]){ A\na=new M(); a.a(); a.b(); a.c(); a.d(); }}\n\n, Toi la a Toi la b Toi la c Toi la d\n\n",
      "id": "2031"
    }
  },
  {
    "id": "213",
    "name": "Java Package",
    "href": "https://www.vietjack.com/java/package_trong_java.jsp",
    "lesson": {
      "title": "package trong java",
      "content": "Để thiết lập biến classpath, bạn có thể sử dụng các lệnh sau trong Windows và Unix Bourne Shell:\n\n- Trong Unix:\n  - Để thêm một thư mục vào classpath:\n    ```\n    export CLASSPATH=$CLASSPATH:/path/to/directory\n    ```\n  - Để xóa một thư mục khỏi classpath:\n    ```\n    unset CLASSPATH\n    export CLASSPATH\n    ```\n  - Để hiển thị classpath hiện tại:\n    ```\n    echo $CLASSPATH\n    ```\n\n\n- Trong Windows:\n  - Để thêm một thư mục vào classpath:\n    ```\n    set CLASSPATH=%CLASSPATH%;C:\\path\\to\\directory\n    ```\n  - Để xóa một thư mục khỏi classpath:\n    ```\n    set CLASSPATH=\n    ```\n  - Để hiển thị classpath hiện tại:\n    ```\n    echo %CLASSPATH%\n    ```\n\nĐể đặt hai lớp public trong một package, bạn có thể làm như sau:\n\n1. Tạo hai Java source file, mỗi file chứa một lớp public nhưng giữ tên package giống nhau.\n2. Biên dịch các file Java source này thành các class file.\n3. Thiết lập classpath để bao gồm thư mục chứa các class file này.\n4. Chạy chương trình của bạn.\n\nCó nhiều cách để tải class file hoặc jar file:\n\n- Sử dụng classpath switch với javac và java tool.\n- Thiết lập classpath trong biến môi trường.\n- Tạo jar file chứa tất cả class file và sao chép jar file trong thư mục jrelibext.\n\nĐể truy cập package từ package bên ngoài, bạn có thể sử dụng các kỹ thuật sau:\n\n- Sử dụng tên đầy đủ của class.\n- Sử dụng lệnh import.\n- Sử dụng wild card (*).\n\nJava package được sử dụng để:\n\n- Xóa bỏ các xung đột về đặt tên.\n- Cung cấp bảo vệ truy cập.\n- Phân loại các lớp và các interface để chúng có thể được duy trì dễ dàng hơn.\n\nĐể tạo một package trong Java, bạn có thể làm như sau:\n\n1. Chọn tên cho package.\n2. Đặt câu lệnh khai báo package ở trên cùng của source file.\n3. Đặt các lớp, interface, enumeration và annotation vào package.\n\nCó nhiều package đã xây dựng sẵn trong Java, chẳng hạn như:\n\n- java.lang: Các lớp cơ bản.\n- java.io: Các lớp input và output cơ bản.\n- java.util: Các lớp tiện ích.\n- java.sql: Các lớp cơ sở dữ liệu.\n\nBạn cũng có thể định nghĩa các package của riêng mình./* Ten File : Animal.java */ package animals; interface Animal { public void\neat(); public void travel(); }\n\n, //Luu duoi dang Simple.java package mypack; public class Simple{ public static\nvoid main(String args[]){ System.out.println(\"Chao mung ban den voi package\ntrong Java\"); } }\n\n, javac -d thu_muc ten_javafile\n\n, javac -d . Simple.java\n\n, package payroll; public class Boss { public void payEmployee(Employee e) {\ne.mailCheck(); } }\n\n, payroll.Employee\n\n, import payroll.*;\n\n, import payroll.Employee;\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B{ public static\nvoid main(String args[]){ A obj = new A(); obj.msg(); } }\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.A; class B{ public static\nvoid main(String args[]){ A obj = new A(); obj.msg(); } }\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; class B{ public static void main(String\nargs[]){ pack.A obj = new pack.A();//Su dung ten day du obj.msg(); } }\n\n, package com.vietjack.core; class Simple{ public static void main(String\nargs[]){ System.out.println(\"Hello subpackage\"); } }\n\n, //Luu duoi dang Simple.java package mypack; public class Simple{ public static\nvoid main(String args[]){ System.out.println(\"Chao mung den voi package\"); } }\n\n, //Luu duoi dang C.java neu khong se gay ra Compilte Time Error class A{} class\nB{} public class C{}\n\n, //Luu duoi dang A.java package vietjack; public class A{}\n\n, //Luu duoi dang B.java package vietjack; public class B{}\n\n",
      "id": "2131"
    }
  },
  {
    "id": "223",
    "name": "Các kiểu Modifier",
    "href": "https://www.vietjack.com/java/cac_kieu_modifier_trong_java.jsp",
    "lesson": {
      "title": "các kiểu modifier trong java",
      "content": "Trong chương tiếp theo, chúng ta sẽ khám phá các toán tử cơ bản được sử dụng trong ngôn ngữ lập trình Java. Chúng ta sẽ xem xét cách sử dụng các toán tử này để thực hiện các phép toán số học, so sánh và logic trong khi phát triển ứng dụng.\n\nNgoài ra, chúng ta sẽ tìm hiểu về các từ khóa đồng bộ (synchronized) và biến động (volatile) được sử dụng để làm việc với các luồng (thread). Chúng ta sẽ khám phá cách sử dụng từ khóa trừu tượng (abstract) để tạo các lớp và phương thức trừu tượng, cũng như cách sử dụng từ khóa final để kết thúc việc thực thi các lớp, phương thức và biến.\n\nJava cũng cung cấp một số từ khóa không phải từ khóa truy cập (nonaccess modifier) để thực hiện các tính năng khác. Chúng ta sẽ tìm hiểu về các từ khóa protected (bảo vệ), public (công khai), private (riêng tư) và default (mặc định) để thiết lập chỉ định truy cập cho các lớp, biến, phương thức và constructor.\n\nCuối cùng, chúng ta sẽ xem xét cách sử dụng các từ khóa này để thay đổi ý nghĩa của các định nghĩa trong ngôn ngữ Java. Chúng ta sẽ tìm hiểu về các từ khóa nonaccess modifier và access modifier, cũng như cách sử dụng chúng để kiểm soát phạm vi truy cập của các thành phần trong chương trình.public class tenClass { // ... } private boolean myFlag; static final double\nweeks = 9.5; protected static final int BOXWIDTH = 42; public static void\nmain(String[] arguments) { // Phan than phuong thuc }\n\n",
      "id": "2231"
    }
  },
  {
    "id": "233",
    "name": "Non-Access Modifier",
    "href": "https://www.vietjack.com/java/nonaccess_modifier_trong_java.jsp",
    "lesson": {
      "title": "non access modifier trong java",
      "content": "* `run()` thường được gọi trong một thread mà bạn bắt đầu sử dụng `Runnable` và `stop()` được gọi từ một thread khác.\n* Nếu trong dòng 1, giá trị được lưu trữ được sử dụng trong một vòng lặp, vòng lặp có thể không dừng lại khi bạn đặt nó thành `false` trong dòng 2. Đây là lúc bạn muốn sử dụng `volatile`.\n* Truy cập vào một biến `volatile` đồng bộ hóa tất cả các bản sao của biến trong bộ nhớ chính.\n* `volatile` chỉ có thể được áp dụng cho các biến thành viên là đối tượng hoặc tham chiếu đối tượng `private`.\n* Một tham chiếu đối tượng `volatile` có thể là `null`.\n* `volatile` được sử dụng để cho JVM biết rằng một thread đang truy cập biến đó phải luôn luôn hợp nhất bản sao biến riêng của nó với bản sao chính trong bộ nhớ.\n* Trình sửa đổi này được đặt trong lệnh tạo biến, đứng trước lớp hoặc kiểu dữ liệu của biến đó.\n* Một biến thành viên được đánh dấu là `transient` để chỉ ra rằng JVM bỏ qua biến cụ thể đó khi tuần tự hóa đối tượng đang chứa nó.\n* Từ khóa `synchronized` được sử dụng để chỉ ra rằng một phương thức có thể được truy cập bởi chỉ một thread tại một thời điểm.\n* Trình sửa đổi `synchronized` có thể được áp dụng với bất kỳ mức độ truy cập nào trong số bốn mức độ truy cập.\n* Phương thức `abstract` kết thúc bằng dấu chấm phẩy, ví dụ: `public abstract sample`.\n* Nếu một lớp chứa một hoặc nhiều phương thức `abstract`, lớp đó phải được khai báo là `abstract`.\n* Một lớp `abstract` không cần chứa các phương thức `abstract`.\n* Bất kỳ lớp nào kế thừa một lớp `abstract` phải triển khai tất cả các phương thức `abstract` của lớp cha trừ khi lớp con này cũng là một lớp `abstract`.\n* Một phương thức `abstract` là một phương thức được khai báo mà không có bất kỳ triển khai nào. Thân phương thức này được cung cấp bởi lớp con.\n* Các phương thức `abstract` không bao giờ có thể là `final`.\n* Một lớp `abstract` có thể chứa cả các phương thức `abstract` cũng như các phương thức thông thường.\n* Một lớp không thể vừa `abstract` và `final`.\n* Một lớp `final` không thể được kế thừa.\n* Nếu một lớp chứa các phương thức `abstract`, lớp đó nên được khai báo là `abstract`, nếu không nó sẽ tạo ra lỗi biên dịch.\n* Một lớp `abstract` không bao giờ có thể được khởi tạo.\n* Nếu một lớp được khai báo là `abstract`, mục đích duy nhất của lớp này là để được kế thừa.\n* Mục đích chính của việc sử dụng một lớp được khai báo là `final` là để ngăn cản lớp bị phân lớp thành lớp con.\n* Nếu một lớp được đánh dấu là `final`, không có lớp nào có thể kế thừa bất kỳ đặc điểm nào từ lớp `final` đó.\n* Bạn khai báo các phương thức sử dụng trình sửa đổi `final` trong khai báo lớp như trong ví dụ sau.\n* Mục đích chính của việc tạo phương thức `final` là nội dung của phương thức không nên bị thay đổi bởi bên ngoài.\n* Một phương thức `final` không thể bị ghi đè (phương thức ghi đè) bởi bất kỳ lớp con nào.\n* Như đã đề cập trước đó, trình sửa đổi `final` ngăn cản một phương thức bị sửa đổi trong một lớp con.\n* Đối với các biến, trình sửa đổi `final` thường được sử dụng với `static` để tạo hằng số cho một biến lớp.\n* Tuy nhiên, dữ liệu bên trong đối tượng có thể bị thay đổi, do đó trạng thái của đối tượng có thể thay đổi nhưng không phải là tham chiếu.\n* Một biến `final` có thể được khởi tạo một cách rõ ràng chỉ một lần.\n* Một biến tham chiếu được khai báo là `final` không bao giờ có thể được gán lại để tham chiếu đến một đối tượng khác.\n* Trình sửa đổi `static` trong Java được sử dụng để tạo các phương thức lớp và biến lớp như trong ví dụ sau.\n* Các biến lớp và phương thức lớp có thể được truy cập bằng cách sử dụng tên lớp theo sau là dấu chấm và tên biến hoặc phương thức.\n* Các phương thức `static` không sử dụng bất kỳ biến thành viên nào của bất kỳ đối tượng nào trong lớp mà chúng được định nghĩa. Các phương thức `static` nhận tất cả dữ liệu từ các tham số và tính toán mọi thứ từ các tham số của chúng mà không tham chiếu đến các biến.\n* Từ khóa `static` được sử dụng để tạo các phương thức sẽ tồn tại một cách độc lập trong bất kỳ thành phần nào được tạo cho lớp đó.\n* Các biến `static` cũng được gọi là các biến lớp.\n* Các biến cục bộ không thể được khai báo là `static`.\n* Từ khóa `static` được sử dụng để tạo các biến sẽ tồn tại một cách độc lập trong bất kỳ thành phần nào được tạo cho lớp đó.\n* Chỉ có một bản sao biến `static` tồn tại cho dù có nhiều thành phần của lớp.\n* Trình sửa đổi `synchronized` và `volatile` được sử dụng cho các thread, trình sửa đổi `abstract` để tạo các lớp và phương thức trừu tượng, trình sửa đổi `final` để kết thúc việc thực thi các lớp, phương thức và biến, trình sửa đổi `static` để tạo các phương thức lớp và biến.\n* Java cũng cung cấp một số trình sửa đổi `nonaccess` để thực hiện các tính năng khác.public class InstanceCounter { private static int numInstances = 0; protected\nstatic int getCount() { return numInstances; } private static void\naddInstance() { numInstances++; } InstanceCounter() {\nInstanceCounter.addInstance(); } public static void main(String[] arguments) {\nSystem.out.println(\"Bat dau voi \" + InstanceCounter.getCount() + \"\ninstances\"); for (int i = 0; i < 500; ++i){ new InstanceCounter(); }\nSystem.out.println(\"Duoc tao voi \" + InstanceCounter.getCount() + \"\ninstances\"); } }\n\n, Bat dau voi 0 instances Duoc tao voi 500 instances\n\n, public class Test{ final int value = 10; // Sau day la cac vi du ve khai bao\nconstant: public static final int BOXWIDTH = 6; static final String TITLE =\n\"Manager\"; public void changeValue(){ value = 12; //se cho mot error } }\n\n, public class Test{ public final void changeName(){ // Phan than phuong thuc }\n}\n\n, public final class Test { // Phan than Class }\n\n, abstract class Caravan{ private double price; private String model; private\nString year; public abstract void goFast(); //mot phuong thuc abstract public\nabstract void changeColor(); }\n\n, public abstract class SuperClass{ abstract void m(); //phuong thuc abstract }\nclass SubClass extends SuperClass{ // trien khai phuong thuc abstract void\nm(){ ......... } }\n\n, public synchronized void showDetails(){ ....... }\n\n, public transient int limit = 55; //JVM bo qua bien khi xep thu tu doi tuong\ndang chua no public int b; //day la truong hop thong thuong\n\n, public class MyRunnable implements Runnable { private volatile boolean active;\npublic void run() { active = true; while (active) // dong 1 { // o day la code\n} } public void stop() { active = false; // dong 2 } }\n\n",
      "id": "2331"
    }
  },
  {
    "id": "243",
    "name": "Access Modifier",
    "href": "https://www.vietjack.com/java/access_modifier_trong_java.jsp",
    "lesson": {
      "title": "access modifier trong java",
      "content": "- Các phương thức khai báo private không được kế thừa và không có quy tắc nào cho chúng.\n- Các phương thức khai báo mà không có điều khiển truy cập (không sử dụng modifier nào) có thể được khai báo private trong các lớp phụ.\n- Các phương thức được khai báo protected trong một lớp cha phải là protected hoặc public trong các lớp phụ, không thể là private.\n- Các phương thức được khai báo public trong một lớp cha cũng phải là public trong tất cả lớp phụ.\n- Các phương thức được kế thừa trong Java phải tuân theo các quy tắc sau:\n - Default modifier có phạm vi hẹp hơn protected, vì vậy không thể ghi đè phương thức protected bằng phương thức default.\n - Nếu ghi đè một phương thức, phương thức được ghi đè (ví dụ được khai báo trong lớp con) không được có phạm vi hẹp hơn.\n- Do tính kế thừa lớp, tất cả phương thức và biến của một lớp được kế thừa bởi các lớp phụ của nó.\n- Tuy nhiên, nếu lớp public mà chúng ta đang cố gắng truy cập ở trong một package khác, thì lớp public này vẫn cần được import.\n- Public access modifier có thể truy cập ở bất cứ đâu, nó có phạm vi rộng nhất trong tất cả các modifier.\n- Một lớp, phương thức, constructor hoặc interface được khai báo public có thể được truy cập từ bất kỳ lớp nào khác.\n- Các trường, phương thức và khối được khai báo bên trong một lớp public có thể được truy cập từ bất kỳ lớp nào trong thế giới Java.\n- Trong ví dụ có hai package là pack và mypack, một lớp của package pack là public nên có thể được truy cập từ bên ngoài package, nhưng phương thức msg của package này được khai báo là protected nên chỉ có thể được truy cập từ bên ngoài lớp thông qua tính kế thừa.\n- Protected access modifier cung cấp cho lớp phụ cơ hội để sử dụng phương thức hoặc biến helper trong khi ngăn cản một lớp không liên quan cố gắng sử dụng nó.\n- Protected access modifier không thể được áp dụng cho lớp và interface, nhưng có thể được áp dụng cho các phương thức và trường.\n- Protected access modifier có thể truy cập bên trong package và bên ngoài package thông qua tính kế thừa.\n- Protected access modifier có thể được áp dụng trên thành viên dữ liệu nhưng không thể được áp dụng trên lớp.\n- Các biến, phương thức và constructor được khai báo protected trong một lớp cha (superclass) chỉ được truy cập bởi các lớp con trong cùng package hoặc bất kỳ lớp nào bên trong package đó của lớp được protected.\n- Trong ví dụ, phạm vi của lớp và phương thức msg của nó là default nên không thể truy cập từ bên ngoài package.\n- Một biến hoặc phương thức được khai báo mà không có bất kỳ access modifier nào sẽ có sẵn cho mọi lớp trong cùng package.\n- Các trường trong một interface hoàn toàn là public static final và các phương thức trong một interface là public theo mặc định.\n- Default access modifier nghĩa là chúng ta không khai báo một cách rõ ràng một access modifier cho một lớp, trường hoặc phương thức.\n- Default modifier chỉ có thể truy cập bên trong package.\n- Nếu tạo bất kỳ constructor nào là private, chúng ta không thể tạo instance (sự thể hiện) của lớp đó từ bên ngoài lớp.\n- Sử dụng private access modifier trong Java là cách chủ yếu để một đối tượng đóng gói chính nó và ẩn dữ liệu với bên ngoài.\n- Các biến được khai báo private có thể được truy cập bên ngoài lớp nếu phương thức public getter có mặt trong lớp đó.\n- Private access modifier là chế độ truy cập mang tính hạn chế nhất, lớp và interface không thể là private.\n- Các phương thức, biến và constructor được khai báo private chỉ có thể được truy cập trong chính lớp được khai báo đó.Access Modifier mô tả phạm vi khả dụng của các thành viên lớp (fields, methods, constructors)\n\n| Access Modifier | Trong lớp | Trong gói | Trong gói con | Ngoài gói |\n|---|---|---|---|---|\n| private | Có | Không | Không | Không |\n| default | Có | Có | Không | Không |\n| protected | Có | Có | Có | Không |\n| public | Có | Có | Có | Có |class A{ private int data=40; private void msg(){System.out.println(\"Hello\njava\");} } public class Simple{ public static void main(String args[]){ A\nobj=new A(); System.out.println(obj.data);//Compile Time Error\nobj.msg();//Compile Time Error } }\n\n, class A{ private A(){}//private constructor void\nmsg(){System.out.println(\"Hello java\");} } public class Simple{ public static\nvoid main(String args[]){ A obj=new A();//Compile Time Error } }\n\n, //Luu duoi dang A.java package pack; class A{ void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B{ public static\nvoid main(String args[]){ A obj = new A();//Compile Time Error\nobj.msg();//Compile Time Error } }\n\n, //Luu duoi dang A.java package pack; public class A{ protected void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B extends A{\npublic static void main(String args[]){ B obj = new B(); obj.msg(); } }\n\n, //Luu duoi dang A.java package pack; public class A{ public void\nmsg(){System.out.println(\"Hello\");} }\n\n, //Luu duoi dang B.java package mypack; import pack.*; class B{ public static\nvoid main(String args[]){ A obj = new A(); obj.msg(); } }\n\n, class A{ protected void msg(){System.out.println(\"Hello java\");} } public\nclass Simple extends A{ void msg(){System.out.println(\"Hello java\");}//Compile\nTime Error public static void main(String args[]){ Simple obj=new Simple();\nobj.msg(); } }\n\n",
      "id": "2431"
    }
  },
  {
    "id": "253",
    "name": "Tính bao đóng",
    "href": "https://www.vietjack.com/java/tinh_bao_dong_trong_java.jsp",
    "lesson": {
      "title": "tính bao đóng trong java",
      "content": "* Để chạy chương trình Java, hãy sử dụng lệnh `java comimtatest`.\n* Để biên dịch chương trình Java, hãy sử dụng lệnh `javac testjava`.\n* Ví dụ về tính bao đóng:\n    * Một lớp có thể có một trường với phương thức setter và getter của nó.\n    * Người dùng của lớp không biết cách lớp lưu trữ dữ liệu.\n    * Một lớp có thể thay đổi kiểu dữ liệu của một trường và người dùng lớp không cần phải thay đổi code.\n    * Một lớp có thể có toàn bộ quyền kiểm soát thông qua những gì được lưu giữ trong các trường của nó.\n    * Tất cả các lớp có thể có chế độ chỉ đọc hoặc chỉ ghi chỉ có hàm getter hoặc setter.\n    * Bằng cách cung cấp phương thức setter hoặc getter, bạn có thể làm cho lớp là readonly hoặc writeonly.\n    * Nó cung cấp cho bạn sự kiểm soát thông qua dữ liệu.\n    * Ví dụ: bạn muốn thiết lập giá trị của id là lớn hơn 100 thì bạn có thể viết biểu thức logic bên trong phương thức setter.\n* Tính bao đóng có thể được mô tả như là một tấm bảo vệ code và tránh code và dữ liệu của bạn bị truy cập một cách ngẫu nhiên bởi các code khác bên ngoài class.\n* Truy cập dữ liệu và code được điều khiển một cách chặt chẽ bởi một interface.\n* Tính bao đóng là kỹ thuật tạo một trường của lớp private và cung cấp khả năng truy cập trường này qua các phương thức public.\n* Nếu một trường được khai báo là private, nó không thể được truy cập bởi bên ngoài lớp đó.\n* Có thể che dấu các trường có lớp này.\n* Vì lý do này, tính bao đóng được ám chỉ như việc dấu dữ liệu data hiding.\n* Tính bao đóng trong Java là một tiến trình đóng gói code và dữ liệu lại với nhau vào trong một đơn vị unit đơn.\n* Ví dụ như một gói bột giặt là hỗn hợp của các hạt bột giặt khác nhau.\n* Chúng ta có thể tạo một lớp được bao đóng hoàn toàn trong Java bằng việc tạo tất cả thành viên dữ liệu của lớp là private.\n* Bây giờ chúng ta sử dụng phương thức setter và getter để thiết lập và lấy dữ liệu trong nó.\n* Lớp Java bean là ví dụ về một lớp được bao đóng hoàn toàn.//Luu duoi dang Student.java package com.vietjack; public class Student{\nprivate String name; public String getName(){ return name; } public void\nsetName(String name){ this.name=name } }\n\n, //Luu duoi dang Test.java package com.vietjack; class Test{ public static void\nmain(String[] args){ Student s=new Student(); s.setname(\"vietjackteam\");\nSystem.out.println(s.getName()); } }\n\n, output: vietjackteam\n\n",
      "id": "2531"
    }
  },
  {
    "id": "263",
    "name": "Lớp Object",
    "href": "https://www.vietjack.com/java/lop_object_trong_java.jsp",
    "lesson": {
      "title": "lớp object trong java",
      "content": "Lớp object là lớp mặc định trong Java và tất cả các lớp khác phải kế thừa nó. Nó cung cấp một số phương thức chung cho tất cả các đối tượng, chẳng hạn như phương thức `getObject()` trả về một đối tượng nhưng có thể là bất kỳ kiểu nào. Bạn có thể sử dụng tham chiếu lớp `object` để tham chiếu đến đối tượng đó. Ví dụ, theo mặc định, lớp `object` là lớp cha của tất cả các lớp trong Java. Nói cách khác, nó là lớp cao nhất trong Java. Lớp `object` rất hữu ích nếu bạn muốn tham chiếu bất kỳ đối tượng nào có kiểu mà bạn không biết. Lưu ý rằng biến tham chiếu của lớp cha có thể tham chiếu đến đối tượng lớp con và được gọi là upcasting.- phương thức getClass () trả về một đối tượng lớp Class biểu thị lớp của đối tượng.\n- phương thức hashCode () trả về mã băm cho đối tượng.\n- phương thức equals (Object obj) so sánh đối tượng đã cho với đối tượng này và trả về true nếu chúng bằng nhau, nếu không trả về false.\n- phương thức clone () tạo và trả về một bản sao của đối tượng này.\n- phương thức toString () trả về một biểu diễn chuỗi của đối tượng này.\n- phương thức notify () đánh thức một luồng duy nhất đang chờ trên đối tượng này.\n- phương thức notifyAll () đánh thức tất cả các luồng đang chờ trên đối tượng này.\n- phương thức wait (long timeout) làm cho luồng hiện tại đợi trong khoảng thời gian chỉ định hoặc cho đến khi được đánh thức bởi luồng khác.\n- phương thức wait (long timeout, int nanos) làm cho luồng hiện tại đợi trong khoảng thời gian chỉ định hoặc cho đến khi được đánh thức bởi luồng khác.\n- phương thức wait () làm cho luồng hiện tại đợi cho đến khi được đánh thức bởi luồng khác.\n- phương thức finalize () được gọi bởi bộ thu gom rác trước khi đối tượng bị xóa khỏi bộ nhớ.Object obj=getObject();//Chung ta khong biet doi tuong nao se duoc tra ve tu\nphuong thuc nay\n\n",
      "id": "2631"
    }
  },
  {
    "id": "273",
    "name": "Nhân bản đối tượng",
    "href": "https://www.vietjack.com/java/mo_phong_doi_tuong_trong_java.jsp",
    "lesson": {
      "title": "nhân bản đối tượng trong java",
      "content": "Clone đối tượng là một kỹ thuật tạo ra bản sao của một đối tượng. Để thực hiện điều này, bạn có thể sử dụng phương thức clone() được định nghĩa trong lớp Object. Tuy nhiên, để sử dụng phương thức này, lớp chứa đối tượng cần clone phải triển khai giao diện Cloneable. Nếu không, khi gọi phương thức clone() sẽ ném ra ngoại lệ CloneNotSupportedException.\n\nPhương thức clone() tạo ra một bản sao mới của đối tượng gốc, có giá trị giống hệt nhau. Điều này có nghĩa là khi bạn thay đổi giá trị của bản sao, giá trị của đối tượng gốc sẽ không bị ảnh hưởng và ngược lại.\n\nClone đối tượng có thể hữu ích trong nhiều trường hợp, chẳng hạn như khi bạn muốn tạo một bản sao của một đối tượng để sử dụng trong một luồng khác hoặc khi bạn muốn lưu trữ một bản sao của một đối tượng trong cơ sở dữ liệu.\n\nĐây là một ví dụ về cách sử dụng phương thức clone() để tạo bản sao của một đối tượng:\n\n```java\npublic class Person implements Cloneable {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        return super.clone();\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) throws CloneNotSupportedException {\n        Person person1 = new Person(\"John Doe\", 30);\n\n        // Clone the person1 object\n        Person person2 = (Person) person1.clone();\n\n        // Change the name of the person2 object\n        person2.setName(\"Jane Doe\");\n\n        // Print the names of the person1 and person2 objects\n        System.out.println(person1.getName()); // John Doe\n        System.out.println(person2.getName()); // Jane Doe\n    }\n}\n```\n\nTrong ví dụ này, lớp Person triển khai giao diện Cloneable và ghi đè phương thức clone() để tạo bản sao của chính nó. Khi bạn gọi phương thức clone() trên đối tượng person1, một bản sao mới của đối tượng này sẽ được tạo ra và gán cho biến person2. Sau đó, bạn có thể thay đổi giá trị của đối tượng person2 mà không ảnh hưởng đến giá trị của đối tượng person1.protected Object clone() throws CloneNotSupportedException\n\n, class Student18 implements Cloneable{ int rollno; String name; Student18(int\nrollno,String name){ this.rollno=rollno; this.name=name; } public Object\nclone()throws CloneNotSupportedException{ return super.clone(); } public\nstatic void main(String args[]){ try{ Student18 s1=new Student18(101,\"hoang\");\nStudent18 s2=(Student18)s1.clone(); System.out.println(s1.rollno+\" \"+s1.name);\nSystem.out.println(s2.rollno+\" \"+s2.name); }catch(CloneNotSupportedException\nc){} } }\n\n, Output:101 hoang 101 hoang\n\n",
      "id": "2731"
    }
  },
  {
    "id": "283",
    "name": "Mảng (Array)",
    "href": "https://www.vietjack.com/java/mang_trong_java.jsp",
    "lesson": {
      "title": "mảng (array) trong java",
      "content": "- Trong Java, mảng là một đối tượng chứa các phần tử có kiểu dữ liệu giống nhau.\n- Mảng trong Java có giới hạn kích thước cố định và không thể thay đổi kích thước tại thời gian chạy.\n- Các phần tử trong mảng được truy cập thông qua chỉ mục (index), bắt đầu từ 0 đến kích thước mảng trừ 1.\n- Có hai loại mảng trong Java: mảng một chiều và mảng đa chiều.\n- Mảng một chiều lưu trữ các phần tử theo một chiều duy nhất, trong khi mảng đa chiều lưu trữ các phần tử theo nhiều chiều.\n- Để khai báo một biến mảng, bạn sử dụng cú pháp sau:\n  ```\n  kieu_du_lieu[] ten_bien_mang;\n  ```\n- Để tạo một mảng, bạn sử dụng toán tử `new` với cú pháp sau:\n  ```\n  ten_bien_mang = new kieu_du_lieu[kich_thuoc_mang];\n  ```\n- Để truy cập một phần tử trong mảng, bạn sử dụng cú pháp sau:\n  ```\n  ten_bien_mang[chi_so_phan_tu]\n  ```\n- Để duyệt qua các phần tử trong mảng, bạn có thể sử dụng vòng lặp `for` hoặc vòng lặp `foreach`.\n- Mảng trong Java có nhiều phương thức hữu ích để sắp xếp, tìm kiếm và thao tác với các phần tử.\n- Bạn có thể truyền mảng vào các phương thức để tái sử dụng cùng một logic trên nhiều mảng khác nhau.1. binarySearch(): Tìm kiếm nhị phân trong mảng các đối tượng được sắp xếp trước, trả về chỉ mục của khóa tìm kiếm nếu tìm thấy, nếu không trả về vị trí chèn.\n\n2. equals(): So sánh hai mảng long, trả về true nếu chúng có cùng số lượng phần tử và tất cả các cặp phần tử tương ứng là bằng nhau.\n\n3. fill(): Gán một giá trị int cụ thể cho từng phần tử của mảng int đã cho.\n\n4. sort(): Sắp xếp mảng các đối tượng theo thứ tự tăng dần dựa trên thứ tự tự nhiên của các phần tử.Kieu_du_lieu[] Bien_tham_chieu_mang; // cach uu tien. hoac Kieu_du_lieu\nBien_tham_chieu_mang[]; // lam viec nhung khong la cach uu tien.\n\n, double[] BK49; // cach uu tien. hoac double BK49[]; // lam viec nhung khong la\ncach uu tien.\n\n, Bien_tham_chieu_mang = new Kieu_du_lieu[Kich_co_mang];\n\n, Kieu_du_lieu[] Bien_tham_chieu_mang = new Kieu_du_lieu[Kich_co_mang];\n\n, Kieu_du_lieu[] Bien_tham_chieu_mang = {giatri0, giatri1, ..., giatriN};\n\n, double[] BK49 = new double[10];\n\n, class Array1{ public static void main(String args[]){ int a[]=new\nint[5];//phan khai bao va khoi tao a[0]=10;//Phan khoi tao a[1]=20; a[2]=70;\na[3]=40; a[4]=50; //in mang for(int i=0;i<a.length;i++)//length la thuoc tinh\ncua mang System.out.println(a[i]); }}\n\n, int a[]={33,3,4,5};//khai bao, khoi tao va khoi tao\n\n, class Testarray1{ public static void main(String args[]){ int\na[]={33,3,4,5};//khai bao, khoi tao va khoi tao //in mang for(int\ni=0;i<a.length;i++)//length la thuoc tinh cua mang System.out.println(a[i]);\n}}\n\n, class Testarray2{ static void min(int arr[]){ int min=arr[0]; for(int\ni=1;i<arr.length;i++) if(min>arr[i]) min=arr[i]; System.out.println(min); }\npublic static void main(String args[]){ int a[]={33,3,4,5}; min(a);//Truyen\nmang toi phuong thuc }}\n\n, public class TestArray3 { public static void main(String[] args) { double[]\nBK49 = {1.9, 2.9, 3.4, 3.5}; // In tat ca cac phan tu mang for (double\nelement: BK49) { System.out.println(element); } } }\n\n, package edu.doannhg.basic; public class ArrayDemo { public static void\nhamDaoNguoc(int[] list) { int[] result = new int[list.length]; // vong lap de\ndao nguoc mang for (int i = 0, j = result.length - 1; i < list.length; i++,\nj--) { result[j] = list[i]; } // vong lap foreach de hien thi cac phan tu\ntrong mang dao nguoc for (int a: result) { System.out.print(a+ \" \"); } }\npublic static void main(String [] args){ int [] arr = {9, 8, 7, 6, 5, 4, 3, 2,\n1}; hamDaoNguoc(arr); } }\n\n, Kieu_du_lieu[][] Bien_tham_chieu_mang; (hoac) Kieu_du_lieu\n[][]Bien_tham_chieu_mang; (hoac) Kieu_du_lieu Bien_tham_chieu_mang[][]; (hoac)\nKieu_du_lieu []Bien_tham_chieu_mang[];\n\n, int[][] arr=new int[3][3];//3 hang va 3 cot\n\n, arr[0][0]=1; arr[0][1]=2; arr[0][2]=3; arr[1][0]=4; arr[1][1]=5; arr[1][2]=6;\narr[2][0]=7; arr[2][1]=8; arr[2][2]=9;\n\n, class Testarray3{ public static void main(String args[]){ //khai bao va khoi\ntao mang 2 chieu int arr[][]={{1,2,3},{2,4,5},{4,4,5}}; //in mang hai chieu\nfor(int i=0;i<3;i++){ for(int j=0;j<3;j++){ System.out.print(arr[i][j]+\" \"); }\nSystem.out.println(); } }}\n\n, class Testarray4{ public static void main(String args[]){ int arr[]={4,4,5};\nClass c=arr.getClass(); String name=c.getName(); System.out.println(name); }}\n\n, public static void arraycopy( Object src, int srcPos,Object dest, int destPos,\nint length )\n\n, class TestArrayCopyDemo { public static void main(String[] args) { char[]\ncopyFrom = { 'd', 'e', 'c', 'a', 'f', 'f', 'e', 'i', 'n', 'a', 't', 'e', 'd'\n}; char[] copyTo = new char[7]; System.arraycopy(copyFrom, 2, copyTo, 0, 7);\nSystem.out.println(new String(copyTo)); } }\n\n, class Testarray5{ public static void main(String args[]){ //tao hai ma tran\nint a[][]={{1,3,4},{3,4,5}}; int b[][]={{1,3,4},{3,4,5}}; //tao ma tran khac\nde luu giu ket qua phep cong hai ma tran int c[][]=new int[2][3]; //cong va in\ntong hai ma tran for(int i=0;i<2;i++){ for(int j=0;j<3;j++){\nc[i][j]=a[i][j]+b[i][j]; System.out.print(c[i][j]+\" \"); }\nSystem.out.println();//new line } }}\n\n",
      "id": "2831"
    }
  },
  {
    "id": "293",
    "name": "Lớp Wrapper",
    "href": "https://www.vietjack.com/java/lop_wrapper_trong_java.jsp",
    "lesson": {
      "title": "lớp wrapper trong java",
      "content": "Các lớp wrapper trong Java cung cấp một cơ chế để chuyển đổi giữa các kiểu dữ liệu nguyên thủy và các đối tượng. Tính năng tự động đóng gói (autoboxing) và tự động mở gói (unboxing) được giới thiệu trong Java 5.0, giúp cho việc chuyển đổi giữa các kiểu dữ liệu nguyên thủy và các đối tượng trở nên dễ dàng hơn.\n\nCó 8 lớp wrapper trong gói java.lang, mỗi lớp tương ứng với một kiểu dữ liệu nguyên thủy. Bảng dưới đây liệt kê danh sách 8 lớp wrapper:\n\n| Kiểu dữ liệu nguyên thủy | Lớp wrapper |\n|---|---|\n| boolean | Boolean |\n| byte | Byte |\n| char | Character |\n| short | Short |\n| int | Integer |\n| long | Long |\n| float | Float |\n| double | Double |\n\nCác lớp wrapper cung cấp nhiều phương thức tiện dụng để thao tác với các kiểu dữ liệu nguyên thủy tương ứng. Ví dụ, lớp Integer có các phương thức để chuyển đổi một số nguyên thành chuỗi, kiểm tra xem một số nguyên có phải là số chẵn hay không, v.v.\n\nCác lớp wrapper cũng hỗ trợ các toán tử so sánh và toán tử số học. Điều này cho phép bạn thực hiện các phép toán với các đối tượng wrapper theo cách tương tự như bạn thực hiện với các kiểu dữ liệu nguyên thủy.Lớp Wrapper\n\n\n- boolean: Boolean\n- char: Character\n- byte: Byte\n- short: Short\n- int: Integer\n- long: Long\n- float: Float\n- double: Doublepublic class WrapperExample1{ public static void main(String args[]){ //Chuyen\ndoi int thanh Integer int a=20; Integer i=Integer.valueOf(a);//Chuyen doi int\nthanh Integer Integer j=a;//Day la autoboxing, bay gio compiler se viet la\nInteger.valueOf(a) System.out.println(a+\" \"+i+\" \"+j); }}\n\n, public class WrapperExample2{ public static void main(String args[]){ //Chuyen\ndoi Integer thanh int Integer a=new Integer(3); int i=a.intValue();//Chuyen\ndoi Integer thanh int int j=a;//Day la unboxing, bay gio compiler se viet la\na.intValue() System.out.println(a+\" \"+i+\" \"+j); }}\n\n",
      "id": "2931"
    }
  },
  {
    "id": "303",
    "name": "Gọi bởi giá trị",
    "href": "https://www.vietjack.com/java/goi_boi_gia_tri_trong_java.jsp",
    "lesson": {
      "title": "gọi bởi giá trị trong java",
      "content": "Trong lập trình Java, có hai cách truyền tham số cho phương thức: gọi theo giá trị và gọi theo tham chiếu.\n\n- Gọi theo giá trị: khi truyền tham số theo giá trị, một bản sao của tham số được tạo và truyền cho phương thức. Bất kỳ thay đổi nào đối với bản sao này trong phương thức được gọi sẽ không ảnh hưởng đến tham số gốc trong phương thức gọi.\n\n- Gọi theo tham chiếu: khi truyền tham số theo tham chiếu, tham chiếu đến tham số gốc được truyền cho phương thức. Bất kỳ thay đổi nào đối với tham số trong phương thức được gọi sẽ ảnh hưởng đến tham số gốc trong phương thức gọi.\n\nTrong Java, chỉ có gọi theo giá trị. Không có gọi theo tham chiếu. Khi chúng ta gọi một phương thức và truyền một giá trị, thì đó là gọi theo giá trị. Các thay đổi được thực hiện trong phương thức được gọi sẽ không ảnh hưởng đến giá trị trong phương thức gọi.class Vidu{ int data=50; void change(int data){ data=data+100;//cac thay doi\nse chi o trong bien cuc bo } public static void main(String args[]){ Vidu\nop=new Vidu(); System.out.println(\"Truoc khi thay doi \"+op.data);\nop.change(500); System.out.println(\"Sau khi thay doi \"+op.data); } }\n\n, Output:Truoc khi thay doi 50 Sau khi thay doi 50\n\n, class Vidu2{ int data=50; void change(Vidu2 op){ op.data=op.data+100;//Cac\nthay doi se la trong bien instance } public static void main(String args[]){\nVidu2 op=new Vidu2(); System.out.println(\"Truoc khi thay doi \"+op.data);\nop.change(op);//truyen doi tuong System.out.println(\"Sau khi thay doi\n\"+op.data); } }\n\n, Output:Truoc khi thay doi 50 Sau khi thay doi 150\n\n",
      "id": "3031"
    }
  },
  {
    "id": "313",
    "name": "Từ khóa strictfp",
    "href": "https://www.vietjack.com/java/tu_khoa_strictfp_trong_java.jsp",
    "lesson": {
      "title": "từ khóa strictfp trong java",
      "content": "* Từ khóa `strictfp` không thể được áp dụng cho các phương thức trừu tượng, các biến hoặc các hàm khởi tạo.\n* Từ khóa `strictfp` có thể được áp dụng cho các phương thức, các lớp và giao diện.\n* Từ khóa `strictfp` đảm bảo rằng bạn sẽ nhận được cùng kết quả trên mọi nền tảng nếu bạn thực hiện các phép toán trên các giá trị số thực dấu chấm động.\n* Độ chính xác của các giá trị số thực dấu chấm động có thể khác nhau giữa các nền tảng và đó là lý do tại sao ngôn ngữ lập trình Java cung cấp từ khóa `strictfp` để bạn có thể nhận được cùng kết quả trên mọi nền tảng.\n* Vì vậy, bây giờ bạn sẽ có sự kiểm soát tốt hơn với các phép toán về số thực.strictfp class A{}//strictfp ap dung tren lop\n\n, strictfp interface M{}//strictfp ap dung tren interface\n\n, class A{ strictfp void m(){}//strictfp ap dung tren phuong thuc }\n\n, class B{ strictfp abstract void m();//su to hop khong hop le cua các modifier\n}\n\n, class B{ strictfp int data=10;//modifier strictfp khong duoc cho phep o day }\n\n, class B{ strictfp B(){}//modifier strictfp khong duoc cho phep o day }\n\n",
      "id": "3131"
    }
  },
  {
    "id": "323",
    "name": "Date & Time",
    "href": "https://www.vietjack.com/java/date_time_trong_java.jsp",
    "lesson": {
      "title": "date và time trong java",
      "content": "* Lớp `Calendar` là một lớp trừu tượng đại diện cho một lịch cụ thể. Nó cung cấp các phương thức để thao tác với các trường ngày tháng, chẳng hạn như năm, tháng, ngày, giờ, phút và giây.\n* Lớp `GregorianCalendar` là một lớp con cụ thể của lớp `Calendar` triển khai lịch Gregory. Nó là lịch được sử dụng rộng rãi nhất trên thế giới.\n* Lớp `SimpleDateFormat` là một lớp cụ thể được sử dụng để định dạng và phân tích các ngày tháng. Nó cho phép bạn xác định một mẫu định dạng tùy chỉnh để định dạng ngày tháng.\n* Lớp `Date` là một lớp cụ thể đại diện cho một điểm thời gian. Nó lưu trữ ngày tháng và thời gian hiện tại.\n* Phương thức `compareTo()` được sử dụng để so sánh hai đối tượng `Date`. Nó trả về một giá trị âm nếu đối tượng gọi đến sớm hơn đối tượng được truyền vào, một giá trị dương nếu đối tượng gọi đến muộn hơn đối tượng được truyền vào hoặc 0 nếu hai đối tượng bằng nhau.\n* Phương thức `getTime()` được sử dụng để lấy số mili giây đã trôi qua kể từ nửa đêm ngày 1 tháng 1 năm 1970.\n* Phương thức `toString()` được sử dụng để chuyển đổi đối tượng `Date` thành một chuỗi.**Phương thức và Miêu tả**\n\n1. **after(Date date)**: Trả về true nếu ngày của đối tượng Date đang gọi muộn hơn ngày đã cho, nếu không trả về false.\n2. **before(Date date)**: Trả về true nếu ngày của đối tượng Date đang gọi sớm hơn ngày đã cho, nếu không trả về false.\n3. **clone()**: Sao chép đối tượng Date đang gọi.\n4. **compareTo(Date date)**: So sánh giá trị của đối tượng đang gọi với giá trị của date. Trả về 0 nếu các giá trị này bằng nhau, trả về một giá trị âm nếu đối tượng đang gọi sớm hơn date, trả về một giá trị dương nếu đối tượng đang gọi muộn hơn date.\n5. **compareTo(Object obj)**: Thực hiện tương tự như compareTo(Date) nếu đối tượng là của lớp Date. Nếu không, nó sẽ trả về một ClassCastException.\n6. **equals(Object date)**: Trả về true nếu đối tượng Date đang gọi có thời gian và ngày tháng giống như date đã cho, nếu không trả về false.\n7. **getTime()**: Trả về số mili giây đã trôi qua kể từ ngày 1 tháng 1 năm 1970.\n8. **hashCode()**: Trả về một mã băm (hash code) cho đối tượng đang gọi.\n9. **setTime(long time)**: Thiết lập ngày tháng và thời gian thành time đã cho, biểu thị số mili giây đã trôi qua (tính bằng mili giây) kể từ nửa đêm ngày 1 tháng 1 năm 1970.\n10. **toString()**: Chuyển đổi đối tượng Date đang gọi thành một chuỗi và trả về kết quả.\n\n**Constructor và miêu tả**\n\n1. **GregorianCalendar()**: Tạo một GregorianCalendar mặc định bằng cách sử dụng thời gian hiện tại trong múi giờ mặc định với bản địa hóa mặc định.\n2. **GregorianCalendar(int year, int month, int date)**: Tạo một GregorianCalendar với ngày tháng đã cho trong múi giờ mặc định với bản địa hóa mặc định.\n3. **GregorianCalendar(int year, int month, int date, int hour, int minute)**: Tạo một GregorianCalendar với ngày tháng và thời gian đã cho trong múi giờ mặc định với bản địa hóa mặc định.\n4. **GregorianCalendar(int year, int month, int date, int hour, int minute, int second)**: Tạo một GregorianCalendar với ngày tháng và thời gian đã cho trong múi giờ mặc định với bản địa hóa mặc định.\n5. **GregorianCalendar(Locale aLocale)**: Tạo một GregorianCalendar dựa trên thời gian hiện tại trong múi giờ mặc định với bản địa hóa đã cho.\n6. **GregorianCalendar(TimeZone zone)**: Tạo một GregorianCalendar dựa trên thời gian hiện tại trong múi giờ đã cho với bản địa hóa mặc định.\n7. **GregorianCalendar(TimeZone zone, Locale aLocale)**: Tạo một GregorianCalendar dựa trên thời gian hiện tại trong múi giờ đã cho với bản địa hóa đã cho.\n\n**Phương thức và miêu tả**\n\n1. **add(int field, int amount)**: Thêm một số lượng thời gian nhất định vào trường thời gian đã cho, dựa trên các quy tắc của lịch đó.\n2. **computeFields()**: Chuyển đổi UTC dạng mili giây thành các giá trị trường thời gian.\n3. **computeTime()**: Ghi đè các giá trị trường thời gian đã chuyển đổi thành UTC dạng mili giây.\n4. **equals(Object obj)**: So sánh GregorianCalendar với một đối tượng tham chiếu.\n5. **get(int field)**: Nhận giá trị cho một trường thời gian đã cho.\n6. **getActualMaximum(int field)**: Trả về giá trị lớn nhất mà trường này có thể có, đã cho ngày hiện tại.\n7. **getActualMinimum(int field)**: Trả về giá trị nhỏ nhất mà trường này có thể có, đã cho ngày hiện tại.\n8. **getGreatestMinimum(int field)**: Trả về giá trị tối thiểu cao nhất cho trường đã cho nếu nó thay đổi.\n9. **getGregorianChange()**: Nhận ngày thay đổi theo Lịch Gregorian.\n10. **getLeastMaximum(int field)**: Trả về giá trị tối đa thấp nhất cho trường đã cho nếu nó thay đổi.\n11. **getMaximum(int field)**: Trả về giá trị tối đa cho trường đã cho.\n12. **getTime()**: Nhận thời gian hiện tại của Calendar này.\n13. **getTimeInMillis()**: Nhận thời gian hiện tại của Calendar này dạng long.\n14. **getTimeZone()**: Nhận múi giờ.\n15. **getMinimum(int field)**: Trả về giá trị tối thiểu cho trường đã cho.\n16. **hashCode()**: Ghi đè mã băm.\n17. **isLeapYear(int year)**: Xác định xem năm đã cho có phải là năm nhuận hay không.\n18. **roll(int field, boolean up)**: Cộng hoặc trừ một đơn vị thời gian trên trường thời gian đã cho mà không thay đổi các trường lớn hơn.\n19. **set(int field, int value)**: Thiết lập trường thời gian với giá trị đã cho.\n20. **set(int year, int month, int date)**: Thiết lập các giá trị cho các trường năm, tháng và ngày.\n21. **set(int year, int month, int date, int hour, int minute)**: Thiết lập các giá trị cho các trường năm, tháng, ngày, giờ và phút.\n22. **set(int year, int month, int date, int hour, int minute, int second)**: Thiết lập các giá trị cho các trường năm, tháng, ngày, giờ, phút và giây.\n23. **setGregorianChange(Date date)**: Thiết lập ngày thay đổi theo Lịch Gregorian.\n24. **setTime(Date date)**: Thiết lập thời gian hiện tại của Calendar này với Date đã cho.\n25. **setTimeInMillis(long millis)**: Thiết lập thời gian hiện tại của Calendar này từ giá trị long đã cho.\n26. **setTimeZone(TimeZone value)**: Thiết lập múi giờ với giá trị múi giờ đã cho.\n27. **toString()**: Trả về một biểu diễn chuỗi của lịch này.Date( )\n\n, Date(long millisec)\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // hien thi\ndate va time boi su dung toString() System.out.println(date.toString()); } }\n\n, Mon May 04 09:51:52 CDT 2009\n\n, import java.util.*; import java.text.*; public class DateDemo { public static\nvoid main(String args[]) { Date dNow = new Date( ); SimpleDateFormat ft = new\nSimpleDateFormat (\"E yyyy.MM.dd 'at' hh:mm:ss a zzz\");\nSystem.out.println(\"Date hien tai: \" + ft.format(dNow)); } }\n\n, Date hien tai: Sun 2004.07.18 at 04:14:09 PM PDT\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // Hien thi\ndate va time boi su dung toString() String str = String.format(\"Date hien\ntai/Time : %tc\", date ); System.out.printf(str); } }\n\n, Date hien tai/Time : Sat Dec 15 16:37:57 MST 2012\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // Hien thi\ndate va time boi su dung toString() System.out.printf(\"%1$s %2$tB %2$td,\n%2$tY\", \"Date la:\", date); } }\n\n, Date la: February 09, 2004\n\n, import java.util.Date; public class DateDemo { public static void main(String\nargs[]) { // khoi tao mot doi tuong Date Date date = new Date(); // Hien thi\ndate da duoc dinh dang System.out.printf(\"%s %tB %<te, %<tY\", \"Date la:\",\ndate); } }\n\n, Date la: February 09, 2004\n\n, import java.util.*; import java.text.*; public class DateDemo { public static\nvoid main(String args[]) { SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-\nMM-dd\"); String input = args.length == 0 ? \"1818-11-11\" : args[0];\nSystem.out.print(input + \" Duoc parse thanh dang \"); Date t; try { t =\nft.parse(input); System.out.println(t); } catch (ParseException e) {\nSystem.out.println(\"Khong the parse duoc boi su dung \" + ft); } } }\n\n, $ java DateDemo 1818-11-11 Duoc parse thanh dang Wed Nov 11 00:00:00 GMT 1818\n$ java DateDemo 2007-12-01 2007-12-01 Duoc parse thanh dang Sat Dec 01\n00:00:00 GMT 2007\n\n, import java.util.*; public class SleepDemo { public static void main(String\nargs[]) { try { System.out.println(new Date( ) + \"\\n\"); Thread.sleep(5*60*10);\nSystem.out.println(new Date( ) + \"\\n\"); } catch (Exception e) {\nSystem.out.println(\"Nhan mot exception!\"); } } }\n\n, Sun May 03 18:04:41 GMT 2009 Sun May 03 18:04:51 GMT 2009\n\n, import java.util.*; public class DiffDemo { public static void main(String\nargs[]) { try { long start = System.currentTimeMillis( );\nSystem.out.println(new Date( ) + \"\\n\"); Thread.sleep(5*60*10);\nSystem.out.println(new Date( ) + \"\\n\"); long end = System.currentTimeMillis(\n); long diff = end - start; System.out.println(\"Khac nhau la : \" + diff); }\ncatch (Exception e) { System.out.println(\"Nhan mot exception!\"); } } }\n\n, Sun May 03 18:16:51 GMT 2009 Sun May 03 18:16:57 GMT 2009 Difference is : 5993\n\n, import java.util.*; public class GregorianCalendarDemo { public static void\nmain(String args[]) { String months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n\"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"}; int year; // Tao mot\nGregorian calendar duoc khoi tao // voi date va time hien tai trong // locale\nva timezone mac dinh. GregorianCalendar gcalendar = new GregorianCalendar();\n// Hien thi thon tin date va time hien tai. System.out.print(\"Date: \");\nSystem.out.print(months[gcalendar.get(Calendar.MONTH)]); System.out.print(\" \"\n+ gcalendar.get(Calendar.DATE) + \" \"); System.out.println(year =\ngcalendar.get(Calendar.YEAR)); System.out.print(\"Time: \");\nSystem.out.print(gcalendar.get(Calendar.HOUR) + \":\");\nSystem.out.print(gcalendar.get(Calendar.MINUTE) + \":\");\nSystem.out.println(gcalendar.get(Calendar.SECOND)); // Kiem tra xem year hien\ntai co phai la leap year khong if(gcalendar.isLeapYear(year)) {\nSystem.out.println(\"Year hien tai la mot leap year\"); } else {\nSystem.out.println(\"Year hien tai khong la mot leap year\"); } } }\n\n, Date: Apr 22 2009 Time: 11:25:27 Year hien tai khong la mot leap year\n\n",
      "id": "3231"
    }
  },
  {
    "id": "333",
    "name": "Regular Expression",
    "href": "https://www.vietjack.com/java/regular_expression_trong_java.jsp",
    "lesson": {
      "title": "regular expression trong java",
      "content": "- Regular expression (biểu thức chính quy) là một chuỗi các ký tự đặc biệt giúp bạn tìm kiếm hoặc khớp chuỗi hoặc tập hợp chuỗi khác bằng cú pháp riêng biệt trong một mẫu. Chúng có thể được sử dụng để tìm, chỉnh sửa và thao tác văn bản và dữ liệu.\n- Java cung cấp gói `javautilregex` để khớp các mẫu với các biểu thức chính quy. Các biểu thức chính quy trong Java tương tự như trong ngôn ngữ lập trình Perl và rất dễ học.\n- Lớp `Pattern` là một biểu diễn biên dịch của một biểu thức chính quy. Bạn có thể tạo một đối tượng `Pattern` bằng cách gọi một trong các phương thức biên dịch tĩnh chung của nó. Các phương thức này chấp nhận một biểu thức chính quy làm tham số đầu tiên.\n- Lớp `Matcher` là phương tiện mà thông dịch mẫu và thực hiện các hoạt động khớp với một chuỗi đầu vào. Bạn nhận được một đối tượng `Matcher` bằng cách gọi phương thức `matcher` trên một đối tượng `Pattern`.\n- Lớp `PatternSyntaxException` là một ngoại lệ chưa được kiểm tra chỉ ra lỗi cú pháp trong mẫu biểu thức chính quy.\n- Các phương thức `appendReplacement` và `appendTail` trong lớp `Matcher` có thể được sử dụng để thay thế văn bản.\n- Các phương thức `replaceFirst` và `replaceAll` trong Java thay thế văn bản khớp với một biểu thức chính quy đã cho. Phương thức `replaceFirst` thay thế sự xuất hiện khớp đầu tiên trong khi phương thức `replaceAll` thay thế tất cả các khớp.\n- Các phương thức `matches` và `lookingAt` khớp một chuỗi đầu vào với một mẫu. Tuy nhiên, sự khác biệt giữa hai phương thức này là phương thức `matches` yêu cầu toàn bộ chuỗi đầu vào để khớp trong khi phương thức `lookingAt` thì không.\n- Các phương thức `start` và `end` trả về chỉ mục bắt đầu và kết thúc của chuỗi con được khớp bởi nhóm đã cho trong hoạt động khớp trước.\n- Các phương thức về chỉ mục cung cấp các giá trị chỉ mục hữu ích giúp tìm kiếm sự khớp chính xác trong chuỗi đầu vào.\n- Bảng cú pháp siêu ký tự cho biểu thức chính quy có sẵn trong Java được liệt kê trong tài liệu.\n- Các nhóm nắm bắt được đánh số bằng cách đếm số dấu ngoặc đơn mở từ trái sang phải. Ví dụ, biểu thức `abc` có bốn nhóm.\n- Một đối tượng `PatternSyntaxException` là một ngoại lệ chưa được kiểm tra chỉ ra lỗi cú pháp trong mẫu biểu thức chính quy.\n- Một đối tượng `Matcher` là phương tiện mà thông dịch mẫu và thực hiện các hoạt động khớp với một chuỗi đầu vào.\n- Một đối tượng `Pattern` là một biểu diễn biên dịch của một biểu thức chính quy.\n- Gói `javautilregex` chủ yếu chứa ba lớp: `Pattern`, `Matcher` và `PatternSyntaxException`.- **So khớp:** \n\n  - ^: Bắt đầu dòng\n\n\n  - $: Kết thúc dòng\n\n\n  - .: Bất kỳ ký tự nào ngoại trừ ký tự dòng mới\n\n\n  - []: Tập hợp các ký tự\n\n\n  - [^]: Bất kỳ ký tự nào không có trong tập hợp\n\n\n  - \\A: Bắt đầu chuỗi\n\n\n  - \\z: Kết thúc chuỗi\n\n\n  - \\Z: Kết thúc chuỗi trước khi có ký tự dòng mới\n\n\n  - re*: Bất kỳ số lần xuất hiện nào của biểu thức trước\n\n\n  - re+: Ít nhất một lần xuất hiện của biểu thức trước\n\n\n  - re?: Bất kỳ số lần xuất hiện nào của biểu thức trước hoặc không xuất hiện\n\n\n  - re{n}: Chính xác n lần xuất hiện của biểu thức trước\n\n\n  - re{n,}: Ít nhất n lần xuất hiện của biểu thức trước\n\n\n  - re{n,m}: Ít nhất n và nhiều nhất m lần xuất hiện của biểu thức trước\n\n\n  - a|b: Biểu thức a hoặc biểu thức b\n\n\n  - (re): Nhóm biểu thức chính quy\n\n\n  - (?:re): Nhóm biểu thức chính quy không ghi nhớ\n\n\n  - (?>re): Nhóm biểu thức chính quy không theo dõi ngược\n\n\n  - \\w: Ký tự từ\n\n\n  - \\W: Ký tự không phải từ\n\n\n  - \\s: Ký tự khoảng trắng\n\n\n  - \\S: Ký tự không phải khoảng trắng\n\n\n  - \\d: Chữ số\n\n\n  - \\D: Ký tự không phải chữ số\n\n\n  - \\A: Bắt đầu chuỗi\n\n\n  - \\Z: Kết thúc chuỗi\n\n\n  - \\z: Kết thúc chuỗi trước khi có ký tự dòng mới\n\n\n  - \\G: Vị trí kết thúc của lần khớp trước\n\n\n  - \\n: Tham chiếu ngược đến nhóm biểu thức chính quy thứ n\n\n\n  - \\b: Ranh giới từ\n\n\n  - \\B: Ranh giới không phải từ\n\n\n  - \\n, \\t, v.v.: Ký tự dòng mới, ký tự trả về, ký tự tab, v.v.\n\n\n  - \\Q: Bắt đầu chuỗi ký tự trích dẫn\n\n\n  - \\E: Kết thúc chuỗi ký tự trích dẫn\n\n\n- **Phương thức Matcher:**\n\n  - start(): Trả về chỉ mục bắt đầu của lần khớp trước\n\n\n  - start(int group): Trả về chỉ mục bắt đầu của nhóm thứ group trong lần khớp trước\n\n\n  - end(): Trả về chỉ mục kết thúc của lần khớp trước\n\n\n  - end(int group): Trả về chỉ mục kết thúc của nhóm thứ group trong lần khớp trước\n\n\n  - lookingAt(): Kiểm tra xem có thể khớp mẫu với đầu vào mà không cần di chuyển con trỏ\n\n\n  - find(): Tìm lần khớp tiếp theo của mẫu trong đầu vào\n\n\n  - find(int start): Tìm lần khớp tiếp theo của mẫu trong đầu vào, bắt đầu từ chỉ mục start\n\n\n  - matches(): Kiểm tra xem có thể khớp mẫu với toàn bộ đầu vào hay không\n\n\n  - appendReplacement(StringBuffer sb, String replacement): Thêm chuỗi thay thế vào bộ đệm và thay thế lần khớp tiếp theo trong đầu vào bằng chuỗi thay thế\n\n\n  - appendTail(StringBuffer sb): Thêm phần còn lại của đầu vào vào bộ đệm\n\n\n  - replaceAll(String replacement): Thay thế tất cả các lần khớp của mẫu trong đầu vào bằng chuỗi thay thế\n\n\n  - replaceFirst(String replacement): Thay thế lần khớp đầu tiên của mẫu trong đầu vào bằng chuỗi thay thế\n\n\n  - quoteReplacement(String s): Trích dẫn chuỗi thay thế để sử dụng trong phương thức appendReplacement\n\n\n- **Phương thức PatternSyntaxException:**\n\n  - getDescription(): Trả về mô tả lỗi\n\n\n  - getIndex(): Trả về chỉ mục của lỗi\n\n\n  - getPattern(): Trả về mẫu biểu thức chính quy sai sót\n\n\n  - getMessage(): Trả về chuỗi chứa mô tả lỗi, chỉ mục lỗi và mẫu biểu thức chính quy sai sótimport java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { public static void main( String args[] ){ // String de duoc\nquet de tim pattern. String line = \"Vietjack xin chao cac ban. Day la vi du ve\nRegex! 1000 0USD\"; String pattern = \"(.*)(\\\\\\d+)(.*)\"; // Tao mot doi tuong\nPattern Pattern r = Pattern.compile(pattern); // Tao doi tuong matcher.\nMatcher m = r.matcher(line); if (m.find( )) { System.out.println(\"Gia tri duoc\ntim thay la: \" + m.group(0) ); System.out.println(\"Gia tri duoc tim thay la: \"\n+ m.group(1) ); System.out.println(\"Gia tri duoc tim thay la: \" + m.group(2)\n); } else { System.out.println(\"Khong co ket noi\"); } } }\n\n, Gia tri duoc tim thay la: Vietjack xin chao cac ban. Day la vi du ve Regex!\n1000 0USD Gia tri duoc tim thay la: Vietjack xin chao cac ban. Day la vi du ve\nRegex! 1000 Gia tri duoc tim thay la: 0\n\n, import java.util.regex.*; class RegexExample5{ public static void main(String\nargs[]){ System.out.println(\"cac metacharacter d....\");//d nghia la ky so\n(digit) System.out.println(Pattern.matches(\"\\\\\\d\", \"abc\"));//false (non-digit)\nSystem.out.println(Pattern.matches(\"\\\\\\d\", \"1\"));//true (digit va xuat hien\nmot lan) System.out.println(Pattern.matches(\"\\\\\\d\", \"4443\"));//false (digit\nnhung xuat hien nhieu hon mot lan) System.out.println(Pattern.matches(\"\\\\\\d\",\n\"323abc\"));//false (digit va char) System.out.println(\"cac metacharacter\nD....\");//D nghia la khong phai ky so (non-digit)\nSystem.out.println(Pattern.matches(\"\\\\\\D\", \"abc\"));//false (non-digit nhung\nxuat hien nhieu hon mot lan) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"1\"));//false (digit) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"4443\"));//false (digit) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"323abc\"));//false (digit va char) System.out.println(Pattern.matches(\"\\\\\\D\",\n\"m\"));//true (non-digit va xuat hien mot lan) System.out.println(\"cac\nmetacharacter D voi quantifier....\");\nSystem.out.println(Pattern.matches(\"\\\\\\D*\", \"mak\"));//true (non-digit va co\nthe xuat hien 0 hoac nhie lan) }}\n\n, cac metacharacter d.... false true false false cac metacharacter D.... false\nfalse false false true cac metacharacter D voi quantifier.... true\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static final String REGEX = \"\\\\\\bplay\\\\\\b\"; private\nstatic final String INPUT = \"play play play football tennis play\"; public\nstatic void main( String args[] ){ Pattern p = Pattern.compile(REGEX); Matcher\nm = p.matcher(INPUT); // Lay mot doi tuong matcher int count = 0;\nwhile(m.find()) { count++; System.out.println(\"So ket noi \"+count);\nSystem.out.println(\"start(): \"+m.start()); System.out.println(\"end():\n\"+m.end()); } } }\n\n, So ket noi 1 start(): 0 end(): 4 So ket noi 2 start(): 5 end(): 9 So ket noi 3\nstart(): 10 end(): 14 So ket noi 4 start(): 31 end(): 35\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static final String REGEX = \"it\"; private static final\nString INPUT = \"itttttttttttttgaphot\"; private static Pattern pattern; private\nstatic Matcher matcher; public static void main( String args[] ){ pattern =\nPattern.compile(REGEX); matcher = pattern.matcher(INPUT);\nSystem.out.println(\"REGEX hien tai la: \"+REGEX); System.out.println(\"INPUT\nhien tai la: \"+INPUT); System.out.println(\"lookingAt():\n\"+matcher.lookingAt()); System.out.println(\"matches(): \"+matcher.matches()); }\n}\n\n, REGEX hien tai la: it INPUT hien tai la: itttttttttttttgaphot lookingAt():\ntrue matches(): false\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static String REGEX = \"HaDong\"; private static String\nINPUT = \"HaDong nam o mien nam. \" + \"HaDong la thanh pho cua BinhDuong.\";\nprivate static String REPLACE = \"BinhDuong\"; public static void main(String[]\nargs) { Pattern p = Pattern.compile(REGEX); // lay mot doi tuong matcher\nMatcher m = p.matcher(INPUT); INPUT = m.replaceAll(REPLACE);\nSystem.out.println(INPUT); } }\n\n, BinhDuong nam o mien nam. BinhDuong la thanh pho cua BinhDuong.\n\n, import java.util.regex.Matcher; import java.util.regex.Pattern; public class\nRegexMatches { private static String REGEX = \"a*b\"; private static String\nINPUT = \"aabfooaabfooabfoob\"; private static String REPLACE = \"-\"; public\nstatic void main(String[] args) { Pattern p = Pattern.compile(REGEX); // lay\nmot doi tuong matcher Matcher m = p.matcher(INPUT); StringBuffer sb = new\nStringBuffer(); while(m.find()){ m.appendReplacement(sb,REPLACE); }\nm.appendTail(sb); System.out.println(sb.toString()); } }\n\n, -foo-foo-foo- \n\n",
      "id": "3331"
    }
  },
  {
    "id": "14",
    "name": "File và I/O",
    "href": "https://www.vietjack.com/java/file_io_trong_java.jsp",
    "lesson": {
      "title": "file và i/o trong java",
      "content": "- Các lớp `File` và `FileReader` có thể được sử dụng để đọc các file văn bản.\n- Các lớp `File` và `FileInputStream` có thể được sử dụng để đọc các file nhị phân.\n- Phương thức `list()` của lớp `File` có thể được sử dụng để liệt kê các file và thư mục trong một thư mục.\n- Phương thức `mkdirs()` của lớp `File` có thể được sử dụng để tạo một thư mục.\n- Phương thức `mkdir()` của lớp `File` có thể được sử dụng để tạo một thư mục.\n- Các lớp `FileOutputStream` và `FileWriter` có thể được sử dụng để ghi vào các file.\n- Phương thức `write()` của lớp `FileOutputStream` có thể được sử dụng để ghi các byte vào một file.\n- Phương thức `write()` của lớp `FileWriter` có thể được sử dụng để ghi các ký tự vào một file.\n- Phương thức `close()` của lớp `FileOutputStream` và `FileWriter` có thể được sử dụng để đóng file.\n- Các lớp `FileInputStream` và `FileReader` có thể được sử dụng để đọc từ các file.\n- Phương thức `read()` của lớp `FileInputStream` có thể được sử dụng để đọc các byte từ một file.\n- Phương thức `read()` của lớp `FileReader` có thể được sử dụng để đọc các ký tự từ một file.\n- Phương thức `close()` của lớp `FileInputStream` và `FileReader` có thể được sử dụng để đóng file.**STT** | **Phương thức** | **Miêu tả**\n------- | -------- | --------\n1 | `close()` | Đóng output stream và giải phóng bất kỳ nguồn hệ thống nào liên kết với file. Ném IOException nếu có lỗi.\n2 | `finalize()` | Xóa sự kết nối tới file và đảm bảo rằng phương thức `close()` được gọi khi không có tham chiếu nào nữa tới stream này. Ném IOException nếu có lỗi.\n3 | `read(int r)` | Đọc một byte dữ liệu đã xác định từ InputStream và trả về dưới dạng int. Trả về -1 nếu kết thúc file.\n4 | `read(byte[] r)` | Đọc `r` byte từ input stream vào một mảng byte và trả về tổng số byte đã đọc. Trả về -1 nếu kết thúc file.\n5 | `available()` | Cung cấp số byte có thể đọc được từ input stream này dưới dạng int.import java.io.*; public class CopyFile { public static void main(String\nargs[]) throws IOException { FileInputStream in = null; FileOutputStream out =\nnull; try { in = new FileInputStream(\"input.txt\"); out = new\nFileOutputStream(\"output.txt\"); int c; while ((c = in.read()) != -1) {\nout.write(c); } }finally { if (in != null) { in.close(); } if (out != null) {\nout.close(); } } } }\n\n, Day la vi du ve sao chep file.\n\n, $javac CopyFile.java $java CopyFile\n\n, import java.io.*; public class CopyFile { public static void main(String\nargs[]) throws IOException { FileReader in = null; FileWriter out = null; try\n{ in = new FileReader(\"input.txt\"); out = new FileWriter(\"output.txt\"); int c;\nwhile ((c = in.read()) != -1) { out.write(c); } }finally { if (in != null) {\nin.close(); } if (out != null) { out.close(); } } } }\n\n, Day la vi du ve sao chep file.\n\n, $javac CopyFile.java $java CopyFile\n\n, import java.io.*; public class ReadConsole { public static void main(String\nargs[]) throws IOException { InputStreamReader cin = null; try { cin = new\nInputStreamReader(System.in); System.out.println(\"Nhap cac ky tu, 'q' de\nthoat.\"); char c; do { c = (char) cin.read(); System.out.print(c); } while(c\n!= 'q'); }finally { if (cin != null) { cin.close(); } } } }\n\n, $javac ReadConsole.java $java ReadConsole Nhap cac ky tu, 'q' de thoat. 1 1 e\ne q q\n\n, InputStream f = new FileInputStream(\"C:/java/hello\");\n\n, File f = new File(\"C:/java/hello\"); InputStream f = new FileInputStream(f);\n\n, OutputStream f = new FileOutputStream(\"C:/java/hello\")\n\n, File f = new File(\"C:/java/hello\"); OutputStream f = new FileOutputStream(f);\n\n, import java.io.*; public class fileStreamTest{ public static void main(String\nargs[]){ try{ byte bWrite [] = {11,21,3,40,5}; OutputStream os = new\nFileOutputStream(\"test.txt\"); for(int x=0; x < bWrite.length ; x++){ os.write(\nbWrite[x] ); // writes the bytes } os.close(); InputStream is = new\nFileInputStream(\"test.txt\"); int size = is.available(); for(int i=0; i< size;\ni++){ System.out.print((char)is.read() + \" \"); } is.close();\n}catch(IOException e){ System.out.print(\"Exception\"); } } }\n\n, import java.io.File; public class CreateDir { public static void main(String\nargs[]) { String dirname = \"/tmp/user/java/bin\"; File d = new File(dirname);\n// Bay gio tao thu muc. d.mkdirs(); } }\n\n, import java.io.File; public class ReadDir { public static void main(String[]\nargs) { File file = null; String[] paths; try{ // Tao doi tuong file moi file\n= new File(\"/tmp\"); // mang cac file va thu muc paths = file.list(); // voi\nmoi ten trong path array for(String path:paths) { // in ten file va ten thu\nmuc System.out.println(path); } }catch(Exception e){ // neu co bat cu error\nnao xuat hien e.printStackTrace(); } } }\n\n, test1.txt test2.txt ReadDir.java ReadDir.class\n\n",
      "id": "141"
    }
  },
  {
    "id": "24",
    "name": "ByteArrayInputStream",
    "href": "https://www.vietjack.com/java/bytearrayinputstream_trong_java.jsp",
    "lesson": {
      "title": "bytearrayinputstream trong java",
      "content": "Khi chạy mẫu chương trình, kết quả thu được sẽ như sau:\n\nBytearrayinputstream và bytearrayoutputstream trong Java:\n\nPhương thức skip(n): Bỏ qua n byte từ stream. Phương thức này trả về số byte thực sự bị bỏ qua.\n\nPhương thức mark(readlimit): Thiết lập vị trí đã đánh dấu hiện tại trong stream. Tham số readlimit cung cấp giới hạn tối đa của các byte mà có thể được đọc trước khi vị trí đã đánh dấu trở nên vô hiệu.\n\nPhương thức reset(): Thiết lập lại vị trí đọc thành vị trí đã đánh dấu trước đó.\n\nPhương thức available(): Cung cấp số lượng byte mà có thể được đọc từ file input stream này.\n\nPhương thức read(): Trả về một int mà cung cấp số các byte để được đọc.\n\nPhương thức read(b, off, len): Đọc len byte bắt đầu từ từ input stream vào trong một mảng. Trả về tổng số byte đã đọc nếu kết thúc file thì trả về -1.\n\nPhương thức read(b): Đọc byte kế tiếp của dữ liệu từ inputstream. Trả về một int như là byte kế tiếp của dữ liệu nếu nó là kết thúc của file thì trả về -1.\n\nKhi bạn có đối tượng bytearrayinputstream thì có một số phương thức có thể được sử dụng để đọc stream hoặc để thực hiện các hoạt động khác trên stream đó.\n\nCó hai constructor để tạo đối tượng bytearrayinputstream:\n\n- Constructor không tham số: Tạo một đối tượng bytearrayinputstream với một mảng byte trống.\n- Constructor nhận một mảng các byte: Tạo một đối tượng bytearrayinputstream với một mảng byte đã cho.\n\nNgoài ra, còn có một constructor khác nhận một mảng các byte và hai int với offset là byte đầu tiên để được đọc và len là số byte để được đọc.\n\nLớp bytearrayinputstream cho phép một bộ đệm buffer trong bộ nhớ để được sử dụng như là một inputstream. Nguồn input này là một mảng byte.1. Phương thức read() đọc byte tiếp theo của dữ liệu từ InputStream và trả về dưới dạng int. Nếu là kết thúc file, trả về -1.\n\n\n2. Phương thức read(byte[] r, int off, int len) đọc len byte bắt đầu từ off từ Input Stream vào trong một mảng và trả về tổng số byte đã đọc. Nếu là kết thúc file, trả về -1.\n\n\n3. Phương thức available() cung cấp số lượng byte mà có thể được đọc từ file input stream này và trả về dưới dạng int.\n\n\n4. Phương thức mark(int read) thiết lập vị trí đã đánh dấu hiện tại trong stream với tham số cung cấp giới hạn tối đa của các byte mà có thể được đọc trước khi vị trí đã đánh dấu trở nên vô hiệu.\n\n\n5. Phương thức skip(long n) bỏ qua n byte từ stream và trả về số byte thực sự bị bỏ qua.ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] a);\n\n, ByteArrayInputStream bArray = new ByteArrayInputStream(byte []a, int off, int\nlen)\n\n, import java.io.*; public class ByteStreamTest { public static void main(String\nargs[])throws IOException { ByteArrayOutputStream bOutput = new\nByteArrayOutputStream(12); while( bOutput.size()!= 10 ) { // Nhan input tu\nnguoi dung bOutput.write(System.in.read()); } byte b [] =\nbOutput.toByteArray(); System.out.println(\"In noi dung\"); for(int x= 0 ; x <\nb.length; x++) { // in cac ky tu System.out.print((char)b[x] + \" \"); }\nSystem.out.println(\" \"); int c; ByteArrayInputStream bInput = new\nByteArrayInputStream(b); System.out.println(\"Chuyen doi cac ky tu thanh chu\nhoa \" ); for(int y = 0 ; y < 1; y++ ) { while(( c= bInput.read())!= -1) {\nSystem.out.println(Character.toUpperCase((char)c)); } bInput.reset(); } } }\n\n, asdfghjkly In noi dung a s d f g h j k l y Chuyen doi cac ky tu thanh chu hoa\nA S D F G H J K L Y\n\n",
      "id": "241"
    }
  },
  {
    "id": "34",
    "name": "DataInputStream",
    "href": "https://www.vietjack.com/java/datainputstream_trong_java.jsp",
    "lesson": {
      "title": "datainputstream trong java",
      "content": "DataInputStream và DataOutputStream là hai lớp hữu ích để đọc và ghi dữ liệu gốc nguyên thủy trong Java. DataInputStream có thể được sử dụng để đọc các kiểu dữ liệu nguyên thủy như int, float, double, boolean và char. DataOutputStream có thể được sử dụng để ghi các kiểu dữ liệu nguyên thủy này vào một luồng.\n\nDataInputStream có một số phương thức hữu ích để đọc dữ liệu từ một luồng. Phương thức readLine() có thể được sử dụng để đọc một dòng văn bản từ luồng. Phương thức read() có thể được sử dụng để đọc một byte duy nhất từ luồng. Phương thức read(byte[] b) có thể được sử dụng để đọc một số byte từ luồng vào một mảng byte.\n\nDataOutputStream cũng có một số phương thức hữu ích để ghi dữ liệu vào một luồng. Phương thức writeLine() có thể được sử dụng để ghi một dòng văn bản vào luồng. Phương thức write() có thể được sử dụng để ghi một byte duy nhất vào luồng. Phương thức write(byte[] b) có thể được sử dụng để ghi một số byte từ một mảng byte vào luồng.\n\nDataInputStream và DataOutputStream có thể được sử dụng để thực hiện nhiều tác vụ khác nhau, chẳng hạn như đọc và ghi dữ liệu từ tệp, đọc và ghi dữ liệu từ mạng và đọc và ghi dữ liệu từ các thiết bị ngoại vi.1. Phương thức read() đọc len byte dữ liệu từ luồng đầu vào vào một mảng byte. Nó trả về tổng số byte đã đọc vào bộ đệm hoặc -1 nếu đó là cuối tệp.\n\n\n2. Phương thức read() đọc một số byte từ luồng đầu vào và lưu trữ chúng trong một mảng byte. Nó trả về tổng số byte đã đọc vào bộ đệm hoặc -1 nếu đó là cuối tệp.\n\n\n3. Có các hình thức sau:\n    - public final Boolean readBoolean() throws IOException\n    - public final byte readByte() throws IOException\n    - public final short readShort() throws IOException\n    - public final Int readInt() throws IOException\nCác phương thức này đọc các byte từ InputStream. Chúng trả về hai byte tiếp theo của InputStream dưới dạng kiểu dữ liệu nguyên thủy cụ thể.\n\n\n4. Phương thức readLine() đọc dòng văn bản tiếp theo từ luồng đầu vào. Nó đọc các byte liên tiếp, chuyển đổi từng byte thành một ký tự, cho đến khi gặp dấu kết thúc dòng hoặc kết thúc dòng; các ký tự đã đọc sau đó được trả về dưới dạng Chuỗi.InputStream in = DataInputStream(InputStream in);\n\n, import java.io.*; public class Test{ public static void main(String\nargs[])throws IOException{ DataInputStream d = new DataInputStream(new\nFileInputStream(\"test.txt\")); DataOutputStream out = new DataOutputStream(new\nFileOutputStream(\"test1.txt\")); String count; while((count = d.readLine()) !=\nnull){ String u = count.toUpperCase(); System.out.println(u); out.writeBytes(u\n+ \" ,\"); } d.close(); out.close(); } }\n\n, DAY LA TEST 1 , DAY LA TEST 2 , DAY LA TEST 3 , DAY LA TEST 4 , DAY LA TEST 5\n,\n\n",
      "id": "341"
    }
  },
  {
    "id": "44",
    "name": "ByteArrayOutputStream",
    "href": "https://www.vietjack.com/java/bytearrayoutputstream_trong_java.jsp",
    "lesson": {
      "title": "bytearrayoutputstream trong java",
      "content": "Bytearrayoutputstream là một lớp trong Java dùng để tạo một luồng đầu ra byte trong bộ nhớ. Khi bạn có một đối tượng bytearrayoutputstream, có một số phương thức có thể được sử dụng để ghi vào luồng đó hoặc để thực hiện các hoạt động khác trên luồng đó.\n\nCác constructor sau được sử dụng để tạo đối tượng bytearrayoutputstream trong Java:\n\n- Bytearrayoutputstream(): Constructor này tạo một buffer có kích thước mặc định là 32 byte.\n- Bytearrayoutputstream(int size): Constructor này tạo một buffer có kích thước là int.\n\nCác phương thức sau có thể được sử dụng để ghi vào bytearrayoutputstream:\n\n- Write(int b): Phương thức này ghi một byte duy nhất vào luồng.\n- Write(byte[] b): Phương thức này ghi một mảng byte vào luồng.\n- Write(byte[] b, int off, int len): Phương thức này ghi một phần của mảng byte vào luồng, bắt đầu từ vị trí off và ghi len byte.\n\nCác phương thức sau có thể được sử dụng để đọc từ bytearrayoutputstream:\n\n- Tostring(): Phương thức này trả về một chuỗi chứa nội dung của luồng.\n- ToByteArray(): Phương thức này trả về một mảng byte chứa nội dung của luồng.\n\nPhương thức sau có thể được sử dụng để xóa nội dung của bytearrayoutputstream:\n\n- Reset(): Phương thức này xóa nội dung của luồng.1. Phương thức `reset()` thiết lập lại số lượng byte hợp lệ trong mảng byte trong luồng đầu ra về 0, do đó xóa tất cả dữ liệu đã lưu trong luồng.\n\n\n2. Phương thức `toByteArray()` tạo một mảng byte mới có kích thước bằng kích thước hiện tại của luồng đầu ra và sao chép nội dung của bộ đệm vào đó. Phương thức này trả về nội dung hiện tại của luồng đầu ra dưới dạng mảng byte.\n\n\n3. Phương thức `toString()` chuyển đổi nội dung của bộ đệm thành chuỗi theo mã hóa ký tự mặc định. Phương thức này trả về chuỗi đã được chuyển đổi từ nội dung của bộ đệm.\n\n\n4. Phương thức `write(int w)` ghi một byte đã cho vào luồng đầu ra.\n\n\n5. Phương thức `write(byte []b, int of, int len)` ghi `len` byte bắt đầu từ vị trí `off` trong mảng `b` vào luồng.\n\n\n6. Phương thức `writeTo(OutputStream outSt)` ghi toàn bộ nội dung của luồng này vào luồng đã chỉ định.OutputStream bOut = new ByteArrayOutputStream()\n\n, OutputStream bOut = new ByteArrayOutputStream(int a)\n\n, import java.io.*; public class ByteStreamTest { public static void main(String\nargs[])throws IOException { ByteArrayOutputStream bOutput = new\nByteArrayOutputStream(12); while( bOutput.size()!= 10 ) { // Nhan input tu\nnguoi dung bOutput.write(System.in.read()); } byte b [] =\nbOutput.toByteArray(); System.out.println(\"In noi dung\"); for(int x= 0 ; x <\nb.length; x++) { //In cac ky tu System.out.print((char)b[x] + \" \"); }\nSystem.out.println(\" \"); int c; ByteArrayOutputStream bInput = new\nByteArrayOutputStream(b); System.out.println(\"Chuyen doi cac ky tu thanh chu\nhoa \" ); for(int y = 0 ; y < 1; y++ ) { while(( c= bInput.read())!= -1) {\nSystem.out.println(Character.toUpperCase((char)c)); } bInput.reset(); } } }\n\n, asdfghjkly In noi dung a s d f g h j k l y Chuyen doi cac ky tu thanh chu hoa\nA S D F G H J K L Y\n\n",
      "id": "441"
    }
  },
  {
    "id": "54",
    "name": "DataOutputStream",
    "href": "https://www.vietjack.com/java/dataoutputstream_trong_java.jsp",
    "lesson": {
      "title": "dataoutputstream trong java",
      "content": "Trong Java, lớp DataOutputStream được sử dụng để ghi các kiểu dữ liệu gốc vào một nguồn đầu ra. Nó cung cấp các phương thức để ghi các kiểu dữ liệu như int, float, double, boolean, char và string. Lớp DataOutputStream cũng cung cấp các phương thức để ghi mảng byte và các đối tượng khác có thể được tuần tự hóa.\n\nĐể sử dụng lớp DataOutputStream, bạn cần tạo một đối tượng DataOutputStream. Bạn có thể tạo một đối tượng DataOutputStream bằng cách sử dụng constructor của lớp này. Constructor của lớp DataOutputStream nhận một đối tượng OutputStream làm đối số. Đối tượng OutputStream này là đối tượng mà bạn muốn ghi dữ liệu vào.\n\nSau khi đã tạo một đối tượng DataOutputStream, bạn có thể sử dụng các phương thức của lớp này để ghi dữ liệu vào đối tượng OutputStream. Ví dụ, bạn có thể sử dụng phương thức writeInt() để ghi một số nguyên vào đối tượng OutputStream. Bạn cũng có thể sử dụng phương thức writeFloat() để ghi một số thực vào đối tượng OutputStream.\n\nNgoài các phương thức để ghi các kiểu dữ liệu gốc, lớp DataOutputStream cũng cung cấp các phương thức để ghi mảng byte và các đối tượng khác có thể được tuần tự hóa. Ví dụ, bạn có thể sử dụng phương thức write() để ghi một mảng byte vào đối tượng OutputStream. Bạn cũng có thể sử dụng phương thức writeObject() để ghi một đối tượng có thể được tuần tự hóa vào đối tượng OutputStream.\n\nKhi bạn đã ghi tất cả dữ liệu mà bạn muốn ghi vào đối tượng DataOutputStream, bạn cần gọi phương thức close() của đối tượng DataOutputStream để đóng đối tượng này. Gọi phương thức close() sẽ ghi bất kỳ dữ liệu nào còn lại trong bộ đệm của đối tượng DataOutputStream vào đối tượng OutputStream và sau đó đóng đối tượng OutputStream.1. Hàm `write(byte[], int, int)` ghi một lượng byte được chỉ định từ một mảng byte đã cho vào luồng.\n\n2. Hàm `write(byte[])` ghi toàn bộ các byte trong một mảng byte đã cho vào luồng.\n\n3. Các hàm `writeBoolean()`, `writeByte()`, `writeShort()`, `writeInt()` ghi dữ liệu có kiểu gốc cụ thể vào luồng dưới dạng các byte.\n\n4. Hàm `flush()` xóa sạch luồng dữ liệu đầu ra.\n\n5. Hàm `writeBytes(String)` ghi một chuỗi tới luồng đầu ra dưới dạng một dãy các byte, mỗi ký tự trong chuỗi được ghi liên tiếp.DataOutputStream out = DataOutputStream(OutputStream out);\n\n, import java.io.*; public class Test{ public static void main(String\nargs[])throws IOException{ DataInputStream d = new DataInputStream(new\nFileInputStream(\"test.txt\")); DataOutputStream out = new DataOutputStream(new\nFileOutputStream(\"test1.txt\")); String count; while((count = d.readLine()) !=\nnull){ String u = count.toUpperCase(); System.out.println(u); out.writeBytes(u\n+ \" ,\"); } d.close(); out.close(); } }\n\n, DAY LA TEST 1 , DAY LA TEST 2 , DAY LA TEST 3 , DAY LA TEST 4 , DAY LA TEST 5\n,\n\n",
      "id": "541"
    }
  },
  {
    "id": "64",
    "name": "Lớp File",
    "href": "https://www.vietjack.com/java/lop_file_trong_java.jsp",
    "lesson": {
      "title": "lớp file trong java",
      "content": "Lớp File trong Java cung cấp một cách để thao tác với các file và thư mục trên hệ thống tệp. Nó cho phép bạn tạo, xóa, đổi tên, di chuyển và truy cập các file và thư mục.\n\nMột số phương thức phổ biến của lớp File bao gồm:\n\n* `exists()`: Kiểm tra xem một file hoặc thư mục có tồn tại hay không.\n* `isDirectory()`: Kiểm tra xem một file hoặc thư mục là thư mục hay không.\n* `isFile()`: Kiểm tra xem một file hoặc thư mục là file hay không.\n* `getName()`: Trả về tên của file hoặc thư mục.\n* `getPath()`: Trả về đường dẫn tuyệt đối của file hoặc thư mục.\n* `getParent()`: Trả về đường dẫn tuyệt đối của thư mục cha của file hoặc thư mục.\n* `createNewFile()`: Tạo một file mới nếu nó chưa tồn tại.\n* `delete()`: Xóa một file hoặc thư mục.\n* `renameTo()`: Đổi tên một file hoặc thư mục.\n* `mkdirs()`: Tạo một thư mục mới.\n* `listFiles()`: Trả về một mảng các file và thư mục trong một thư mục.\n\nLớp File cũng cung cấp một số phương thức tiện ích khác, chẳng hạn như `createTempFile()`, `listRoots()`, `getFreeSpace()`, `getTotalSpace()`, `getUsableSpace()`, `setLastModified()`, `canRead()`, `canWrite()`, `isHidden()`, `length()`, `lastModified()`, `toURI()`, `toPath()`, `getParentFile()`, `compareTo()` và `equals()`.\n\nBạn có thể sử dụng lớp File để thao tác với các file và thư mục theo nhiều cách khác nhau. Ví dụ, bạn có thể sử dụng nó để tạo một file mới, xóa một file hiện có, đổi tên một file, di chuyển một file, tạo một thư mục mới, xóa một thư mục hiện có, đổi tên một thư mục, di chuyển một thư mục, liệt kê các file và thư mục trong một thư mục, kiểm tra xem một file hoặc thư mục có tồn tại hay không, kiểm tra xem một file hoặc thư mục là file hay thư mục, kiểm tra xem một file hoặc thư mục có thể đọc được hay không, kiểm tra xem một file hoặc thư mục có thể ghi được hay không, kiểm tra xem một file hoặc thư mục có ẩn hay không, lấy kích thước của một file, lấy thời gian sửa đổi lần cuối của một file, chuyển đổi một đối tượng File thành một URI, chuyển đổi một đối tượng File thành một đối tượng Path, lấy đối tượng File của thư mục cha của một đối tượng File, so sánh hai đối tượng File và kiểm tra xem hai đối tượng File có bằng nhau hay không.1. Phương thức getName() sẽ trả về tên của file hoặc thư mục được biểu thị bởi pathname trừu tượng.\n\n\n2. Phương thức getParent() sẽ trả về chuỗi pathname của pathname trừu tượng cha, hoặc null nếu pathname này không là tên của một thư mục cha.\n\n\n3. Phương thức getParentFile() sẽ trả về pathname trừu tượng của pathname trừu tượng cha, hoặc null nếu pathname này không là tên của một thư mục cha.\n\n\n4. Phương thức getPath() sẽ biến đổi pathname trừu tượng này thành một chuỗi pathname.\n\n\n5. Phương thức isAbsolute() sẽ kiểm tra có hay không pathname trừu tượng này là absolute. Trả về true nếu là absolute, nếu không là false.\n\n\n6. Phương thức getAbsolutePath() sẽ trả về chuỗi pathname tuyệt đối của pathname trừu tượng này.\n\n\n7. Phương thức canRead() sẽ kiểm tra có hay không ứng dụng có thể đọc file, được biểu thị bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu file đã xác định bởi pathname trừu tượng này là tồn tại và có thể được đọc từ ứng dụng; nếu không là false.\n\n\n8. Phương thức canWrite() sẽ kiểm tra có hay không ứng dụng có thể sửa đổi file, được biểu thị bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu hệ thống file thực sự chứa một file được biểu thị bằng pathname trừu tượng này và ứng dụng được phép write tới file đó; nếu không là false.\n\n\n9. Phương thức exists() sẽ kiểm tra có hay không file hoặc thư mục được biểu thị bởi pathname trừu tượng này là tồn tại. Trả về true nếu và chỉ nếu file hoặc thư mục được biểu thị bởi pathname trừu tượng này là tồn tại; nếu không là false.\n\n\n10. Phương thức isDirectory() sẽ kiểm tra có hay không file được biểu thị bởi pathname trừu tượng này là một thư mục. Trả về true nếu và chỉ nếu file được biểu thị bởi pathname trừu tượng này là tồn tại và là một thư mục; nếu không là false.\n\n\n11. Phương thức isFile() sẽ kiểm tra có hay không file được biểu thị bởi pathname trừu tượng này là một normal file. Một file là normal nếu nó không là một thư mục và ngoài ra, thỏa mãn các tiêu chuẩn khác phụ thuộc vào hệ thống. Bất kỳ một non-directory file được tạo bởi một ứng dụng Java được bảo đảm là một normal file. Trả về true nếu và chỉ nếu file được biểu thị bởi pathname trừu tượng này là một normal file; nếu không là false.\n\n\n12. Phương thức lastModified() sẽ trả về time mà file được biểu thị bởi pathname trừu tượng này được sửa đổi lần cuối cùng. Trả về giá trị long biểu diễn thời gian mà file được sửa đổi lần cuối cùng, được tính toán bằng mili giây từ 00:00:00 GMT, 1/1/1970, hoặc 0L nếu file không tồn tại hoặc nếu một I/O error xuất hiện.\n\n\n13. Phương thức length() sẽ trả về độ dài của file được biểu thị bởi pathname trừu tượng này. Giá trị trả về là không rõ ràng nếu pathname này biểu thị một thư mục.\n\n\n14. Phương thức createNewFile() sẽ tạo một file mới, trống với tên pathname trừu tượng này nếu và chỉ nếu một file với tên này chưa tồn tại. Trả về true nếu và chỉ nếu file với tên này không tồn tại và được tạo thành công; nếu file với tên này đã tồn tại, thì trả về false.\n\n\n15. Phương thức delete() sẽ xóa file hoặc thư mục được biểu thị bởi pathname trừu tượng này. Nếu pathname này biểu thị một thư mục, thì thư mục phải là trống để bị xóa. Trả về true nếu và chỉ nếu file hoặc thư mục bị xóa thành công; nếu không là false.\n\n\n16. Phương thức deleteOnExit() sẽ yêu cầu rằng file hoặc thư mục được biểu thị bởi pathname trừu tượng này để bị xóa khi thiết bị ảo kết thúc.\n\n\n17. Phương thức list() sẽ trả về một mảng các chuỗi chỉ các file và thư mục trong thư mục được biểu thị bởi pathname trừu tượng này.\n\n\n18. Phương thức list(FilenameFilter filter) sẽ trả về một mảng các chuỗi chỉ các file và thư mục trong thư mục được biểu thị bởi pathname trừu tượng này mà thỏa mãn filter đã cho.\n\n\n19. Phương thức listFiles() sẽ trả về một mảng các pathname trừu tượng biểu thị các file trong thư mục được biểu thị bởi pathname trừu tượng này.\n\n\n20. Phương thức listFiles(FileFilter filter) sẽ trả về một mảng các pathname trừu tượng biểu thị các file và thư mục trong thư mục được biểu thị bởi pathname trừu tượng này mà thỏa mãn filter đã cho.\n\n\n21. Phương thức mkdir() sẽ tạo thư mục được chỉ bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu thư mục được tạo; nếu không là false.\n\n\n22. Phương thức mkdirs() sẽ tạo thư mục được chỉ bởi pathname trừu tượng này, bao gồm bất kỳ thư mục cha nào cần thiết nhưng không tồn tại. Trả về true nếu và chỉ nếu thư mục được tạo, cùng với tất cả thư mục cha cần thiết; nếu không là false.\n\n\n23. Phương thức renameTo(File dest) sẽ đổi tên file được biểu thị bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu việc đổi tên thành công; nếu không là false.\n\n\n24. Phương thức setLastModified(long time) sẽ thiết lập thời gian chỉnh sửa cuối cùng của file hoặc thư mục được chỉ bởi pathname trừu tượng này. Trả về true nếu và chỉ nếu hoạt động này thành công; nếu không là false.\n\n\n25. Phương thức setReadOnly() sẽ đánh dấu file hoặc thư mục được chỉ bởi pathname trừu tượng này để mà các hoạt động read-only được cho phép. Trả về true nếu hoạt động này thành công; nếu không là false.\n\n\n26. Phương thức createTempFile(String prefix, String suffix, File directory) sẽ tạo một file trống trong thư mục đã cho, bởi sử dụng các chuỗi tiền tố và hậu tố đã cung cấp để tạo tên của nó. Trả về pathname trừu tượng biểu thị một file trống mới được tạo.\n\n\n27. Phương thức createTempFile(String prefix, String suffix) sẽ tạo một file trống trong thư mục temporary-file, bởi sử dụng tiền tố và hậu tố đã cung cấp để tạo tên của nó. Triệu hồi phương thức này tương đương với gọi phương thức createTempFile(prefix, suffix, null). Trả về pathname trừu tượng biểu thị một file trống mới được tạo.\n\n\n28. Phương thức compareTo(File pathname) sẽ so sánh 2 pathname trừu tượng theo từ điển. Trả về 0 nếu tham số là cân bằng với pathname trừu tượng này, một giá trị nhỏ hơn 0 nếu pathname trừu tượng này nhỏ hơn tham số theo từ điển, hoặc một giá trị lớn hơn 0 nếu pathname trừu tượng này lớn hơn tham số theo từ điển.\n\n\n29. Phương thức compareTo(Object o) sẽ so sánh pathname trừu tượng này với đối tượng khác. Trả về 0 nếu tham số là cân bằng với pathname trừu tượng này, một giá trị nhỏ hơn 0 nếu pathname trừu tượng nhỏ hơn tham số theo từ điển, hoặc một giá trị lớn hơn 0 nếu pathname trừu tượng này lớn hơn tham số theo từ điển.\n\n\n30. Phương thức equals(Object obj) sẽ kiểm tra pathname trừu tượng này có cân bằng với đối tượng đã cung cấp không. Trả về true nếu và chỉ nếu tham số là không null và là một pathname trừu tượng mà biểu thị file hoặc thư mục giống như với pathname trừu tượng này.\n\n\n31. Phương thức toString() sẽ trả về chuỗi pathname của pathname trừu tượng này. Đây là chuỗi được trả về bởi phương thức getPath().File(File parent, String child);\n\n, File(String pathname)\n\n, File(String parent, String child)\n\n, File(URI uri)\n\n, package com.tutorialspoint; import java.io.File; public class FileDemo {\npublic static void main(String[] args) { File f = null; String[] strs =\n{\"test1.txt\", \"test2.txt\"}; try{ // voi moi string trong mang string\nfor(String s:strs ) { // tao file moi f= new File(s); // true neu file la\nexecutable boolean bool = f.canExecute(); // tim absolute path String a =\nf.getAbsolutePath(); // in absolute path System.out.print(a); // prints\nSystem.out.println(\" la executable: \"+ bool); } }catch(Exception e){ // neu co\nbat cu I/O error nao xuat hien e.printStackTrace(); } } }\n\n, test1.txt la executable: true test2.txt la executable: false\n\n",
      "id": "641"
    }
  },
  {
    "id": "74",
    "name": "Lớp FileReader",
    "href": "https://www.vietjack.com/java/lop_filereader_trong_java.jsp",
    "lesson": {
      "title": "lớp filereader trong java",
      "content": "Lớp `FileReader` trong Java là một lớp con của lớp `InputStreamReader` và được sử dụng để đọc các luồng ký tự. Lớp `FileReader` có một số constructor để tạo các đối tượng cần thiết. Cú pháp để tạo một `FileReader` mới trong Java được cung cấp tên file để đọc từ đó là:\n\n```\nFileReader(String fileName)\n```\n\nCú pháp để tạo một `FileReader` mới trong Java được cung cấp `FileDescriptor` để đọc từ đó là:\n\n```\nFileReader(FileDescriptor fd)\n```\n\nCú pháp để tạo một `FileReader` mới trong Java được cung cấp `File` để đọc từ đó là:\n\n```\nFileReader(File file)\n```\n\nKhi bạn có đối tượng `FileReader`, bạn có thể sử dụng một số phương thức sau để thao tác các file:\n\n* `int read()`: Đọc một ký tự đơn từ file và trả về một `int` biểu diễn ký tự đã đọc.\n* `int read(char[] cbuf)`: Đọc các ký tự từ file và lưu chúng vào mảng `char` được cung cấp. Trả về số ký tự đã đọc.\n* `void close()`: Đóng file.\n\nLớp `FileReader` được sử dụng rộng rãi để đọc các file văn bản trong Java.1. `public int read() throws IOException`\n\n   - Phương thức này đọc một ký tự đơn từ nguồn nhập.\n   - Trả về một số nguyên biểu diễn ký tự đã đọc.\n\n\n2. `public int read(char [] c, int offset, int len)`\n\n   - Phương thức này đọc các ký tự từ nguồn nhập và lưu chúng vào mảng `c`.\n   - Các ký tự được đọc bắt đầu từ vị trí `offset` trong mảng và tiếp tục cho đến khi đọc được `len` ký tự.\n   - Trả về số ký tự đã đọc.FileReader(File file)\n\n, FileReader(FileDescriptor fd)\n\n, FileReader(String fileName)\n\n, import java.io.*;public class FileRead{ public static void main(String\nargs[])throws IOException{ File file = new File(\"Hello1.txt\"); // tao file\nfile.createNewFile(); // tao mot doi tuong FileWriter FileWriter writer = new\nFileWriter(file); // ghi noi dung vao file writer.write(\"Day\\n la\\n mot\\n vi\\n\ndu\\n\"); writer.flush(); writer.close(); //Tao mot doi tuong FileReader\nFileReader fr = new FileReader(file); char [] a = new char[50]; fr.read(a); //\ndoc noi dung toi mang for(char c : a) System.out.print(c); //in tung ky tu mot\nfr.close(); } }\n\n, Day la mot vi du\n\n",
      "id": "741"
    }
  },
  {
    "id": "84",
    "name": "Lớp FileWriter",
    "href": "https://www.vietjack.com/java/lop_filewriter_trong_java.jsp",
    "lesson": {
      "title": "lớp filewriter trong java",
      "content": "- Lớp FileWriter trong Java được sử dụng để ghi các luồng ký tự vào tệp.\n- Có một số phương thức có thể được sử dụng để thao tác các tệp này.\n- Cú pháp để tạo một đối tượng FileWriter được cung cấp một tên tệp với một boolean chỉ dẫn có hay không phụ thêm dữ liệu đã ghi là:\n```java\nFileWriter(String fileName, boolean append)\n```\n- Cú pháp để tạo một đối tượng FileWriter được cung cấp một tên tệp là:\n```java\nFileWriter(String fileName)\n```\n- Cú pháp để tạo một đối tượng FileWriter mà liên kết với một file descriptor là:\n```java\nFileWriter(FileDescriptor fd)\n```\n- Cú pháp để tạo một đối tượng FileWriter được cung cấp một đối tượng File với một boolean chỉ dẫn có hay không phụ thêm dữ liệu đã ghi là:\n```java\nFileWriter(File file, boolean append)\n```\n- Cú pháp để tạo một đối tượng FileWriter được cung cấp một đối tượng File là:\n```java\nFileWriter(File file)\n```\n- Lớp FileWriter có một số constructor để tạo các đối tượng cần thiết.\n- Lớp FileWriter trong Java kế thừa từ lớp OutputStreamWriter lớp này được sử dụng để ghi các luồng ký tự.1. Hàm `write(int c)` cho phép ghi một ký tự đơn vào luồng dữ liệu.\n\n2. Hàm `write(char[] c, int offset, int len)` cho phép ghi một phần của mảng ký tự `c` vào luồng dữ liệu, bắt đầu từ chỉ mục `offset` và có độ dài `len`.\n\n3. Hàm `write(String s, int offset, int len)` cho phép ghi một phần của chuỗi `s` vào luồng dữ liệu, bắt đầu từ chỉ mục `offset` và có độ dài `len`.FileWriter(File file)\n\n, FileWriter(File file, boolean append)\n\n, FileWriter(FileDescriptor fd)\n\n, FileWriter(String fileName)\n\n, FileWriter(String fileName, boolean append)\n\n, import java.io.*; public class FileRead{ public static void main(String\nargs[])throws IOException{ File file = new File(\"Hello1.txt\"); // tao file\nfile.createNewFile(); // Tao mot doi tuong FileWriter FileWriter writer = new\nFileWriter(file); // ghi noi dung vao file writer.write(\"Day\\n la\\n mot\\n vi\\n\ndu\\n\"); writer.flush(); writer.close(); //Tao mot doi tuong FileReader\nFileReader fr = new FileReader(file); char [] a = new char[50]; fr.read(a); //\ndoc noi dung toi mang for(char c : a) System.out.print(c); //in tung ky tu mot\nfr.close(); } }\n\n, Day la mot vi du\n\n",
      "id": "841"
    }
  },
  {
    "id": "15",
    "name": "Đối tượng String",
    "href": "https://www.vietjack.com/java/string_trong_java.jsp",
    "lesson": {
      "title": "string trong java",
      "content": "Chuỗi là một tập hợp các ký tự liên tiếp trong Java. Lớp `String` được sử dụng để tạo các đối tượng chuỗi. Các đối tượng chuỗi không thể thay đổi, có nghĩa là chúng không thể bị thay đổi. Nếu bạn muốn sử dụng một lớp có thể thay đổi, bạn có thể sử dụng lớp `StringBuffer` hoặc `StringBuilder`.\n\nLớp `String` triển khai các giao diện `Serializable`, `Comparable` và `CharSequence`. Chuỗi trong Java là bất biến, có nghĩa là chúng không thể bị thay đổi. Tuy nhiên, bạn có thể tạo một đối tượng chuỗi mới bằng cách sử dụng phương thức `replace()`.\n\nChuỗi trong Java cung cấp nhiều khái niệm đa dạng giúp bạn thao tác và xử lý với chuỗi như so sánh, cắt nối, tìm độ dài, thay thế, tìm chuỗi con. Về cơ bản, chuỗi là một đối tượng biểu diễn một dãy các giá trị `char` (một mảng các ký tự).char[] ch={'j','a','v','a','t','p','o','i','n','t'}; String s=new String(ch);\n\n, String s=\"vietjack\";\n\n, String s=\"xinchao\";\n\n, String s1=\"xinchao\"; String s2=\"xinchao\";//se khong tao instance moi\n\n, String s=new String(\"xinchao\");//tao hai doi tuong va mot bien tham chieu\n\n, public class StringExample{ public static void main(String args[]){ String\ns1=\"java\";//tao string boi string literal char\nch[]={'s','t','r','i','n','g','s'}; String s2=new String(ch);//chuyen doi mang\nky tu thanh string String s3=new String(\"Vidu\");//tao string boi tu khoa new\nSystem.out.println(s1); System.out.println(s2); System.out.println(s3); }}\n\n, System.out.printf(\"Gia tri cua bien float la \" + \"%f, trong khi gia tri cua\nbien integer \" + \"bien la %d, va chuoi la \" + \"is %s\", floatVar, intVar,\nstringVar);\n\n, String fs; fs = String.format(\"Gia tri cua bien float la \" + \"%f, trong khi\ngia tri cua bien integer \" + \"bien la %d, va chuoi la \" + \"is %s\", floatVar,\nintVar, stringVar); System.out.println(fs);\n\n",
      "id": "151"
    }
  }
]